// node_modules/preact/dist/preact.module.js
var n;
var l;
var u;
var t;
var i;
var o;
var r;
var f;
var e;
var c = {};
var s = [];
var a = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
var v = Array.isArray;
function h(n2, l3) {
  for (var u3 in l3)
    n2[u3] = l3[u3];
  return n2;
}
function p(n2) {
  var l3 = n2.parentNode;
  l3 && l3.removeChild(n2);
}
function y(l3, u3, t4) {
  var i3, o3, r3, f3 = {};
  for (r3 in u3)
    "key" == r3 ? i3 = u3[r3] : "ref" == r3 ? o3 = u3[r3] : f3[r3] = u3[r3];
  if (arguments.length > 2 && (f3.children = arguments.length > 3 ? n.call(arguments, 2) : t4), "function" == typeof l3 && null != l3.defaultProps)
    for (r3 in l3.defaultProps)
      void 0 === f3[r3] && (f3[r3] = l3.defaultProps[r3]);
  return d(l3, f3, i3, o3, null);
}
function d(n2, t4, i3, o3, r3) {
  var f3 = { type: n2, props: t4, key: i3, ref: o3, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: null == r3 ? ++u : r3 };
  return null == r3 && null != l.vnode && l.vnode(f3), f3;
}
function k(n2) {
  return n2.children;
}
function b(n2, l3) {
  this.props = n2, this.context = l3;
}
function g(n2, l3) {
  if (null == l3)
    return n2.__ ? g(n2.__, n2.__.__k.indexOf(n2) + 1) : null;
  for (var u3; l3 < n2.__k.length; l3++)
    if (null != (u3 = n2.__k[l3]) && null != u3.__e)
      return u3.__d || u3.__e;
  return "function" == typeof n2.type ? g(n2) : null;
}
function m(n2) {
  var l3, u3;
  if (null != (n2 = n2.__) && null != n2.__c) {
    for (n2.__e = n2.__c.base = null, l3 = 0; l3 < n2.__k.length; l3++)
      if (null != (u3 = n2.__k[l3]) && null != u3.__e) {
        n2.__e = n2.__c.base = u3.__e;
        break;
      }
    return m(n2);
  }
}
function w(n2) {
  (!n2.__d && (n2.__d = true) && i.push(n2) && !x.__r++ || o !== l.debounceRendering) && ((o = l.debounceRendering) || r)(x);
}
function x() {
  var n2, l3, u3, t4, o3, r3, e3, c6, s4;
  for (i.sort(f); n2 = i.shift(); )
    n2.__d && (l3 = i.length, t4 = void 0, o3 = void 0, r3 = void 0, c6 = (e3 = (u3 = n2).__v).__e, (s4 = u3.__P) && (t4 = [], o3 = [], (r3 = h({}, e3)).__v = e3.__v + 1, z(s4, e3, r3, u3.__n, void 0 !== s4.ownerSVGElement, null != e3.__h ? [c6] : null, t4, null == c6 ? g(e3) : c6, e3.__h, o3), L(t4, e3, o3), e3.__e != c6 && m(e3)), i.length > l3 && i.sort(f));
  x.__r = 0;
}
function P(n2, l3, u3, t4, i3, o3, r3, f3, e3, a4, h3) {
  var p3, y3, _2, b3, m3, w3, x3, P2, C2, D3 = 0, H2 = t4 && t4.__k || s, I2 = H2.length, T2 = I2, j3 = l3.length;
  for (u3.__k = [], p3 = 0; p3 < j3; p3++)
    null != (b3 = u3.__k[p3] = null == (b3 = l3[p3]) || "boolean" == typeof b3 || "function" == typeof b3 ? null : "string" == typeof b3 || "number" == typeof b3 || "bigint" == typeof b3 ? d(null, b3, null, null, b3) : v(b3) ? d(k, { children: b3 }, null, null, null) : b3.__b > 0 ? d(b3.type, b3.props, b3.key, b3.ref ? b3.ref : null, b3.__v) : b3) ? (b3.__ = u3, b3.__b = u3.__b + 1, -1 === (P2 = A(b3, H2, x3 = p3 + D3, T2)) ? _2 = c : (_2 = H2[P2] || c, H2[P2] = void 0, T2--), z(n2, b3, _2, i3, o3, r3, f3, e3, a4, h3), m3 = b3.__e, (y3 = b3.ref) && _2.ref != y3 && (_2.ref && N(_2.ref, null, b3), h3.push(y3, b3.__c || m3, b3)), null != m3 && (null == w3 && (w3 = m3), (C2 = _2 === c || null === _2.__v) ? -1 == P2 && D3-- : P2 !== x3 && (P2 === x3 + 1 ? D3++ : P2 > x3 ? T2 > j3 - x3 ? D3 += P2 - x3 : D3-- : D3 = P2 < x3 && P2 == x3 - 1 ? P2 - x3 : 0), x3 = p3 + D3, "function" != typeof b3.type || P2 === x3 && _2.__k !== b3.__k ? "function" == typeof b3.type || P2 === x3 && !C2 ? void 0 !== b3.__d ? (e3 = b3.__d, b3.__d = void 0) : e3 = m3.nextSibling : e3 = S(n2, m3, e3) : e3 = $(b3, e3, n2), "function" == typeof u3.type && (u3.__d = e3))) : (_2 = H2[p3]) && null == _2.key && _2.__e && (_2.__e == e3 && (_2.__ = t4, e3 = g(_2)), O(_2, _2, false), H2[p3] = null);
  for (u3.__e = w3, p3 = I2; p3--; )
    null != H2[p3] && ("function" == typeof u3.type && null != H2[p3].__e && H2[p3].__e == u3.__d && (u3.__d = H2[p3].__e.nextSibling), O(H2[p3], H2[p3]));
}
function $(n2, l3, u3) {
  for (var t4, i3 = n2.__k, o3 = 0; i3 && o3 < i3.length; o3++)
    (t4 = i3[o3]) && (t4.__ = n2, l3 = "function" == typeof t4.type ? $(t4, l3, u3) : S(u3, t4.__e, l3));
  return l3;
}
function S(n2, l3, u3) {
  return null == u3 || u3.parentNode !== n2 ? n2.insertBefore(l3, null) : l3 == u3 && null != l3.parentNode || n2.insertBefore(l3, u3), l3.nextSibling;
}
function A(n2, l3, u3, t4) {
  var i3 = n2.key, o3 = n2.type, r3 = u3 - 1, f3 = u3 + 1, e3 = l3[u3];
  if (null === e3 || e3 && i3 == e3.key && o3 === e3.type)
    return u3;
  if (t4 > (null != e3 ? 1 : 0))
    for (; r3 >= 0 || f3 < l3.length; ) {
      if (r3 >= 0) {
        if ((e3 = l3[r3]) && i3 == e3.key && o3 === e3.type)
          return r3;
        r3--;
      }
      if (f3 < l3.length) {
        if ((e3 = l3[f3]) && i3 == e3.key && o3 === e3.type)
          return f3;
        f3++;
      }
    }
  return -1;
}
function D(n2, l3, u3, t4, i3) {
  var o3;
  for (o3 in u3)
    "children" === o3 || "key" === o3 || o3 in l3 || I(n2, o3, null, u3[o3], t4);
  for (o3 in l3)
    i3 && "function" != typeof l3[o3] || "children" === o3 || "key" === o3 || "value" === o3 || "checked" === o3 || u3[o3] === l3[o3] || I(n2, o3, l3[o3], u3[o3], t4);
}
function H(n2, l3, u3) {
  "-" === l3[0] ? n2.setProperty(l3, null == u3 ? "" : u3) : n2[l3] = null == u3 ? "" : "number" != typeof u3 || a.test(l3) ? u3 : u3 + "px";
}
function I(n2, l3, u3, t4, i3) {
  var o3;
  n:
    if ("style" === l3)
      if ("string" == typeof u3)
        n2.style.cssText = u3;
      else {
        if ("string" == typeof t4 && (n2.style.cssText = t4 = ""), t4)
          for (l3 in t4)
            u3 && l3 in u3 || H(n2.style, l3, "");
        if (u3)
          for (l3 in u3)
            t4 && u3[l3] === t4[l3] || H(n2.style, l3, u3[l3]);
      }
    else if ("o" === l3[0] && "n" === l3[1])
      o3 = l3 !== (l3 = l3.replace(/(PointerCapture)$|Capture$/, "$1")), l3 = l3.toLowerCase() in n2 ? l3.toLowerCase().slice(2) : l3.slice(2), n2.l || (n2.l = {}), n2.l[l3 + o3] = u3, u3 ? t4 ? u3.u = t4.u : (u3.u = Date.now(), n2.addEventListener(l3, o3 ? j : T, o3)) : n2.removeEventListener(l3, o3 ? j : T, o3);
    else if ("dangerouslySetInnerHTML" !== l3) {
      if (i3)
        l3 = l3.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if ("width" !== l3 && "height" !== l3 && "href" !== l3 && "list" !== l3 && "form" !== l3 && "tabIndex" !== l3 && "download" !== l3 && "rowSpan" !== l3 && "colSpan" !== l3 && "role" !== l3 && l3 in n2)
        try {
          n2[l3] = null == u3 ? "" : u3;
          break n;
        } catch (n3) {
        }
      "function" == typeof u3 || (null == u3 || false === u3 && "-" !== l3[4] ? n2.removeAttribute(l3) : n2.setAttribute(l3, u3));
    }
}
function T(n2) {
  var u3 = this.l[n2.type + false];
  if (n2.t) {
    if (n2.t <= u3.u)
      return;
  } else
    n2.t = Date.now();
  return u3(l.event ? l.event(n2) : n2);
}
function j(n2) {
  return this.l[n2.type + true](l.event ? l.event(n2) : n2);
}
function z(n2, u3, t4, i3, o3, r3, f3, e3, c6, s4) {
  var a4, p3, y3, d3, _2, g3, m3, w3, x3, $2, C2, S2, A5, D3, H2, I2 = u3.type;
  if (void 0 !== u3.constructor)
    return null;
  null != t4.__h && (c6 = t4.__h, e3 = u3.__e = t4.__e, u3.__h = null, r3 = [e3]), (a4 = l.__b) && a4(u3);
  n:
    if ("function" == typeof I2)
      try {
        if (w3 = u3.props, x3 = (a4 = I2.contextType) && i3[a4.__c], $2 = a4 ? x3 ? x3.props.value : a4.__ : i3, t4.__c ? m3 = (p3 = u3.__c = t4.__c).__ = p3.__E : ("prototype" in I2 && I2.prototype.render ? u3.__c = p3 = new I2(w3, $2) : (u3.__c = p3 = new b(w3, $2), p3.constructor = I2, p3.render = q), x3 && x3.sub(p3), p3.props = w3, p3.state || (p3.state = {}), p3.context = $2, p3.__n = i3, y3 = p3.__d = true, p3.__h = [], p3._sb = []), null == p3.__s && (p3.__s = p3.state), null != I2.getDerivedStateFromProps && (p3.__s == p3.state && (p3.__s = h({}, p3.__s)), h(p3.__s, I2.getDerivedStateFromProps(w3, p3.__s))), d3 = p3.props, _2 = p3.state, p3.__v = u3, y3)
          null == I2.getDerivedStateFromProps && null != p3.componentWillMount && p3.componentWillMount(), null != p3.componentDidMount && p3.__h.push(p3.componentDidMount);
        else {
          if (null == I2.getDerivedStateFromProps && w3 !== d3 && null != p3.componentWillReceiveProps && p3.componentWillReceiveProps(w3, $2), !p3.__e && (null != p3.shouldComponentUpdate && false === p3.shouldComponentUpdate(w3, p3.__s, $2) || u3.__v === t4.__v)) {
            for (u3.__v !== t4.__v && (p3.props = w3, p3.state = p3.__s, p3.__d = false), u3.__e = t4.__e, u3.__k = t4.__k, u3.__k.forEach(function(n3) {
              n3 && (n3.__ = u3);
            }), C2 = 0; C2 < p3._sb.length; C2++)
              p3.__h.push(p3._sb[C2]);
            p3._sb = [], p3.__h.length && f3.push(p3);
            break n;
          }
          null != p3.componentWillUpdate && p3.componentWillUpdate(w3, p3.__s, $2), null != p3.componentDidUpdate && p3.__h.push(function() {
            p3.componentDidUpdate(d3, _2, g3);
          });
        }
        if (p3.context = $2, p3.props = w3, p3.__P = n2, p3.__e = false, S2 = l.__r, A5 = 0, "prototype" in I2 && I2.prototype.render) {
          for (p3.state = p3.__s, p3.__d = false, S2 && S2(u3), a4 = p3.render(p3.props, p3.state, p3.context), D3 = 0; D3 < p3._sb.length; D3++)
            p3.__h.push(p3._sb[D3]);
          p3._sb = [];
        } else
          do {
            p3.__d = false, S2 && S2(u3), a4 = p3.render(p3.props, p3.state, p3.context), p3.state = p3.__s;
          } while (p3.__d && ++A5 < 25);
        p3.state = p3.__s, null != p3.getChildContext && (i3 = h(h({}, i3), p3.getChildContext())), y3 || null == p3.getSnapshotBeforeUpdate || (g3 = p3.getSnapshotBeforeUpdate(d3, _2)), P(n2, v(H2 = null != a4 && a4.type === k && null == a4.key ? a4.props.children : a4) ? H2 : [H2], u3, t4, i3, o3, r3, f3, e3, c6, s4), p3.base = u3.__e, u3.__h = null, p3.__h.length && f3.push(p3), m3 && (p3.__E = p3.__ = null);
      } catch (n3) {
        u3.__v = null, (c6 || null != r3) && (u3.__e = e3, u3.__h = !!c6, r3[r3.indexOf(e3)] = null), l.__e(n3, u3, t4);
      }
    else
      null == r3 && u3.__v === t4.__v ? (u3.__k = t4.__k, u3.__e = t4.__e) : u3.__e = M(t4.__e, u3, t4, i3, o3, r3, f3, c6, s4);
  (a4 = l.diffed) && a4(u3);
}
function L(n2, u3, t4) {
  for (var i3 = 0; i3 < t4.length; i3++)
    N(t4[i3], t4[++i3], t4[++i3]);
  l.__c && l.__c(u3, n2), n2.some(function(u4) {
    try {
      n2 = u4.__h, u4.__h = [], n2.some(function(n3) {
        n3.call(u4);
      });
    } catch (n3) {
      l.__e(n3, u4.__v);
    }
  });
}
function M(l3, u3, t4, i3, o3, r3, f3, e3, s4) {
  var a4, h3, y3, d3 = t4.props, _2 = u3.props, k4 = u3.type, b3 = 0;
  if ("svg" === k4 && (o3 = true), null != r3) {
    for (; b3 < r3.length; b3++)
      if ((a4 = r3[b3]) && "setAttribute" in a4 == !!k4 && (k4 ? a4.localName === k4 : 3 === a4.nodeType)) {
        l3 = a4, r3[b3] = null;
        break;
      }
  }
  if (null == l3) {
    if (null === k4)
      return document.createTextNode(_2);
    l3 = o3 ? document.createElementNS("http://www.w3.org/2000/svg", k4) : document.createElement(k4, _2.is && _2), r3 = null, e3 = false;
  }
  if (null === k4)
    d3 === _2 || e3 && l3.data === _2 || (l3.data = _2);
  else {
    if (r3 = r3 && n.call(l3.childNodes), h3 = (d3 = t4.props || c).dangerouslySetInnerHTML, y3 = _2.dangerouslySetInnerHTML, !e3) {
      if (null != r3)
        for (d3 = {}, b3 = 0; b3 < l3.attributes.length; b3++)
          d3[l3.attributes[b3].name] = l3.attributes[b3].value;
      (y3 || h3) && (y3 && (h3 && y3.__html == h3.__html || y3.__html === l3.innerHTML) || (l3.innerHTML = y3 && y3.__html || ""));
    }
    if (D(l3, _2, d3, o3, e3), y3)
      u3.__k = [];
    else if (P(l3, v(b3 = u3.props.children) ? b3 : [b3], u3, t4, i3, o3 && "foreignObject" !== k4, r3, f3, r3 ? r3[0] : t4.__k && g(t4, 0), e3, s4), null != r3)
      for (b3 = r3.length; b3--; )
        null != r3[b3] && p(r3[b3]);
    e3 || ("value" in _2 && void 0 !== (b3 = _2.value) && (b3 !== l3.value || "progress" === k4 && !b3 || "option" === k4 && b3 !== d3.value) && I(l3, "value", b3, d3.value, false), "checked" in _2 && void 0 !== (b3 = _2.checked) && b3 !== l3.checked && I(l3, "checked", b3, d3.checked, false));
  }
  return l3;
}
function N(n2, u3, t4) {
  try {
    "function" == typeof n2 ? n2(u3) : n2.current = u3;
  } catch (n3) {
    l.__e(n3, t4);
  }
}
function O(n2, u3, t4) {
  var i3, o3;
  if (l.unmount && l.unmount(n2), (i3 = n2.ref) && (i3.current && i3.current !== n2.__e || N(i3, null, u3)), null != (i3 = n2.__c)) {
    if (i3.componentWillUnmount)
      try {
        i3.componentWillUnmount();
      } catch (n3) {
        l.__e(n3, u3);
      }
    i3.base = i3.__P = null, n2.__c = void 0;
  }
  if (i3 = n2.__k)
    for (o3 = 0; o3 < i3.length; o3++)
      i3[o3] && O(i3[o3], u3, t4 || "function" != typeof n2.type);
  t4 || null == n2.__e || p(n2.__e), n2.__ = n2.__e = n2.__d = void 0;
}
function q(n2, l3, u3) {
  return this.constructor(n2, u3);
}
function B(u3, t4, i3) {
  var o3, r3, f3, e3;
  l.__ && l.__(u3, t4), r3 = (o3 = "function" == typeof i3) ? null : i3 && i3.__k || t4.__k, f3 = [], e3 = [], z(t4, u3 = (!o3 && i3 || t4).__k = y(k, null, [u3]), r3 || c, c, void 0 !== t4.ownerSVGElement, !o3 && i3 ? [i3] : r3 ? null : t4.firstChild ? n.call(t4.childNodes) : null, f3, !o3 && i3 ? i3 : r3 ? r3.__e : t4.firstChild, o3, e3), L(f3, u3, e3);
}
n = s.slice, l = { __e: function(n2, l3, u3, t4) {
  for (var i3, o3, r3; l3 = l3.__; )
    if ((i3 = l3.__c) && !i3.__)
      try {
        if ((o3 = i3.constructor) && null != o3.getDerivedStateFromError && (i3.setState(o3.getDerivedStateFromError(n2)), r3 = i3.__d), null != i3.componentDidCatch && (i3.componentDidCatch(n2, t4 || {}), r3 = i3.__d), r3)
          return i3.__E = i3;
      } catch (l4) {
        n2 = l4;
      }
  throw n2;
} }, u = 0, t = function(n2) {
  return null != n2 && void 0 === n2.constructor;
}, b.prototype.setState = function(n2, l3) {
  var u3;
  u3 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = h({}, this.state), "function" == typeof n2 && (n2 = n2(h({}, u3), this.props)), n2 && h(u3, n2), null != n2 && this.__v && (l3 && this._sb.push(l3), w(this));
}, b.prototype.forceUpdate = function(n2) {
  this.__v && (this.__e = true, n2 && this.__h.push(n2), w(this));
}, b.prototype.render = k, i = [], r = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, f = function(n2, l3) {
  return n2.__v.__b - l3.__v.__b;
}, x.__r = 0, e = 0;

// node_modules/preact/hooks/dist/hooks.module.js
var t2;
var r2;
var u2;
var i2;
var o2 = 0;
var f2 = [];
var c2 = [];
var e2 = l.__b;
var a2 = l.__r;
var v2 = l.diffed;
var l2 = l.__c;
var m2 = l.unmount;
function d2(t4, u3) {
  l.__h && l.__h(r2, t4, o2 || u3), o2 = 0;
  var i3 = r2.__H || (r2.__H = { __: [], __h: [] });
  return t4 >= i3.__.length && i3.__.push({ __V: c2 }), i3.__[t4];
}
function h2(n2) {
  return o2 = 1, s2(B2, n2);
}
function s2(n2, u3, i3) {
  var o3 = d2(t2++, 2);
  if (o3.t = n2, !o3.__c && (o3.__ = [i3 ? i3(u3) : B2(void 0, u3), function(n3) {
    var t4 = o3.__N ? o3.__N[0] : o3.__[0], r3 = o3.t(t4, n3);
    t4 !== r3 && (o3.__N = [r3, o3.__[1]], o3.__c.setState({}));
  }], o3.__c = r2, !r2.u)) {
    var f3 = function(n3, t4, r3) {
      if (!o3.__c.__H)
        return true;
      var u4 = o3.__c.__H.__.filter(function(n4) {
        return n4.__c;
      });
      if (u4.every(function(n4) {
        return !n4.__N;
      }))
        return !c6 || c6.call(this, n3, t4, r3);
      var i4 = false;
      return u4.forEach(function(n4) {
        if (n4.__N) {
          var t5 = n4.__[0];
          n4.__ = n4.__N, n4.__N = void 0, t5 !== n4.__[0] && (i4 = true);
        }
      }), !(!i4 && o3.__c.props === n3) && (!c6 || c6.call(this, n3, t4, r3));
    };
    r2.u = true;
    var c6 = r2.shouldComponentUpdate, e3 = r2.componentWillUpdate;
    r2.componentWillUpdate = function(n3, t4, r3) {
      if (this.__e) {
        var u4 = c6;
        c6 = void 0, f3(n3, t4, r3), c6 = u4;
      }
      e3 && e3.call(this, n3, t4, r3);
    }, r2.shouldComponentUpdate = f3;
  }
  return o3.__N || o3.__;
}
function p2(u3, i3) {
  var o3 = d2(t2++, 3);
  !l.__s && z2(o3.__H, i3) && (o3.__ = u3, o3.i = i3, r2.__H.__h.push(o3));
}
function _(n2) {
  return o2 = 5, F(function() {
    return { current: n2 };
  }, []);
}
function F(n2, r3) {
  var u3 = d2(t2++, 7);
  return z2(u3.__H, r3) ? (u3.__V = n2(), u3.i = r3, u3.__h = n2, u3.__V) : u3.__;
}
function b2() {
  for (var t4; t4 = f2.shift(); )
    if (t4.__P && t4.__H)
      try {
        t4.__H.__h.forEach(k2), t4.__H.__h.forEach(w2), t4.__H.__h = [];
      } catch (r3) {
        t4.__H.__h = [], l.__e(r3, t4.__v);
      }
}
l.__b = function(n2) {
  r2 = null, e2 && e2(n2);
}, l.__r = function(n2) {
  a2 && a2(n2), t2 = 0;
  var i3 = (r2 = n2.__c).__H;
  i3 && (u2 === r2 ? (i3.__h = [], r2.__h = [], i3.__.forEach(function(n3) {
    n3.__N && (n3.__ = n3.__N), n3.__V = c2, n3.__N = n3.i = void 0;
  })) : (i3.__h.forEach(k2), i3.__h.forEach(w2), i3.__h = [], t2 = 0)), u2 = r2;
}, l.diffed = function(t4) {
  v2 && v2(t4);
  var o3 = t4.__c;
  o3 && o3.__H && (o3.__H.__h.length && (1 !== f2.push(o3) && i2 === l.requestAnimationFrame || ((i2 = l.requestAnimationFrame) || j2)(b2)), o3.__H.__.forEach(function(n2) {
    n2.i && (n2.__H = n2.i), n2.__V !== c2 && (n2.__ = n2.__V), n2.i = void 0, n2.__V = c2;
  })), u2 = r2 = null;
}, l.__c = function(t4, r3) {
  r3.some(function(t5) {
    try {
      t5.__h.forEach(k2), t5.__h = t5.__h.filter(function(n2) {
        return !n2.__ || w2(n2);
      });
    } catch (u3) {
      r3.some(function(n2) {
        n2.__h && (n2.__h = []);
      }), r3 = [], l.__e(u3, t5.__v);
    }
  }), l2 && l2(t4, r3);
}, l.unmount = function(t4) {
  m2 && m2(t4);
  var r3, u3 = t4.__c;
  u3 && u3.__H && (u3.__H.__.forEach(function(n2) {
    try {
      k2(n2);
    } catch (n3) {
      r3 = n3;
    }
  }), u3.__H = void 0, r3 && l.__e(r3, u3.__v));
};
var g2 = "function" == typeof requestAnimationFrame;
function j2(n2) {
  var t4, r3 = function() {
    clearTimeout(u3), g2 && cancelAnimationFrame(t4), setTimeout(n2);
  }, u3 = setTimeout(r3, 100);
  g2 && (t4 = requestAnimationFrame(r3));
}
function k2(n2) {
  var t4 = r2, u3 = n2.__c;
  "function" == typeof u3 && (n2.__c = void 0, u3()), r2 = t4;
}
function w2(n2) {
  var t4 = r2;
  n2.__c = n2.__(), r2 = t4;
}
function z2(n2, t4) {
  return !n2 || n2.length !== t4.length || t4.some(function(t5, r3) {
    return t5 !== n2[r3];
  });
}
function B2(n2, t4) {
  return "function" == typeof t4 ? t4(n2) : t4;
}

// node_modules/d3-array/src/ascending.js
function ascending(a4, b3) {
  return a4 == null || b3 == null ? NaN : a4 < b3 ? -1 : a4 > b3 ? 1 : a4 >= b3 ? 0 : NaN;
}

// node_modules/d3-array/src/descending.js
function descending(a4, b3) {
  return a4 == null || b3 == null ? NaN : b3 < a4 ? -1 : b3 > a4 ? 1 : b3 >= a4 ? 0 : NaN;
}

// node_modules/d3-array/src/bisector.js
function bisector(f3) {
  let compare1, compare2, delta;
  if (f3.length !== 2) {
    compare1 = ascending;
    compare2 = (d3, x3) => ascending(f3(d3), x3);
    delta = (d3, x3) => f3(d3) - x3;
  } else {
    compare1 = f3 === ascending || f3 === descending ? f3 : zero;
    compare2 = f3;
    delta = f3;
  }
  function left2(a4, x3, lo = 0, hi = a4.length) {
    if (lo < hi) {
      if (compare1(x3, x3) !== 0)
        return hi;
      do {
        const mid2 = lo + hi >>> 1;
        if (compare2(a4[mid2], x3) < 0)
          lo = mid2 + 1;
        else
          hi = mid2;
      } while (lo < hi);
    }
    return lo;
  }
  function right2(a4, x3, lo = 0, hi = a4.length) {
    if (lo < hi) {
      if (compare1(x3, x3) !== 0)
        return hi;
      do {
        const mid2 = lo + hi >>> 1;
        if (compare2(a4[mid2], x3) <= 0)
          lo = mid2 + 1;
        else
          hi = mid2;
      } while (lo < hi);
    }
    return lo;
  }
  function center2(a4, x3, lo = 0, hi = a4.length) {
    const i3 = left2(a4, x3, lo, hi - 1);
    return i3 > lo && delta(a4[i3 - 1], x3) > -delta(a4[i3], x3) ? i3 - 1 : i3;
  }
  return { left: left2, center: center2, right: right2 };
}
function zero() {
  return 0;
}

// node_modules/d3-array/src/number.js
function number(x3) {
  return x3 === null ? NaN : +x3;
}
function* numbers(values2, valueof2) {
  if (valueof2 === void 0) {
    for (let value of values2) {
      if (value != null && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && (value = +value) >= value) {
        yield value;
      }
    }
  }
}

// node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector(number).center;
var bisect_default = bisectRight;

// node_modules/d3-array/src/count.js
function count(values2, valueof2) {
  let count2 = 0;
  if (valueof2 === void 0) {
    for (let value of values2) {
      if (value != null && (value = +value) >= value) {
        ++count2;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && (value = +value) >= value) {
        ++count2;
      }
    }
  }
  return count2;
}

// node_modules/d3-array/src/cross.js
function length(array2) {
  return array2.length | 0;
}
function empty(length3) {
  return !(length3 > 0);
}
function arrayify(values2) {
  return typeof values2 !== "object" || "length" in values2 ? values2 : Array.from(values2);
}
function reducer(reduce) {
  return (values2) => reduce(...values2);
}
function cross(...values2) {
  const reduce = typeof values2[values2.length - 1] === "function" && reducer(values2.pop());
  values2 = values2.map(arrayify);
  const lengths = values2.map(length);
  const j3 = values2.length - 1;
  const index2 = new Array(j3 + 1).fill(0);
  const product = [];
  if (j3 < 0 || lengths.some(empty))
    return product;
  while (true) {
    product.push(index2.map((j4, i4) => values2[i4][j4]));
    let i3 = j3;
    while (++index2[i3] === lengths[i3]) {
      if (i3 === 0)
        return reduce ? product.map(reduce) : product;
      index2[i3--] = 0;
    }
  }
}

// node_modules/d3-array/src/variance.js
function variance(values2, valueof2) {
  let count2 = 0;
  let delta;
  let mean2 = 0;
  let sum2 = 0;
  if (valueof2 === void 0) {
    for (let value of values2) {
      if (value != null && (value = +value) >= value) {
        delta = value - mean2;
        mean2 += delta / ++count2;
        sum2 += delta * (value - mean2);
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && (value = +value) >= value) {
        delta = value - mean2;
        mean2 += delta / ++count2;
        sum2 += delta * (value - mean2);
      }
    }
  }
  if (count2 > 1)
    return sum2 / (count2 - 1);
}

// node_modules/d3-array/src/deviation.js
function deviation(values2, valueof2) {
  const v3 = variance(values2, valueof2);
  return v3 ? Math.sqrt(v3) : v3;
}

// node_modules/d3-array/src/extent.js
function extent(values2, valueof2) {
  let min4;
  let max3;
  if (valueof2 === void 0) {
    for (const value of values2) {
      if (value != null) {
        if (min4 === void 0) {
          if (value >= value)
            min4 = max3 = value;
        } else {
          if (min4 > value)
            min4 = value;
          if (max3 < value)
            max3 = value;
        }
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null) {
        if (min4 === void 0) {
          if (value >= value)
            min4 = max3 = value;
        } else {
          if (min4 > value)
            min4 = value;
          if (max3 < value)
            max3 = value;
        }
      }
    }
  }
  return [min4, max3];
}

// node_modules/d3-array/src/fsum.js
var Adder = class {
  constructor() {
    this._partials = new Float64Array(32);
    this._n = 0;
  }
  add(x3) {
    const p3 = this._partials;
    let i3 = 0;
    for (let j3 = 0; j3 < this._n && j3 < 32; j3++) {
      const y3 = p3[j3], hi = x3 + y3, lo = Math.abs(x3) < Math.abs(y3) ? x3 - (hi - y3) : y3 - (hi - x3);
      if (lo)
        p3[i3++] = lo;
      x3 = hi;
    }
    p3[i3] = x3;
    this._n = i3 + 1;
    return this;
  }
  valueOf() {
    const p3 = this._partials;
    let n2 = this._n, x3, y3, lo, hi = 0;
    if (n2 > 0) {
      hi = p3[--n2];
      while (n2 > 0) {
        x3 = hi;
        y3 = p3[--n2];
        hi = x3 + y3;
        lo = y3 - (hi - x3);
        if (lo)
          break;
      }
      if (n2 > 0 && (lo < 0 && p3[n2 - 1] < 0 || lo > 0 && p3[n2 - 1] > 0)) {
        y3 = lo * 2;
        x3 = hi + y3;
        if (y3 == x3 - hi)
          hi = x3;
      }
    }
    return hi;
  }
};

// node_modules/internmap/src/index.js
var InternMap = class extends Map {
  constructor(entries, key = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
    if (entries != null)
      for (const [key2, value] of entries)
        this.set(key2, value);
  }
  get(key) {
    return super.get(intern_get(this, key));
  }
  has(key) {
    return super.has(intern_get(this, key));
  }
  set(key, value) {
    return super.set(intern_set(this, key), value);
  }
  delete(key) {
    return super.delete(intern_delete(this, key));
  }
};
var InternSet = class extends Set {
  constructor(values2, key = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
    if (values2 != null)
      for (const value of values2)
        this.add(value);
  }
  has(value) {
    return super.has(intern_get(this, value));
  }
  add(value) {
    return super.add(intern_set(this, value));
  }
  delete(value) {
    return super.delete(intern_delete(this, value));
  }
};
function intern_get({ _intern, _key }, value) {
  const key = _key(value);
  return _intern.has(key) ? _intern.get(key) : value;
}
function intern_set({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key))
    return _intern.get(key);
  _intern.set(key, value);
  return value;
}
function intern_delete({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key)) {
    value = _intern.get(key);
    _intern.delete(key);
  }
  return value;
}
function keyof(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}

// node_modules/d3-array/src/identity.js
function identity(x3) {
  return x3;
}

// node_modules/d3-array/src/group.js
function group(values2, ...keys) {
  return nest(values2, identity, identity, keys);
}
function rollup(values2, reduce, ...keys) {
  return nest(values2, identity, reduce, keys);
}
function rollups(values2, reduce, ...keys) {
  return nest(values2, Array.from, reduce, keys);
}
function nest(values2, map3, reduce, keys) {
  return function regroup(values3, i3) {
    if (i3 >= keys.length)
      return reduce(values3);
    const groups2 = new InternMap();
    const keyof3 = keys[i3++];
    let index2 = -1;
    for (const value of values3) {
      const key = keyof3(value, ++index2, values3);
      const group2 = groups2.get(key);
      if (group2)
        group2.push(value);
      else
        groups2.set(key, [value]);
    }
    for (const [key, values4] of groups2) {
      groups2.set(key, regroup(values4, i3));
    }
    return map3(groups2);
  }(values2, 0);
}

// node_modules/d3-array/src/permute.js
function permute(source, keys) {
  return Array.from(keys, (key) => source[key]);
}

// node_modules/d3-array/src/sort.js
function sort(values2, ...F2) {
  if (typeof values2[Symbol.iterator] !== "function")
    throw new TypeError("values is not iterable");
  values2 = Array.from(values2);
  let [f3] = F2;
  if (f3 && f3.length !== 2 || F2.length > 1) {
    const index2 = Uint32Array.from(values2, (d3, i3) => i3);
    if (F2.length > 1) {
      F2 = F2.map((f4) => values2.map(f4));
      index2.sort((i3, j3) => {
        for (const f4 of F2) {
          const c6 = ascendingDefined(f4[i3], f4[j3]);
          if (c6)
            return c6;
        }
      });
    } else {
      f3 = values2.map(f3);
      index2.sort((i3, j3) => ascendingDefined(f3[i3], f3[j3]));
    }
    return permute(values2, index2);
  }
  return values2.sort(compareDefined(f3));
}
function compareDefined(compare = ascending) {
  if (compare === ascending)
    return ascendingDefined;
  if (typeof compare !== "function")
    throw new TypeError("compare is not a function");
  return (a4, b3) => {
    const x3 = compare(a4, b3);
    if (x3 || x3 === 0)
      return x3;
    return (compare(b3, b3) === 0) - (compare(a4, a4) === 0);
  };
}
function ascendingDefined(a4, b3) {
  return (a4 == null || !(a4 >= a4)) - (b3 == null || !(b3 >= b3)) || (a4 < b3 ? -1 : a4 > b3 ? 1 : 0);
}

// node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e22 = Math.sqrt(2);
function tickSpec(start2, stop, count2) {
  const step = (stop - start2) / Math.max(0, count2), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e22 ? 2 : 1;
  let i1, i22, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start2 * inc);
    i22 = Math.round(stop * inc);
    if (i1 / inc < start2)
      ++i1;
    if (i22 / inc > stop)
      --i22;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start2 / inc);
    i22 = Math.round(stop / inc);
    if (i1 * inc < start2)
      ++i1;
    if (i22 * inc > stop)
      --i22;
  }
  if (i22 < i1 && 0.5 <= count2 && count2 < 2)
    return tickSpec(start2, stop, count2 * 2);
  return [i1, i22, inc];
}
function ticks(start2, stop, count2) {
  stop = +stop, start2 = +start2, count2 = +count2;
  if (!(count2 > 0))
    return [];
  if (start2 === stop)
    return [start2];
  const reverse2 = stop < start2, [i1, i22, inc] = reverse2 ? tickSpec(stop, start2, count2) : tickSpec(start2, stop, count2);
  if (!(i22 >= i1))
    return [];
  const n2 = i22 - i1 + 1, ticks2 = new Array(n2);
  if (reverse2) {
    if (inc < 0)
      for (let i3 = 0; i3 < n2; ++i3)
        ticks2[i3] = (i22 - i3) / -inc;
    else
      for (let i3 = 0; i3 < n2; ++i3)
        ticks2[i3] = (i22 - i3) * inc;
  } else {
    if (inc < 0)
      for (let i3 = 0; i3 < n2; ++i3)
        ticks2[i3] = (i1 + i3) / -inc;
    else
      for (let i3 = 0; i3 < n2; ++i3)
        ticks2[i3] = (i1 + i3) * inc;
  }
  return ticks2;
}
function tickIncrement(start2, stop, count2) {
  stop = +stop, start2 = +start2, count2 = +count2;
  return tickSpec(start2, stop, count2)[2];
}
function tickStep(start2, stop, count2) {
  stop = +stop, start2 = +start2, count2 = +count2;
  const reverse2 = stop < start2, inc = reverse2 ? tickIncrement(stop, start2, count2) : tickIncrement(start2, stop, count2);
  return (reverse2 ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}

// node_modules/d3-array/src/threshold/sturges.js
function thresholdSturges(values2) {
  return Math.max(1, Math.ceil(Math.log(count(values2)) / Math.LN2) + 1);
}

// node_modules/d3-array/src/max.js
function max(values2, valueof2) {
  let max3;
  if (valueof2 === void 0) {
    for (const value of values2) {
      if (value != null && (max3 < value || max3 === void 0 && value >= value)) {
        max3 = value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && (max3 < value || max3 === void 0 && value >= value)) {
        max3 = value;
      }
    }
  }
  return max3;
}

// node_modules/d3-array/src/maxIndex.js
function maxIndex(values2, valueof2) {
  let max3;
  let maxIndex2 = -1;
  let index2 = -1;
  if (valueof2 === void 0) {
    for (const value of values2) {
      ++index2;
      if (value != null && (max3 < value || max3 === void 0 && value >= value)) {
        max3 = value, maxIndex2 = index2;
      }
    }
  } else {
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && (max3 < value || max3 === void 0 && value >= value)) {
        max3 = value, maxIndex2 = index2;
      }
    }
  }
  return maxIndex2;
}

// node_modules/d3-array/src/min.js
function min(values2, valueof2) {
  let min4;
  if (valueof2 === void 0) {
    for (const value of values2) {
      if (value != null && (min4 > value || min4 === void 0 && value >= value)) {
        min4 = value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && (min4 > value || min4 === void 0 && value >= value)) {
        min4 = value;
      }
    }
  }
  return min4;
}

// node_modules/d3-array/src/minIndex.js
function minIndex(values2, valueof2) {
  let min4;
  let minIndex2 = -1;
  let index2 = -1;
  if (valueof2 === void 0) {
    for (const value of values2) {
      ++index2;
      if (value != null && (min4 > value || min4 === void 0 && value >= value)) {
        min4 = value, minIndex2 = index2;
      }
    }
  } else {
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && (min4 > value || min4 === void 0 && value >= value)) {
        min4 = value, minIndex2 = index2;
      }
    }
  }
  return minIndex2;
}

// node_modules/d3-array/src/quickselect.js
function quickselect(array2, k4, left2 = 0, right2 = Infinity, compare) {
  k4 = Math.floor(k4);
  left2 = Math.floor(Math.max(0, left2));
  right2 = Math.floor(Math.min(array2.length - 1, right2));
  if (!(left2 <= k4 && k4 <= right2))
    return array2;
  compare = compare === void 0 ? ascendingDefined : compareDefined(compare);
  while (right2 > left2) {
    if (right2 - left2 > 600) {
      const n2 = right2 - left2 + 1;
      const m3 = k4 - left2 + 1;
      const z3 = Math.log(n2);
      const s4 = 0.5 * Math.exp(2 * z3 / 3);
      const sd = 0.5 * Math.sqrt(z3 * s4 * (n2 - s4) / n2) * (m3 - n2 / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left2, Math.floor(k4 - m3 * s4 / n2 + sd));
      const newRight = Math.min(right2, Math.floor(k4 + (n2 - m3) * s4 / n2 + sd));
      quickselect(array2, k4, newLeft, newRight, compare);
    }
    const t4 = array2[k4];
    let i3 = left2;
    let j3 = right2;
    swap(array2, left2, k4);
    if (compare(array2[right2], t4) > 0)
      swap(array2, left2, right2);
    while (i3 < j3) {
      swap(array2, i3, j3), ++i3, --j3;
      while (compare(array2[i3], t4) < 0)
        ++i3;
      while (compare(array2[j3], t4) > 0)
        --j3;
    }
    if (compare(array2[left2], t4) === 0)
      swap(array2, left2, j3);
    else
      ++j3, swap(array2, j3, right2);
    if (j3 <= k4)
      left2 = j3 + 1;
    if (k4 <= j3)
      right2 = j3 - 1;
  }
  return array2;
}
function swap(array2, i3, j3) {
  const t4 = array2[i3];
  array2[i3] = array2[j3];
  array2[j3] = t4;
}

// node_modules/d3-array/src/quantile.js
function quantile(values2, p3, valueof2) {
  values2 = Float64Array.from(numbers(values2, valueof2));
  if (!(n2 = values2.length) || isNaN(p3 = +p3))
    return;
  if (p3 <= 0 || n2 < 2)
    return min(values2);
  if (p3 >= 1)
    return max(values2);
  var n2, i3 = (n2 - 1) * p3, i0 = Math.floor(i3), value0 = max(quickselect(values2, i0).subarray(0, i0 + 1)), value1 = min(values2.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i3 - i0);
}
function quantileSorted(values2, p3, valueof2 = number) {
  if (!(n2 = values2.length) || isNaN(p3 = +p3))
    return;
  if (p3 <= 0 || n2 < 2)
    return +valueof2(values2[0], 0, values2);
  if (p3 >= 1)
    return +valueof2(values2[n2 - 1], n2 - 1, values2);
  var n2, i3 = (n2 - 1) * p3, i0 = Math.floor(i3), value0 = +valueof2(values2[i0], i0, values2), value1 = +valueof2(values2[i0 + 1], i0 + 1, values2);
  return value0 + (value1 - value0) * (i3 - i0);
}

// node_modules/d3-array/src/threshold/freedmanDiaconis.js
function thresholdFreedmanDiaconis(values2, min4, max3) {
  const c6 = count(values2), d3 = quantile(values2, 0.75) - quantile(values2, 0.25);
  return c6 && d3 ? Math.ceil((max3 - min4) / (2 * d3 * Math.pow(c6, -1 / 3))) : 1;
}

// node_modules/d3-array/src/threshold/scott.js
function thresholdScott(values2, min4, max3) {
  const c6 = count(values2), d3 = deviation(values2);
  return c6 && d3 ? Math.ceil((max3 - min4) * Math.cbrt(c6) / (3.49 * d3)) : 1;
}

// node_modules/d3-array/src/mean.js
function mean(values2, valueof2) {
  let count2 = 0;
  let sum2 = 0;
  if (valueof2 === void 0) {
    for (let value of values2) {
      if (value != null && (value = +value) >= value) {
        ++count2, sum2 += value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && (value = +value) >= value) {
        ++count2, sum2 += value;
      }
    }
  }
  if (count2)
    return sum2 / count2;
}

// node_modules/d3-array/src/median.js
function median(values2, valueof2) {
  return quantile(values2, 0.5, valueof2);
}

// node_modules/d3-array/src/merge.js
function* flatten(arrays) {
  for (const array2 of arrays) {
    yield* array2;
  }
}
function merge(arrays) {
  return Array.from(flatten(arrays));
}

// node_modules/d3-array/src/mode.js
function mode(values2, valueof2) {
  const counts = new InternMap();
  if (valueof2 === void 0) {
    for (let value of values2) {
      if (value != null && value >= value) {
        counts.set(value, (counts.get(value) || 0) + 1);
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && value >= value) {
        counts.set(value, (counts.get(value) || 0) + 1);
      }
    }
  }
  let modeValue;
  let modeCount = 0;
  for (const [value, count2] of counts) {
    if (count2 > modeCount) {
      modeCount = count2;
      modeValue = value;
    }
  }
  return modeValue;
}

// node_modules/d3-array/src/pairs.js
function pairs(values2, pairof = pair) {
  const pairs2 = [];
  let previous;
  let first2 = false;
  for (const value of values2) {
    if (first2)
      pairs2.push(pairof(previous, value));
    previous = value;
    first2 = true;
  }
  return pairs2;
}
function pair(a4, b3) {
  return [a4, b3];
}

// node_modules/d3-array/src/range.js
function range(start2, stop, step) {
  start2 = +start2, stop = +stop, step = (n2 = arguments.length) < 2 ? (stop = start2, start2 = 0, 1) : n2 < 3 ? 1 : +step;
  var i3 = -1, n2 = Math.max(0, Math.ceil((stop - start2) / step)) | 0, range3 = new Array(n2);
  while (++i3 < n2) {
    range3[i3] = start2 + i3 * step;
  }
  return range3;
}

// node_modules/d3-array/src/sum.js
function sum(values2, valueof2) {
  let sum2 = 0;
  if (valueof2 === void 0) {
    for (let value of values2) {
      if (value = +value) {
        sum2 += value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if (value = +valueof2(value, ++index2, values2)) {
        sum2 += value;
      }
    }
  }
  return sum2;
}

// node_modules/d3-array/src/reverse.js
function reverse(values2) {
  if (typeof values2[Symbol.iterator] !== "function")
    throw new TypeError("values is not iterable");
  return Array.from(values2).reverse();
}

// node_modules/d3-axis/src/identity.js
function identity_default(x3) {
  return x3;
}

// node_modules/d3-axis/src/axis.js
var top = 1;
var right = 2;
var bottom = 3;
var left = 4;
var epsilon = 1e-6;
function translateX(x3) {
  return "translate(" + x3 + ",0)";
}
function translateY(y3) {
  return "translate(0," + y3 + ")";
}
function number2(scale) {
  return (d3) => +scale(d3);
}
function center(scale, offset2) {
  offset2 = Math.max(0, scale.bandwidth() - offset2 * 2) / 2;
  if (scale.round())
    offset2 = Math.round(offset2);
  return (d3) => +scale(d3) + offset2;
}
function entering() {
  return !this.__axis;
}
function axis(orient, scale) {
  var tickArguments = [], tickValues = null, tickFormat2 = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, offset2 = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5, k4 = orient === top || orient === left ? -1 : 1, x3 = orient === left || orient === right ? "x" : "y", transform2 = orient === top || orient === bottom ? translateX : translateY;
  function axis2(context) {
    var values2 = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain() : tickValues, format3 = tickFormat2 == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity_default : tickFormat2, spacing = Math.max(tickSizeInner, 0) + tickPadding, range3 = scale.range(), range0 = +range3[0] + offset2, range1 = +range3[range3.length - 1] + offset2, position2 = (scale.bandwidth ? center : number2)(scale.copy(), offset2), selection2 = context.selection ? context.selection() : context, path2 = selection2.selectAll(".domain").data([null]), tick = selection2.selectAll(".tick").data(values2, scale).order(), tickExit = tick.exit(), tickEnter = tick.enter().append("g").attr("class", "tick"), line = tick.select("line"), text2 = tick.select("text");
    path2 = path2.merge(path2.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
    tick = tick.merge(tickEnter);
    line = line.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x3 + "2", k4 * tickSizeInner));
    text2 = text2.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x3, k4 * spacing).attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
    if (context !== selection2) {
      path2 = path2.transition(context);
      tick = tick.transition(context);
      line = line.transition(context);
      text2 = text2.transition(context);
      tickExit = tickExit.transition(context).attr("opacity", epsilon).attr("transform", function(d3) {
        return isFinite(d3 = position2(d3)) ? transform2(d3 + offset2) : this.getAttribute("transform");
      });
      tickEnter.attr("opacity", epsilon).attr("transform", function(d3) {
        var p3 = this.parentNode.__axis;
        return transform2((p3 && isFinite(p3 = p3(d3)) ? p3 : position2(d3)) + offset2);
      });
    }
    tickExit.remove();
    path2.attr("d", orient === left || orient === right ? tickSizeOuter ? "M" + k4 * tickSizeOuter + "," + range0 + "H" + offset2 + "V" + range1 + "H" + k4 * tickSizeOuter : "M" + offset2 + "," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k4 * tickSizeOuter + "V" + offset2 + "H" + range1 + "V" + k4 * tickSizeOuter : "M" + range0 + "," + offset2 + "H" + range1);
    tick.attr("opacity", 1).attr("transform", function(d3) {
      return transform2(position2(d3) + offset2);
    });
    line.attr(x3 + "2", k4 * tickSizeInner);
    text2.attr(x3, k4 * spacing).text(format3);
    selection2.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
    selection2.each(function() {
      this.__axis = position2;
    });
  }
  axis2.scale = function(_2) {
    return arguments.length ? (scale = _2, axis2) : scale;
  };
  axis2.ticks = function() {
    return tickArguments = Array.from(arguments), axis2;
  };
  axis2.tickArguments = function(_2) {
    return arguments.length ? (tickArguments = _2 == null ? [] : Array.from(_2), axis2) : tickArguments.slice();
  };
  axis2.tickValues = function(_2) {
    return arguments.length ? (tickValues = _2 == null ? null : Array.from(_2), axis2) : tickValues && tickValues.slice();
  };
  axis2.tickFormat = function(_2) {
    return arguments.length ? (tickFormat2 = _2, axis2) : tickFormat2;
  };
  axis2.tickSize = function(_2) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_2, axis2) : tickSizeInner;
  };
  axis2.tickSizeInner = function(_2) {
    return arguments.length ? (tickSizeInner = +_2, axis2) : tickSizeInner;
  };
  axis2.tickSizeOuter = function(_2) {
    return arguments.length ? (tickSizeOuter = +_2, axis2) : tickSizeOuter;
  };
  axis2.tickPadding = function(_2) {
    return arguments.length ? (tickPadding = +_2, axis2) : tickPadding;
  };
  axis2.offset = function(_2) {
    return arguments.length ? (offset2 = +_2, axis2) : offset2;
  };
  return axis2;
}
function axisBottom(scale) {
  return axis(bottom, scale);
}

// node_modules/d3-dispatch/src/dispatch.js
var noop = { value: () => {
} };
function dispatch() {
  for (var i3 = 0, n2 = arguments.length, _2 = {}, t4; i3 < n2; ++i3) {
    if (!(t4 = arguments[i3] + "") || t4 in _2 || /[\s.]/.test(t4))
      throw new Error("illegal type: " + t4);
    _2[t4] = [];
  }
  return new Dispatch(_2);
}
function Dispatch(_2) {
  this._ = _2;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t4) {
    var name = "", i3 = t4.indexOf(".");
    if (i3 >= 0)
      name = t4.slice(i3 + 1), t4 = t4.slice(0, i3);
    if (t4 && !types.hasOwnProperty(t4))
      throw new Error("unknown type: " + t4);
    return { type: t4, name };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _2 = this._, T2 = parseTypenames(typename + "", _2), t4, i3 = -1, n2 = T2.length;
    if (arguments.length < 2) {
      while (++i3 < n2)
        if ((t4 = (typename = T2[i3]).type) && (t4 = get(_2[t4], typename.name)))
          return t4;
      return;
    }
    if (callback != null && typeof callback !== "function")
      throw new Error("invalid callback: " + callback);
    while (++i3 < n2) {
      if (t4 = (typename = T2[i3]).type)
        _2[t4] = set(_2[t4], typename.name, callback);
      else if (callback == null)
        for (t4 in _2)
          _2[t4] = set(_2[t4], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy3 = {}, _2 = this._;
    for (var t4 in _2)
      copy3[t4] = _2[t4].slice();
    return new Dispatch(copy3);
  },
  call: function(type2, that) {
    if ((n2 = arguments.length - 2) > 0)
      for (var args = new Array(n2), i3 = 0, n2, t4; i3 < n2; ++i3)
        args[i3] = arguments[i3 + 2];
    if (!this._.hasOwnProperty(type2))
      throw new Error("unknown type: " + type2);
    for (t4 = this._[type2], i3 = 0, n2 = t4.length; i3 < n2; ++i3)
      t4[i3].value.apply(that, args);
  },
  apply: function(type2, that, args) {
    if (!this._.hasOwnProperty(type2))
      throw new Error("unknown type: " + type2);
    for (var t4 = this._[type2], i3 = 0, n2 = t4.length; i3 < n2; ++i3)
      t4[i3].value.apply(that, args);
  }
};
function get(type2, name) {
  for (var i3 = 0, n2 = type2.length, c6; i3 < n2; ++i3) {
    if ((c6 = type2[i3]).name === name) {
      return c6.value;
    }
  }
}
function set(type2, name, callback) {
  for (var i3 = 0, n2 = type2.length; i3 < n2; ++i3) {
    if (type2[i3].name === name) {
      type2[i3] = noop, type2 = type2.slice(0, i3).concat(type2.slice(i3 + 1));
      break;
    }
  }
  if (callback != null)
    type2.push({ name, value: callback });
  return type2;
}
var dispatch_default = dispatch;

// node_modules/d3-selection/src/namespaces.js
var xhtml = "http://www.w3.org/1999/xhtml";
var namespaces_default = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

// node_modules/d3-selection/src/namespace.js
function namespace_default(name) {
  var prefix = name += "", i3 = prefix.indexOf(":");
  if (i3 >= 0 && (prefix = name.slice(0, i3)) !== "xmlns")
    name = name.slice(i3 + 1);
  return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name } : name;
}

// node_modules/d3-selection/src/creator.js
function creatorInherit(name) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator_default(name) {
  var fullname = namespace_default(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}

// node_modules/d3-selection/src/selector.js
function none() {
}
function selector_default(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

// node_modules/d3-selection/src/selection/select.js
function select_default(select) {
  if (typeof select !== "function")
    select = selector_default(select);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j3 = 0; j3 < m3; ++j3) {
    for (var group2 = groups2[j3], n2 = group2.length, subgroup = subgroups[j3] = new Array(n2), node, subnode, i3 = 0; i3 < n2; ++i3) {
      if ((node = group2[i3]) && (subnode = select.call(node, node.__data__, i3, group2))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i3] = subnode;
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/array.js
function array(x3) {
  return x3 == null ? [] : Array.isArray(x3) ? x3 : Array.from(x3);
}

// node_modules/d3-selection/src/selectorAll.js
function empty2() {
  return [];
}
function selectorAll_default(selector) {
  return selector == null ? empty2 : function() {
    return this.querySelectorAll(selector);
  };
}

// node_modules/d3-selection/src/selection/selectAll.js
function arrayAll(select) {
  return function() {
    return array(select.apply(this, arguments));
  };
}
function selectAll_default(select) {
  if (typeof select === "function")
    select = arrayAll(select);
  else
    select = selectorAll_default(select);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = [], parents = [], j3 = 0; j3 < m3; ++j3) {
    for (var group2 = groups2[j3], n2 = group2.length, node, i3 = 0; i3 < n2; ++i3) {
      if (node = group2[i3]) {
        subgroups.push(select.call(node, node.__data__, i3, group2));
        parents.push(node);
      }
    }
  }
  return new Selection(subgroups, parents);
}

// node_modules/d3-selection/src/matcher.js
function matcher_default(selector) {
  return function() {
    return this.matches(selector);
  };
}
function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}

// node_modules/d3-selection/src/selection/selectChild.js
var find = Array.prototype.find;
function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selectChild_default(match) {
  return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
}

// node_modules/d3-selection/src/selection/selectChildren.js
var filter = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}
function selectChildren_default(match) {
  return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
}

// node_modules/d3-selection/src/selection/filter.js
function filter_default(match) {
  if (typeof match !== "function")
    match = matcher_default(match);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j3 = 0; j3 < m3; ++j3) {
    for (var group2 = groups2[j3], n2 = group2.length, subgroup = subgroups[j3] = [], node, i3 = 0; i3 < n2; ++i3) {
      if ((node = group2[i3]) && match.call(node, node.__data__, i3, group2)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/selection/sparse.js
function sparse_default(update) {
  return new Array(update.length);
}

// node_modules/d3-selection/src/selection/enter.js
function enter_default() {
  return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector) {
    return this._parent.querySelector(selector);
  },
  querySelectorAll: function(selector) {
    return this._parent.querySelectorAll(selector);
  }
};

// node_modules/d3-selection/src/constant.js
function constant_default(x3) {
  return function() {
    return x3;
  };
}

// node_modules/d3-selection/src/selection/data.js
function bindIndex(parent, group2, enter, update, exit, data) {
  var i3 = 0, node, groupLength = group2.length, dataLength = data.length;
  for (; i3 < dataLength; ++i3) {
    if (node = group2[i3]) {
      node.__data__ = data[i3];
      update[i3] = node;
    } else {
      enter[i3] = new EnterNode(parent, data[i3]);
    }
  }
  for (; i3 < groupLength; ++i3) {
    if (node = group2[i3]) {
      exit[i3] = node;
    }
  }
}
function bindKey(parent, group2, enter, update, exit, data, key) {
  var i3, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group2.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i3 = 0; i3 < groupLength; ++i3) {
    if (node = group2[i3]) {
      keyValues[i3] = keyValue = key.call(node, node.__data__, i3, group2) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i3] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }
  for (i3 = 0; i3 < dataLength; ++i3) {
    keyValue = key.call(parent, data[i3], i3, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i3] = node;
      node.__data__ = data[i3];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i3] = new EnterNode(parent, data[i3]);
    }
  }
  for (i3 = 0; i3 < groupLength; ++i3) {
    if ((node = group2[i3]) && nodeByKeyValue.get(keyValues[i3]) === node) {
      exit[i3] = node;
    }
  }
}
function datum(node) {
  return node.__data__;
}
function data_default(value, key) {
  if (!arguments.length)
    return Array.from(this, datum);
  var bind = key ? bindKey : bindIndex, parents = this._parents, groups2 = this._groups;
  if (typeof value !== "function")
    value = constant_default(value);
  for (var m3 = groups2.length, update = new Array(m3), enter = new Array(m3), exit = new Array(m3), j3 = 0; j3 < m3; ++j3) {
    var parent = parents[j3], group2 = groups2[j3], groupLength = group2.length, data = arraylike(value.call(parent, parent && parent.__data__, j3, parents)), dataLength = data.length, enterGroup = enter[j3] = new Array(dataLength), updateGroup = update[j3] = new Array(dataLength), exitGroup = exit[j3] = new Array(groupLength);
    bind(parent, group2, enterGroup, updateGroup, exitGroup, data, key);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1)
          i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength)
          ;
        previous._next = next || null;
      }
    }
  }
  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}
function arraylike(data) {
  return typeof data === "object" && "length" in data ? data : Array.from(data);
}

// node_modules/d3-selection/src/selection/exit.js
function exit_default() {
  return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
}

// node_modules/d3-selection/src/selection/join.js
function join_default(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter)
      enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update)
      update = update.selection();
  }
  if (onexit == null)
    exit.remove();
  else
    onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}

// node_modules/d3-selection/src/selection/merge.js
function merge_default(context) {
  var selection2 = context.selection ? context.selection() : context;
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m3 = Math.min(m0, m1), merges = new Array(m0), j3 = 0; j3 < m3; ++j3) {
    for (var group0 = groups0[j3], group1 = groups1[j3], n2 = group0.length, merge2 = merges[j3] = new Array(n2), node, i3 = 0; i3 < n2; ++i3) {
      if (node = group0[i3] || group1[i3]) {
        merge2[i3] = node;
      }
    }
  }
  for (; j3 < m0; ++j3) {
    merges[j3] = groups0[j3];
  }
  return new Selection(merges, this._parents);
}

// node_modules/d3-selection/src/selection/order.js
function order_default() {
  for (var groups2 = this._groups, j3 = -1, m3 = groups2.length; ++j3 < m3; ) {
    for (var group2 = groups2[j3], i3 = group2.length - 1, next = group2[i3], node; --i3 >= 0; ) {
      if (node = group2[i3]) {
        if (next && node.compareDocumentPosition(next) ^ 4)
          next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/sort.js
function sort_default(compare) {
  if (!compare)
    compare = ascending2;
  function compareNode(a4, b3) {
    return a4 && b3 ? compare(a4.__data__, b3.__data__) : !a4 - !b3;
  }
  for (var groups2 = this._groups, m3 = groups2.length, sortgroups = new Array(m3), j3 = 0; j3 < m3; ++j3) {
    for (var group2 = groups2[j3], n2 = group2.length, sortgroup = sortgroups[j3] = new Array(n2), node, i3 = 0; i3 < n2; ++i3) {
      if (node = group2[i3]) {
        sortgroup[i3] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection(sortgroups, this._parents).order();
}
function ascending2(a4, b3) {
  return a4 < b3 ? -1 : a4 > b3 ? 1 : a4 >= b3 ? 0 : NaN;
}

// node_modules/d3-selection/src/selection/call.js
function call_default() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

// node_modules/d3-selection/src/selection/nodes.js
function nodes_default() {
  return Array.from(this);
}

// node_modules/d3-selection/src/selection/node.js
function node_default() {
  for (var groups2 = this._groups, j3 = 0, m3 = groups2.length; j3 < m3; ++j3) {
    for (var group2 = groups2[j3], i3 = 0, n2 = group2.length; i3 < n2; ++i3) {
      var node = group2[i3];
      if (node)
        return node;
    }
  }
  return null;
}

// node_modules/d3-selection/src/selection/size.js
function size_default() {
  let size = 0;
  for (const node of this)
    ++size;
  return size;
}

// node_modules/d3-selection/src/selection/empty.js
function empty_default() {
  return !this.node();
}

// node_modules/d3-selection/src/selection/each.js
function each_default(callback) {
  for (var groups2 = this._groups, j3 = 0, m3 = groups2.length; j3 < m3; ++j3) {
    for (var group2 = groups2[j3], i3 = 0, n2 = group2.length, node; i3 < n2; ++i3) {
      if (node = group2[i3])
        callback.call(node, node.__data__, i3, group2);
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/attr.js
function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}
function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction(name, value) {
  return function() {
    var v3 = value.apply(this, arguments);
    if (v3 == null)
      this.removeAttribute(name);
    else
      this.setAttribute(name, v3);
  };
}
function attrFunctionNS(fullname, value) {
  return function() {
    var v3 = value.apply(this, arguments);
    if (v3 == null)
      this.removeAttributeNS(fullname.space, fullname.local);
    else
      this.setAttributeNS(fullname.space, fullname.local, v3);
  };
}
function attr_default(name, value) {
  var fullname = namespace_default(name);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
}

// node_modules/d3-selection/src/window.js
function window_default(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}

// node_modules/d3-selection/src/selection/style.js
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}
function styleFunction(name, value, priority) {
  return function() {
    var v3 = value.apply(this, arguments);
    if (v3 == null)
      this.style.removeProperty(name);
    else
      this.style.setProperty(name, v3, priority);
  };
}
function style_default(name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
}
function styleValue(node, name) {
  return node.style.getPropertyValue(name) || window_default(node).getComputedStyle(node, null).getPropertyValue(name);
}

// node_modules/d3-selection/src/selection/property.js
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}
function propertyFunction(name, value) {
  return function() {
    var v3 = value.apply(this, arguments);
    if (v3 == null)
      delete this[name];
    else
      this[name] = v3;
  };
}
function property_default(name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
}

// node_modules/d3-selection/src/selection/classed.js
function classArray(string2) {
  return string2.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name) {
    var i3 = this._names.indexOf(name);
    if (i3 < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i3 = this._names.indexOf(name);
    if (i3 >= 0) {
      this._names.splice(i3, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd(node, names) {
  var list = classList(node), i3 = -1, n2 = names.length;
  while (++i3 < n2)
    list.add(names[i3]);
}
function classedRemove(node, names) {
  var list = classList(node), i3 = -1, n2 = names.length;
  while (++i3 < n2)
    list.remove(names[i3]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function classed_default(name, value) {
  var names = classArray(name + "");
  if (arguments.length < 2) {
    var list = classList(this.node()), i3 = -1, n2 = names.length;
    while (++i3 < n2)
      if (!list.contains(names[i3]))
        return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}

// node_modules/d3-selection/src/selection/text.js
function textRemove() {
  this.textContent = "";
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var v3 = value.apply(this, arguments);
    this.textContent = v3 == null ? "" : v3;
  };
}
function text_default(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
}

// node_modules/d3-selection/src/selection/html.js
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v3 = value.apply(this, arguments);
    this.innerHTML = v3 == null ? "" : v3;
  };
}
function html_default(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}

// node_modules/d3-selection/src/selection/raise.js
function raise() {
  if (this.nextSibling)
    this.parentNode.appendChild(this);
}
function raise_default() {
  return this.each(raise);
}

// node_modules/d3-selection/src/selection/lower.js
function lower() {
  if (this.previousSibling)
    this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function lower_default() {
  return this.each(lower);
}

// node_modules/d3-selection/src/selection/append.js
function append_default(name) {
  var create3 = typeof name === "function" ? name : creator_default(name);
  return this.select(function() {
    return this.appendChild(create3.apply(this, arguments));
  });
}

// node_modules/d3-selection/src/selection/insert.js
function constantNull() {
  return null;
}
function insert_default(name, before) {
  var create3 = typeof name === "function" ? name : creator_default(name), select = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
  return this.select(function() {
    return this.insertBefore(create3.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

// node_modules/d3-selection/src/selection/remove.js
function remove() {
  var parent = this.parentNode;
  if (parent)
    parent.removeChild(this);
}
function remove_default() {
  return this.each(remove);
}

// node_modules/d3-selection/src/selection/clone.js
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function clone_default(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

// node_modules/d3-selection/src/selection/datum.js
function datum_default(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}

// node_modules/d3-selection/src/selection/on.js
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames2(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t4) {
    var name = "", i3 = t4.indexOf(".");
    if (i3 >= 0)
      name = t4.slice(i3 + 1), t4 = t4.slice(0, i3);
    return { type: t4, name };
  });
}
function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on)
      return;
    for (var j3 = 0, i3 = -1, m3 = on.length, o3; j3 < m3; ++j3) {
      if (o3 = on[j3], (!typename.type || o3.type === typename.type) && o3.name === typename.name) {
        this.removeEventListener(o3.type, o3.listener, o3.options);
      } else {
        on[++i3] = o3;
      }
    }
    if (++i3)
      on.length = i3;
    else
      delete this.__on;
  };
}
function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o3, listener = contextListener(value);
    if (on)
      for (var j3 = 0, m3 = on.length; j3 < m3; ++j3) {
        if ((o3 = on[j3]).type === typename.type && o3.name === typename.name) {
          this.removeEventListener(o3.type, o3.listener, o3.options);
          this.addEventListener(o3.type, o3.listener = listener, o3.options = options);
          o3.value = value;
          return;
        }
      }
    this.addEventListener(typename.type, listener, options);
    o3 = { type: typename.type, name: typename.name, value, listener, options };
    if (!on)
      this.__on = [o3];
    else
      on.push(o3);
  };
}
function on_default(typename, value, options) {
  var typenames = parseTypenames2(typename + ""), i3, n2 = typenames.length, t4;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on)
      for (var j3 = 0, m3 = on.length, o3; j3 < m3; ++j3) {
        for (i3 = 0, o3 = on[j3]; i3 < n2; ++i3) {
          if ((t4 = typenames[i3]).type === o3.type && t4.name === o3.name) {
            return o3.value;
          }
        }
      }
    return;
  }
  on = value ? onAdd : onRemove;
  for (i3 = 0; i3 < n2; ++i3)
    this.each(on(typenames[i3], value, options));
  return this;
}

// node_modules/d3-selection/src/selection/dispatch.js
function dispatchEvent(node, type2, params) {
  var window2 = window_default(node), event = window2.CustomEvent;
  if (typeof event === "function") {
    event = new event(type2, params);
  } else {
    event = window2.document.createEvent("Event");
    if (params)
      event.initEvent(type2, params.bubbles, params.cancelable), event.detail = params.detail;
    else
      event.initEvent(type2, false, false);
  }
  node.dispatchEvent(event);
}
function dispatchConstant(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params);
  };
}
function dispatchFunction(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params.apply(this, arguments));
  };
}
function dispatch_default2(type2, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type2, params));
}

// node_modules/d3-selection/src/selection/iterator.js
function* iterator_default() {
  for (var groups2 = this._groups, j3 = 0, m3 = groups2.length; j3 < m3; ++j3) {
    for (var group2 = groups2[j3], i3 = 0, n2 = group2.length, node; i3 < n2; ++i3) {
      if (node = group2[i3])
        yield node;
    }
  }
}

// node_modules/d3-selection/src/selection/index.js
var root = [null];
function Selection(groups2, parents) {
  this._groups = groups2;
  this._parents = parents;
}
function selection() {
  return new Selection([[document.documentElement]], root);
}
function selection_selection() {
  return this;
}
Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: select_default,
  selectAll: selectAll_default,
  selectChild: selectChild_default,
  selectChildren: selectChildren_default,
  filter: filter_default,
  data: data_default,
  enter: enter_default,
  exit: exit_default,
  join: join_default,
  merge: merge_default,
  selection: selection_selection,
  order: order_default,
  sort: sort_default,
  call: call_default,
  nodes: nodes_default,
  node: node_default,
  size: size_default,
  empty: empty_default,
  each: each_default,
  attr: attr_default,
  style: style_default,
  property: property_default,
  classed: classed_default,
  text: text_default,
  html: html_default,
  raise: raise_default,
  lower: lower_default,
  append: append_default,
  insert: insert_default,
  remove: remove_default,
  clone: clone_default,
  datum: datum_default,
  on: on_default,
  dispatch: dispatch_default2,
  [Symbol.iterator]: iterator_default
};
var selection_default = selection;

// node_modules/d3-selection/src/select.js
function select_default2(selector) {
  return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);
}

// node_modules/d3-selection/src/sourceEvent.js
function sourceEvent_default(event) {
  let sourceEvent;
  while (sourceEvent = event.sourceEvent)
    event = sourceEvent;
  return event;
}

// node_modules/d3-selection/src/pointer.js
function pointer_default(event, node) {
  event = sourceEvent_default(event);
  if (node === void 0)
    node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point2 = svg.createSVGPoint();
      point2.x = event.clientX, point2.y = event.clientY;
      point2 = point2.matrixTransform(node.getScreenCTM().inverse());
      return [point2.x, point2.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}

// node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format3) {
  var m3, l3;
  format3 = (format3 + "").trim().toLowerCase();
  return (m3 = reHex.exec(format3)) ? (l3 = m3[1].length, m3 = parseInt(m3[1], 16), l3 === 6 ? rgbn(m3) : l3 === 3 ? new Rgb(m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, (m3 & 15) << 4 | m3 & 15, 1) : l3 === 8 ? rgba(m3 >> 24 & 255, m3 >> 16 & 255, m3 >> 8 & 255, (m3 & 255) / 255) : l3 === 4 ? rgba(m3 >> 12 & 15 | m3 >> 8 & 240, m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, ((m3 & 15) << 4 | m3 & 15) / 255) : null) : (m3 = reRgbInteger.exec(format3)) ? new Rgb(m3[1], m3[2], m3[3], 1) : (m3 = reRgbPercent.exec(format3)) ? new Rgb(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, 1) : (m3 = reRgbaInteger.exec(format3)) ? rgba(m3[1], m3[2], m3[3], m3[4]) : (m3 = reRgbaPercent.exec(format3)) ? rgba(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, m3[4]) : (m3 = reHslPercent.exec(format3)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, 1) : (m3 = reHslaPercent.exec(format3)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, m3[4]) : named.hasOwnProperty(format3) ? rgbn(named[format3]) : format3 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n2) {
  return new Rgb(n2 >> 16 & 255, n2 >> 8 & 255, n2 & 255, 1);
}
function rgba(r3, g3, b3, a4) {
  if (a4 <= 0)
    r3 = g3 = b3 = NaN;
  return new Rgb(r3, g3, b3, a4);
}
function rgbConvert(o3) {
  if (!(o3 instanceof Color))
    o3 = color(o3);
  if (!o3)
    return new Rgb();
  o3 = o3.rgb();
  return new Rgb(o3.r, o3.g, o3.b, o3.opacity);
}
function rgb(r3, g3, b3, opacity2) {
  return arguments.length === 1 ? rgbConvert(r3) : new Rgb(r3, g3, b3, opacity2 == null ? 1 : opacity2);
}
function Rgb(r3, g3, b3, opacity2) {
  this.r = +r3;
  this.g = +g3;
  this.b = +b3;
  this.opacity = +opacity2;
}
define_default(Rgb, rgb, extend(Color, {
  brighter(k4) {
    k4 = k4 == null ? brighter : Math.pow(brighter, k4);
    return new Rgb(this.r * k4, this.g * k4, this.b * k4, this.opacity);
  },
  darker(k4) {
    k4 = k4 == null ? darker : Math.pow(darker, k4);
    return new Rgb(this.r * k4, this.g * k4, this.b * k4, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a4 = clampa(this.opacity);
  return `${a4 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a4 === 1 ? ")" : `, ${a4})`}`;
}
function clampa(opacity2) {
  return isNaN(opacity2) ? 1 : Math.max(0, Math.min(1, opacity2));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h3, s4, l3, a4) {
  if (a4 <= 0)
    h3 = s4 = l3 = NaN;
  else if (l3 <= 0 || l3 >= 1)
    h3 = s4 = NaN;
  else if (s4 <= 0)
    h3 = NaN;
  return new Hsl(h3, s4, l3, a4);
}
function hslConvert(o3) {
  if (o3 instanceof Hsl)
    return new Hsl(o3.h, o3.s, o3.l, o3.opacity);
  if (!(o3 instanceof Color))
    o3 = color(o3);
  if (!o3)
    return new Hsl();
  if (o3 instanceof Hsl)
    return o3;
  o3 = o3.rgb();
  var r3 = o3.r / 255, g3 = o3.g / 255, b3 = o3.b / 255, min4 = Math.min(r3, g3, b3), max3 = Math.max(r3, g3, b3), h3 = NaN, s4 = max3 - min4, l3 = (max3 + min4) / 2;
  if (s4) {
    if (r3 === max3)
      h3 = (g3 - b3) / s4 + (g3 < b3) * 6;
    else if (g3 === max3)
      h3 = (b3 - r3) / s4 + 2;
    else
      h3 = (r3 - g3) / s4 + 4;
    s4 /= l3 < 0.5 ? max3 + min4 : 2 - max3 - min4;
    h3 *= 60;
  } else {
    s4 = l3 > 0 && l3 < 1 ? 0 : h3;
  }
  return new Hsl(h3, s4, l3, o3.opacity);
}
function hsl(h3, s4, l3, opacity2) {
  return arguments.length === 1 ? hslConvert(h3) : new Hsl(h3, s4, l3, opacity2 == null ? 1 : opacity2);
}
function Hsl(h3, s4, l3, opacity2) {
  this.h = +h3;
  this.s = +s4;
  this.l = +l3;
  this.opacity = +opacity2;
}
define_default(Hsl, hsl, extend(Color, {
  brighter(k4) {
    k4 = k4 == null ? brighter : Math.pow(brighter, k4);
    return new Hsl(this.h, this.s, this.l * k4, this.opacity);
  },
  darker(k4) {
    k4 = k4 == null ? darker : Math.pow(darker, k4);
    return new Hsl(this.h, this.s, this.l * k4, this.opacity);
  },
  rgb() {
    var h3 = this.h % 360 + (this.h < 0) * 360, s4 = isNaN(h3) || isNaN(this.s) ? 0 : this.s, l3 = this.l, m22 = l3 + (l3 < 0.5 ? l3 : 1 - l3) * s4, m1 = 2 * l3 - m22;
    return new Rgb(
      hsl2rgb(h3 >= 240 ? h3 - 240 : h3 + 120, m1, m22),
      hsl2rgb(h3, m1, m22),
      hsl2rgb(h3 < 120 ? h3 + 240 : h3 - 120, m1, m22),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a4 = clampa(this.opacity);
    return `${a4 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a4 === 1 ? ")" : `, ${a4})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h3, m1, m22) {
  return (h3 < 60 ? m1 + (m22 - m1) * h3 / 60 : h3 < 180 ? m22 : h3 < 240 ? m1 + (m22 - m1) * (240 - h3) / 60 : m1) * 255;
}

// node_modules/d3-color/src/math.js
var radians = Math.PI / 180;
var degrees = 180 / Math.PI;

// node_modules/d3-color/src/lab.js
var K = 18;
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t22 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;
function labConvert(o3) {
  if (o3 instanceof Lab)
    return new Lab(o3.l, o3.a, o3.b, o3.opacity);
  if (o3 instanceof Hcl)
    return hcl2lab(o3);
  if (!(o3 instanceof Rgb))
    o3 = rgbConvert(o3);
  var r3 = rgb2lrgb(o3.r), g3 = rgb2lrgb(o3.g), b3 = rgb2lrgb(o3.b), y3 = xyz2lab((0.2225045 * r3 + 0.7168786 * g3 + 0.0606169 * b3) / Yn), x3, z3;
  if (r3 === g3 && g3 === b3)
    x3 = z3 = y3;
  else {
    x3 = xyz2lab((0.4360747 * r3 + 0.3850649 * g3 + 0.1430804 * b3) / Xn);
    z3 = xyz2lab((0.0139322 * r3 + 0.0971045 * g3 + 0.7141733 * b3) / Zn);
  }
  return new Lab(116 * y3 - 16, 500 * (x3 - y3), 200 * (y3 - z3), o3.opacity);
}
function lab(l3, a4, b3, opacity2) {
  return arguments.length === 1 ? labConvert(l3) : new Lab(l3, a4, b3, opacity2 == null ? 1 : opacity2);
}
function Lab(l3, a4, b3, opacity2) {
  this.l = +l3;
  this.a = +a4;
  this.b = +b3;
  this.opacity = +opacity2;
}
define_default(Lab, lab, extend(Color, {
  brighter(k4) {
    return new Lab(this.l + K * (k4 == null ? 1 : k4), this.a, this.b, this.opacity);
  },
  darker(k4) {
    return new Lab(this.l - K * (k4 == null ? 1 : k4), this.a, this.b, this.opacity);
  },
  rgb() {
    var y3 = (this.l + 16) / 116, x3 = isNaN(this.a) ? y3 : y3 + this.a / 500, z3 = isNaN(this.b) ? y3 : y3 - this.b / 200;
    x3 = Xn * lab2xyz(x3);
    y3 = Yn * lab2xyz(y3);
    z3 = Zn * lab2xyz(z3);
    return new Rgb(
      lrgb2rgb(3.1338561 * x3 - 1.6168667 * y3 - 0.4906146 * z3),
      lrgb2rgb(-0.9787684 * x3 + 1.9161415 * y3 + 0.033454 * z3),
      lrgb2rgb(0.0719453 * x3 - 0.2289914 * y3 + 1.4052427 * z3),
      this.opacity
    );
  }
}));
function xyz2lab(t4) {
  return t4 > t3 ? Math.pow(t4, 1 / 3) : t4 / t22 + t0;
}
function lab2xyz(t4) {
  return t4 > t1 ? t4 * t4 * t4 : t22 * (t4 - t0);
}
function lrgb2rgb(x3) {
  return 255 * (x3 <= 31308e-7 ? 12.92 * x3 : 1.055 * Math.pow(x3, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x3) {
  return (x3 /= 255) <= 0.04045 ? x3 / 12.92 : Math.pow((x3 + 0.055) / 1.055, 2.4);
}
function hclConvert(o3) {
  if (o3 instanceof Hcl)
    return new Hcl(o3.h, o3.c, o3.l, o3.opacity);
  if (!(o3 instanceof Lab))
    o3 = labConvert(o3);
  if (o3.a === 0 && o3.b === 0)
    return new Hcl(NaN, 0 < o3.l && o3.l < 100 ? 0 : NaN, o3.l, o3.opacity);
  var h3 = Math.atan2(o3.b, o3.a) * degrees;
  return new Hcl(h3 < 0 ? h3 + 360 : h3, Math.sqrt(o3.a * o3.a + o3.b * o3.b), o3.l, o3.opacity);
}
function hcl(h3, c6, l3, opacity2) {
  return arguments.length === 1 ? hclConvert(h3) : new Hcl(h3, c6, l3, opacity2 == null ? 1 : opacity2);
}
function Hcl(h3, c6, l3, opacity2) {
  this.h = +h3;
  this.c = +c6;
  this.l = +l3;
  this.opacity = +opacity2;
}
function hcl2lab(o3) {
  if (isNaN(o3.h))
    return new Lab(o3.l, 0, 0, o3.opacity);
  var h3 = o3.h * radians;
  return new Lab(o3.l, Math.cos(h3) * o3.c, Math.sin(h3) * o3.c, o3.opacity);
}
define_default(Hcl, hcl, extend(Color, {
  brighter(k4) {
    return new Hcl(this.h, this.c, this.l + K * (k4 == null ? 1 : k4), this.opacity);
  },
  darker(k4) {
    return new Hcl(this.h, this.c, this.l - K * (k4 == null ? 1 : k4), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));

// node_modules/d3-color/src/cubehelix.js
var A2 = -0.14861;
var B3 = 1.78277;
var C = -0.29227;
var D2 = -0.90649;
var E = 1.97294;
var ED = E * D2;
var EB = E * B3;
var BC_DA = B3 * C - D2 * A2;
function cubehelixConvert(o3) {
  if (o3 instanceof Cubehelix)
    return new Cubehelix(o3.h, o3.s, o3.l, o3.opacity);
  if (!(o3 instanceof Rgb))
    o3 = rgbConvert(o3);
  var r3 = o3.r / 255, g3 = o3.g / 255, b3 = o3.b / 255, l3 = (BC_DA * b3 + ED * r3 - EB * g3) / (BC_DA + ED - EB), bl = b3 - l3, k4 = (E * (g3 - l3) - C * bl) / D2, s4 = Math.sqrt(k4 * k4 + bl * bl) / (E * l3 * (1 - l3)), h3 = s4 ? Math.atan2(k4, bl) * degrees - 120 : NaN;
  return new Cubehelix(h3 < 0 ? h3 + 360 : h3, s4, l3, o3.opacity);
}
function cubehelix(h3, s4, l3, opacity2) {
  return arguments.length === 1 ? cubehelixConvert(h3) : new Cubehelix(h3, s4, l3, opacity2 == null ? 1 : opacity2);
}
function Cubehelix(h3, s4, l3, opacity2) {
  this.h = +h3;
  this.s = +s4;
  this.l = +l3;
  this.opacity = +opacity2;
}
define_default(Cubehelix, cubehelix, extend(Color, {
  brighter(k4) {
    k4 = k4 == null ? brighter : Math.pow(brighter, k4);
    return new Cubehelix(this.h, this.s, this.l * k4, this.opacity);
  },
  darker(k4) {
    k4 = k4 == null ? darker : Math.pow(darker, k4);
    return new Cubehelix(this.h, this.s, this.l * k4, this.opacity);
  },
  rgb() {
    var h3 = isNaN(this.h) ? 0 : (this.h + 120) * radians, l3 = +this.l, a4 = isNaN(this.s) ? 0 : this.s * l3 * (1 - l3), cosh = Math.cos(h3), sinh = Math.sin(h3);
    return new Rgb(
      255 * (l3 + a4 * (A2 * cosh + B3 * sinh)),
      255 * (l3 + a4 * (C * cosh + D2 * sinh)),
      255 * (l3 + a4 * (E * cosh)),
      this.opacity
    );
  }
}));

// node_modules/d3-interpolate/src/basis.js
function basis(t13, v0, v1, v22, v3) {
  var t23 = t13 * t13, t32 = t23 * t13;
  return ((1 - 3 * t13 + 3 * t23 - t32) * v0 + (4 - 6 * t23 + 3 * t32) * v1 + (1 + 3 * t13 + 3 * t23 - 3 * t32) * v22 + t32 * v3) / 6;
}
function basis_default(values2) {
  var n2 = values2.length - 1;
  return function(t4) {
    var i3 = t4 <= 0 ? t4 = 0 : t4 >= 1 ? (t4 = 1, n2 - 1) : Math.floor(t4 * n2), v1 = values2[i3], v22 = values2[i3 + 1], v0 = i3 > 0 ? values2[i3 - 1] : 2 * v1 - v22, v3 = i3 < n2 - 1 ? values2[i3 + 2] : 2 * v22 - v1;
    return basis((t4 - i3 / n2) * n2, v0, v1, v22, v3);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values2) {
  var n2 = values2.length;
  return function(t4) {
    var i3 = Math.floor(((t4 %= 1) < 0 ? ++t4 : t4) * n2), v0 = values2[(i3 + n2 - 1) % n2], v1 = values2[i3 % n2], v22 = values2[(i3 + 1) % n2], v3 = values2[(i3 + 2) % n2];
    return basis((t4 - i3 / n2) * n2, v0, v1, v22, v3);
  };
}

// node_modules/d3-interpolate/src/constant.js
var constant_default2 = (x3) => () => x3;

// node_modules/d3-interpolate/src/color.js
function linear(a4, d3) {
  return function(t4) {
    return a4 + t4 * d3;
  };
}
function exponential(a4, b3, y3) {
  return a4 = Math.pow(a4, y3), b3 = Math.pow(b3, y3) - a4, y3 = 1 / y3, function(t4) {
    return Math.pow(a4 + t4 * b3, y3);
  };
}
function hue(a4, b3) {
  var d3 = b3 - a4;
  return d3 ? linear(a4, d3 > 180 || d3 < -180 ? d3 - 360 * Math.round(d3 / 360) : d3) : constant_default2(isNaN(a4) ? b3 : a4);
}
function gamma(y3) {
  return (y3 = +y3) === 1 ? nogamma : function(a4, b3) {
    return b3 - a4 ? exponential(a4, b3, y3) : constant_default2(isNaN(a4) ? b3 : a4);
  };
}
function nogamma(a4, b3) {
  var d3 = b3 - a4;
  return d3 ? linear(a4, d3) : constant_default2(isNaN(a4) ? b3 : a4);
}

// node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y3) {
  var color3 = gamma(y3);
  function rgb2(start2, end) {
    var r3 = color3((start2 = rgb(start2)).r, (end = rgb(end)).r), g3 = color3(start2.g, end.g), b3 = color3(start2.b, end.b), opacity2 = nogamma(start2.opacity, end.opacity);
    return function(t4) {
      start2.r = r3(t4);
      start2.g = g3(t4);
      start2.b = b3(t4);
      start2.opacity = opacity2(t4);
      return start2 + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function rgbSpline(spline) {
  return function(colors) {
    var n2 = colors.length, r3 = new Array(n2), g3 = new Array(n2), b3 = new Array(n2), i3, color3;
    for (i3 = 0; i3 < n2; ++i3) {
      color3 = rgb(colors[i3]);
      r3[i3] = color3.r || 0;
      g3[i3] = color3.g || 0;
      b3[i3] = color3.b || 0;
    }
    r3 = spline(r3);
    g3 = spline(g3);
    b3 = spline(b3);
    color3.opacity = 1;
    return function(t4) {
      color3.r = r3(t4);
      color3.g = g3(t4);
      color3.b = b3(t4);
      return color3 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default);
var rgbBasisClosed = rgbSpline(basisClosed_default);

// node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a4, b3) {
  if (!b3)
    b3 = [];
  var n2 = a4 ? Math.min(b3.length, a4.length) : 0, c6 = b3.slice(), i3;
  return function(t4) {
    for (i3 = 0; i3 < n2; ++i3)
      c6[i3] = a4[i3] * (1 - t4) + b3[i3] * t4;
    return c6;
  };
}
function isNumberArray(x3) {
  return ArrayBuffer.isView(x3) && !(x3 instanceof DataView);
}

// node_modules/d3-interpolate/src/array.js
function genericArray(a4, b3) {
  var nb = b3 ? b3.length : 0, na = a4 ? Math.min(nb, a4.length) : 0, x3 = new Array(na), c6 = new Array(nb), i3;
  for (i3 = 0; i3 < na; ++i3)
    x3[i3] = value_default(a4[i3], b3[i3]);
  for (; i3 < nb; ++i3)
    c6[i3] = b3[i3];
  return function(t4) {
    for (i3 = 0; i3 < na; ++i3)
      c6[i3] = x3[i3](t4);
    return c6;
  };
}

// node_modules/d3-interpolate/src/date.js
function date_default(a4, b3) {
  var d3 = /* @__PURE__ */ new Date();
  return a4 = +a4, b3 = +b3, function(t4) {
    return d3.setTime(a4 * (1 - t4) + b3 * t4), d3;
  };
}

// node_modules/d3-interpolate/src/number.js
function number_default(a4, b3) {
  return a4 = +a4, b3 = +b3, function(t4) {
    return a4 * (1 - t4) + b3 * t4;
  };
}

// node_modules/d3-interpolate/src/object.js
function object_default(a4, b3) {
  var i3 = {}, c6 = {}, k4;
  if (a4 === null || typeof a4 !== "object")
    a4 = {};
  if (b3 === null || typeof b3 !== "object")
    b3 = {};
  for (k4 in b3) {
    if (k4 in a4) {
      i3[k4] = value_default(a4[k4], b3[k4]);
    } else {
      c6[k4] = b3[k4];
    }
  }
  return function(t4) {
    for (k4 in i3)
      c6[k4] = i3[k4](t4);
    return c6;
  };
}

// node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero2(b3) {
  return function() {
    return b3;
  };
}
function one(b3) {
  return function(t4) {
    return b3(t4) + "";
  };
}
function string_default(a4, b3) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i3 = -1, s4 = [], q2 = [];
  a4 = a4 + "", b3 = b3 + "";
  while ((am = reA.exec(a4)) && (bm = reB.exec(b3))) {
    if ((bs = bm.index) > bi) {
      bs = b3.slice(bi, bs);
      if (s4[i3])
        s4[i3] += bs;
      else
        s4[++i3] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s4[i3])
        s4[i3] += bm;
      else
        s4[++i3] = bm;
    } else {
      s4[++i3] = null;
      q2.push({ i: i3, x: number_default(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b3.length) {
    bs = b3.slice(bi);
    if (s4[i3])
      s4[i3] += bs;
    else
      s4[++i3] = bs;
  }
  return s4.length < 2 ? q2[0] ? one(q2[0].x) : zero2(b3) : (b3 = q2.length, function(t4) {
    for (var i4 = 0, o3; i4 < b3; ++i4)
      s4[(o3 = q2[i4]).i] = o3.x(t4);
    return s4.join("");
  });
}

// node_modules/d3-interpolate/src/value.js
function value_default(a4, b3) {
  var t4 = typeof b3, c6;
  return b3 == null || t4 === "boolean" ? constant_default2(b3) : (t4 === "number" ? number_default : t4 === "string" ? (c6 = color(b3)) ? (b3 = c6, rgb_default) : string_default : b3 instanceof color ? rgb_default : b3 instanceof Date ? date_default : isNumberArray(b3) ? numberArray_default : Array.isArray(b3) ? genericArray : typeof b3.valueOf !== "function" && typeof b3.toString !== "function" || isNaN(b3) ? object_default : number_default)(a4, b3);
}

// node_modules/d3-interpolate/src/round.js
function round_default(a4, b3) {
  return a4 = +a4, b3 = +b3, function(t4) {
    return Math.round(a4 * (1 - t4) + b3 * t4);
  };
}

// node_modules/d3-interpolate/src/transform/decompose.js
var degrees2 = 180 / Math.PI;
var identity2 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a4, b3, c6, d3, e3, f3) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a4 * a4 + b3 * b3))
    a4 /= scaleX, b3 /= scaleX;
  if (skewX = a4 * c6 + b3 * d3)
    c6 -= a4 * skewX, d3 -= b3 * skewX;
  if (scaleY = Math.sqrt(c6 * c6 + d3 * d3))
    c6 /= scaleY, d3 /= scaleY, skewX /= scaleY;
  if (a4 * d3 < b3 * c6)
    a4 = -a4, b3 = -b3, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e3,
    translateY: f3,
    rotate: Math.atan2(b3, a4) * degrees2,
    skewX: Math.atan(skewX) * degrees2,
    scaleX,
    scaleY
  };
}

// node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value) {
  const m3 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m3.isIdentity ? identity2 : decompose_default(m3.a, m3.b, m3.c, m3.d, m3.e, m3.f);
}
function parseSvg(value) {
  if (value == null)
    return identity2;
  if (!svgNode)
    svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate()))
    return identity2;
  value = value.matrix;
  return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
}

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse2, pxComma, pxParen, degParen) {
  function pop(s4) {
    return s4.length ? s4.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s4, q2) {
    if (xa !== xb || ya !== yb) {
      var i3 = s4.push("translate(", null, pxComma, null, pxParen);
      q2.push({ i: i3 - 4, x: number_default(xa, xb) }, { i: i3 - 2, x: number_default(ya, yb) });
    } else if (xb || yb) {
      s4.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a4, b3, s4, q2) {
    if (a4 !== b3) {
      if (a4 - b3 > 180)
        b3 += 360;
      else if (b3 - a4 > 180)
        a4 += 360;
      q2.push({ i: s4.push(pop(s4) + "rotate(", null, degParen) - 2, x: number_default(a4, b3) });
    } else if (b3) {
      s4.push(pop(s4) + "rotate(" + b3 + degParen);
    }
  }
  function skewX(a4, b3, s4, q2) {
    if (a4 !== b3) {
      q2.push({ i: s4.push(pop(s4) + "skewX(", null, degParen) - 2, x: number_default(a4, b3) });
    } else if (b3) {
      s4.push(pop(s4) + "skewX(" + b3 + degParen);
    }
  }
  function scale(xa, ya, xb, yb, s4, q2) {
    if (xa !== xb || ya !== yb) {
      var i3 = s4.push(pop(s4) + "scale(", null, ",", null, ")");
      q2.push({ i: i3 - 4, x: number_default(xa, xb) }, { i: i3 - 2, x: number_default(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s4.push(pop(s4) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a4, b3) {
    var s4 = [], q2 = [];
    a4 = parse2(a4), b3 = parse2(b3);
    translate(a4.translateX, a4.translateY, b3.translateX, b3.translateY, s4, q2);
    rotate(a4.rotate, b3.rotate, s4, q2);
    skewX(a4.skewX, b3.skewX, s4, q2);
    scale(a4.scaleX, a4.scaleY, b3.scaleX, b3.scaleY, s4, q2);
    a4 = b3 = null;
    return function(t4) {
      var i3 = -1, n2 = q2.length, o3;
      while (++i3 < n2)
        s4[(o3 = q2[i3]).i] = o3.x(t4);
      return s4.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-interpolate/src/hsl.js
function hsl2(hue2) {
  return function(start2, end) {
    var h3 = hue2((start2 = hsl(start2)).h, (end = hsl(end)).h), s4 = nogamma(start2.s, end.s), l3 = nogamma(start2.l, end.l), opacity2 = nogamma(start2.opacity, end.opacity);
    return function(t4) {
      start2.h = h3(t4);
      start2.s = s4(t4);
      start2.l = l3(t4);
      start2.opacity = opacity2(t4);
      return start2 + "";
    };
  };
}
var hsl_default = hsl2(hue);
var hslLong = hsl2(nogamma);

// node_modules/d3-interpolate/src/lab.js
function lab2(start2, end) {
  var l3 = nogamma((start2 = lab(start2)).l, (end = lab(end)).l), a4 = nogamma(start2.a, end.a), b3 = nogamma(start2.b, end.b), opacity2 = nogamma(start2.opacity, end.opacity);
  return function(t4) {
    start2.l = l3(t4);
    start2.a = a4(t4);
    start2.b = b3(t4);
    start2.opacity = opacity2(t4);
    return start2 + "";
  };
}

// node_modules/d3-interpolate/src/hcl.js
function hcl2(hue2) {
  return function(start2, end) {
    var h3 = hue2((start2 = hcl(start2)).h, (end = hcl(end)).h), c6 = nogamma(start2.c, end.c), l3 = nogamma(start2.l, end.l), opacity2 = nogamma(start2.opacity, end.opacity);
    return function(t4) {
      start2.h = h3(t4);
      start2.c = c6(t4);
      start2.l = l3(t4);
      start2.opacity = opacity2(t4);
      return start2 + "";
    };
  };
}
var hcl_default = hcl2(hue);
var hclLong = hcl2(nogamma);

// node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue2) {
  return function cubehelixGamma(y3) {
    y3 = +y3;
    function cubehelix3(start2, end) {
      var h3 = hue2((start2 = cubehelix(start2)).h, (end = cubehelix(end)).h), s4 = nogamma(start2.s, end.s), l3 = nogamma(start2.l, end.l), opacity2 = nogamma(start2.opacity, end.opacity);
      return function(t4) {
        start2.h = h3(t4);
        start2.s = s4(t4);
        start2.l = l3(Math.pow(t4, y3));
        start2.opacity = opacity2(t4);
        return start2 + "";
      };
    }
    cubehelix3.gamma = cubehelixGamma;
    return cubehelix3;
  }(1);
}
var cubehelix_default = cubehelix2(hue);
var cubehelixLong = cubehelix2(nogamma);

// node_modules/d3-interpolate/src/piecewise.js
function piecewise(interpolate, values2) {
  if (values2 === void 0)
    values2 = interpolate, interpolate = value_default;
  var i3 = 0, n2 = values2.length - 1, v3 = values2[0], I2 = new Array(n2 < 0 ? 0 : n2);
  while (i3 < n2)
    I2[i3] = interpolate(v3, v3 = values2[++i3]);
  return function(t4) {
    var i4 = Math.max(0, Math.min(n2 - 1, Math.floor(t4 *= n2)));
    return I2[i4](t4 - i4);
  };
}

// node_modules/d3-interpolate/src/quantize.js
function quantize_default(interpolator, n2) {
  var samples = new Array(n2);
  for (var i3 = 0; i3 < n2; ++i3)
    samples[i3] = interpolator(i3 / (n2 - 1));
  return samples;
}

// node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f3) {
  setTimeout(f3, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time2) {
    if (typeof callback !== "function")
      throw new TypeError("callback is not a function");
    time2 = (time2 == null ? now() : +time2) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail)
        taskTail._next = this;
      else
        taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time2;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time2) {
  var t4 = new Timer();
  t4.restart(callback, delay, time2);
  return t4;
}
function timerFlush() {
  now();
  ++frame;
  var t4 = taskHead, e3;
  while (t4) {
    if ((e3 = clockNow - t4._time) >= 0)
      t4._call.call(void 0, e3);
    t4 = t4._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay)
    clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t03, t13 = taskHead, t23, time2 = Infinity;
  while (t13) {
    if (t13._call) {
      if (time2 > t13._time)
        time2 = t13._time;
      t03 = t13, t13 = t13._next;
    } else {
      t23 = t13._next, t13._next = null;
      t13 = t03 ? t03._next = t23 : taskHead = t23;
    }
  }
  taskTail = t03;
  sleep(time2);
}
function sleep(time2) {
  if (frame)
    return;
  if (timeout)
    timeout = clearTimeout(timeout);
  var delay = time2 - clockNow;
  if (delay > 24) {
    if (time2 < Infinity)
      timeout = setTimeout(wake, time2 - clock.now() - clockSkew);
    if (interval)
      interval = clearInterval(interval);
  } else {
    if (!interval)
      clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// node_modules/d3-timer/src/timeout.js
function timeout_default(callback, delay, time2) {
  var t4 = new Timer();
  delay = delay == null ? 0 : +delay;
  t4.restart((elapsed) => {
    t4.stop();
    callback(elapsed + delay);
  }, delay, time2);
  return t4;
}

// node_modules/d3-transition/src/transition/schedule.js
var emptyOn = dispatch_default("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule_default(node, name, id2, index2, group2, timing) {
  var schedules = node.__transition;
  if (!schedules)
    node.__transition = {};
  else if (id2 in schedules)
    return;
  create(node, id2, {
    name,
    index: index2,
    // For context during callback.
    group: group2,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init(node, id2) {
  var schedule = get2(node, id2);
  if (schedule.state > CREATED)
    throw new Error("too late; already scheduled");
  return schedule;
}
function set2(node, id2) {
  var schedule = get2(node, id2);
  if (schedule.state > STARTED)
    throw new Error("too late; already running");
  return schedule;
}
function get2(node, id2) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id2]))
    throw new Error("transition not found");
  return schedule;
}
function create(node, id2, self) {
  var schedules = node.__transition, tween;
  schedules[id2] = self;
  self.timer = timer(schedule, 0, self.time);
  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start2, self.delay, self.time);
    if (self.delay <= elapsed)
      start2(elapsed - self.delay);
  }
  function start2(elapsed) {
    var i3, j3, n2, o3;
    if (self.state !== SCHEDULED)
      return stop();
    for (i3 in schedules) {
      o3 = schedules[i3];
      if (o3.name !== self.name)
        continue;
      if (o3.state === STARTED)
        return timeout_default(start2);
      if (o3.state === RUNNING) {
        o3.state = ENDED;
        o3.timer.stop();
        o3.on.call("interrupt", node, node.__data__, o3.index, o3.group);
        delete schedules[i3];
      } else if (+i3 < id2) {
        o3.state = ENDED;
        o3.timer.stop();
        o3.on.call("cancel", node, node.__data__, o3.index, o3.group);
        delete schedules[i3];
      }
    }
    timeout_default(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING)
      return;
    self.state = STARTED;
    tween = new Array(n2 = self.tween.length);
    for (i3 = 0, j3 = -1; i3 < n2; ++i3) {
      if (o3 = self.tween[i3].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j3] = o3;
      }
    }
    tween.length = j3 + 1;
  }
  function tick(elapsed) {
    var t4 = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1), i3 = -1, n2 = tween.length;
    while (++i3 < n2) {
      tween[i3].call(node, t4);
    }
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }
  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id2];
    for (var i3 in schedules)
      return;
    delete node.__transition;
  }
}

// node_modules/d3-transition/src/interrupt.js
function interrupt_default(node, name) {
  var schedules = node.__transition, schedule, active, empty3 = true, i3;
  if (!schedules)
    return;
  name = name == null ? null : name + "";
  for (i3 in schedules) {
    if ((schedule = schedules[i3]).name !== name) {
      empty3 = false;
      continue;
    }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i3];
  }
  if (empty3)
    delete node.__transition;
}

// node_modules/d3-transition/src/selection/interrupt.js
function interrupt_default2(name) {
  return this.each(function() {
    interrupt_default(this, name);
  });
}

// node_modules/d3-transition/src/transition/tween.js
function tweenRemove(id2, name) {
  var tween0, tween1;
  return function() {
    var schedule = set2(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i3 = 0, n2 = tween1.length; i3 < n2; ++i3) {
        if (tween1[i3].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i3, 1);
          break;
        }
      }
    }
    schedule.tween = tween1;
  };
}
function tweenFunction(id2, name, value) {
  var tween0, tween1;
  if (typeof value !== "function")
    throw new Error();
  return function() {
    var schedule = set2(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t4 = { name, value }, i3 = 0, n2 = tween1.length; i3 < n2; ++i3) {
        if (tween1[i3].name === name) {
          tween1[i3] = t4;
          break;
        }
      }
      if (i3 === n2)
        tween1.push(t4);
    }
    schedule.tween = tween1;
  };
}
function tween_default(name, value) {
  var id2 = this._id;
  name += "";
  if (arguments.length < 2) {
    var tween = get2(this.node(), id2).tween;
    for (var i3 = 0, n2 = tween.length, t4; i3 < n2; ++i3) {
      if ((t4 = tween[i3]).name === name) {
        return t4.value;
      }
    }
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
}
function tweenValue(transition2, name, value) {
  var id2 = transition2._id;
  transition2.each(function() {
    var schedule = set2(this, id2);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });
  return function(node) {
    return get2(node, id2).value[name];
  };
}

// node_modules/d3-transition/src/transition/interpolate.js
function interpolate_default(a4, b3) {
  var c6;
  return (typeof b3 === "number" ? number_default : b3 instanceof color ? rgb_default : (c6 = color(b3)) ? (b3 = c6, rgb_default) : string_default)(a4, b3);
}

// node_modules/d3-transition/src/transition/attr.js
function attrRemove2(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS2(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrConstantNS2(fullname, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrFunction2(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attrFunctionNS2(fullname, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attr_default2(name, value) {
  var fullname = namespace_default(name), i3 = fullname === "transform" ? interpolateTransformSvg : interpolate_default;
  return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i3, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i3, value));
}

// node_modules/d3-transition/src/transition/attrTween.js
function attrInterpolate(name, i3) {
  return function(t4) {
    this.setAttribute(name, i3.call(this, t4));
  };
}
function attrInterpolateNS(fullname, i3) {
  return function(t4) {
    this.setAttributeNS(fullname.space, fullname.local, i3.call(this, t4));
  };
}
function attrTweenNS(fullname, value) {
  var t03, i0;
  function tween() {
    var i3 = value.apply(this, arguments);
    if (i3 !== i0)
      t03 = (i0 = i3) && attrInterpolateNS(fullname, i3);
    return t03;
  }
  tween._value = value;
  return tween;
}
function attrTween(name, value) {
  var t03, i0;
  function tween() {
    var i3 = value.apply(this, arguments);
    if (i3 !== i0)
      t03 = (i0 = i3) && attrInterpolate(name, i3);
    return t03;
  }
  tween._value = value;
  return tween;
}
function attrTween_default(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  var fullname = namespace_default(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}

// node_modules/d3-transition/src/transition/delay.js
function delayFunction(id2, value) {
  return function() {
    init(this, id2).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id2, value) {
  return value = +value, function() {
    init(this, id2).delay = value;
  };
}
function delay_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get2(this.node(), id2).delay;
}

// node_modules/d3-transition/src/transition/duration.js
function durationFunction(id2, value) {
  return function() {
    set2(this, id2).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id2, value) {
  return value = +value, function() {
    set2(this, id2).duration = value;
  };
}
function duration_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get2(this.node(), id2).duration;
}

// node_modules/d3-transition/src/transition/ease.js
function easeConstant(id2, value) {
  if (typeof value !== "function")
    throw new Error();
  return function() {
    set2(this, id2).ease = value;
  };
}
function ease_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value)) : get2(this.node(), id2).ease;
}

// node_modules/d3-transition/src/transition/easeVarying.js
function easeVarying(id2, value) {
  return function() {
    var v3 = value.apply(this, arguments);
    if (typeof v3 !== "function")
      throw new Error();
    set2(this, id2).ease = v3;
  };
}
function easeVarying_default(value) {
  if (typeof value !== "function")
    throw new Error();
  return this.each(easeVarying(this._id, value));
}

// node_modules/d3-transition/src/transition/filter.js
function filter_default2(match) {
  if (typeof match !== "function")
    match = matcher_default(match);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j3 = 0; j3 < m3; ++j3) {
    for (var group2 = groups2[j3], n2 = group2.length, subgroup = subgroups[j3] = [], node, i3 = 0; i3 < n2; ++i3) {
      if ((node = group2[i3]) && match.call(node, node.__data__, i3, group2)) {
        subgroup.push(node);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/merge.js
function merge_default2(transition2) {
  if (transition2._id !== this._id)
    throw new Error();
  for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m3 = Math.min(m0, m1), merges = new Array(m0), j3 = 0; j3 < m3; ++j3) {
    for (var group0 = groups0[j3], group1 = groups1[j3], n2 = group0.length, merge2 = merges[j3] = new Array(n2), node, i3 = 0; i3 < n2; ++i3) {
      if (node = group0[i3] || group1[i3]) {
        merge2[i3] = node;
      }
    }
  }
  for (; j3 < m0; ++j3) {
    merges[j3] = groups0[j3];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/on.js
function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t4) {
    var i3 = t4.indexOf(".");
    if (i3 >= 0)
      t4 = t4.slice(0, i3);
    return !t4 || t4 === "start";
  });
}
function onFunction(id2, name, listener) {
  var on0, on1, sit = start(name) ? init : set2;
  return function() {
    var schedule = sit(this, id2), on = schedule.on;
    if (on !== on0)
      (on1 = (on0 = on).copy()).on(name, listener);
    schedule.on = on1;
  };
}
function on_default2(name, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get2(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
}

// node_modules/d3-transition/src/transition/remove.js
function removeFunction(id2) {
  return function() {
    var parent = this.parentNode;
    for (var i3 in this.__transition)
      if (+i3 !== id2)
        return;
    if (parent)
      parent.removeChild(this);
  };
}
function remove_default2() {
  return this.on("end.remove", removeFunction(this._id));
}

// node_modules/d3-transition/src/transition/select.js
function select_default3(select) {
  var name = this._name, id2 = this._id;
  if (typeof select !== "function")
    select = selector_default(select);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j3 = 0; j3 < m3; ++j3) {
    for (var group2 = groups2[j3], n2 = group2.length, subgroup = subgroups[j3] = new Array(n2), node, subnode, i3 = 0; i3 < n2; ++i3) {
      if ((node = group2[i3]) && (subnode = select.call(node, node.__data__, i3, group2))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i3] = subnode;
        schedule_default(subgroup[i3], name, id2, i3, subgroup, get2(node, id2));
      }
    }
  }
  return new Transition(subgroups, this._parents, name, id2);
}

// node_modules/d3-transition/src/transition/selectAll.js
function selectAll_default2(select) {
  var name = this._name, id2 = this._id;
  if (typeof select !== "function")
    select = selectorAll_default(select);
  for (var groups2 = this._groups, m3 = groups2.length, subgroups = [], parents = [], j3 = 0; j3 < m3; ++j3) {
    for (var group2 = groups2[j3], n2 = group2.length, node, i3 = 0; i3 < n2; ++i3) {
      if (node = group2[i3]) {
        for (var children2 = select.call(node, node.__data__, i3, group2), child, inherit3 = get2(node, id2), k4 = 0, l3 = children2.length; k4 < l3; ++k4) {
          if (child = children2[k4]) {
            schedule_default(child, name, id2, k4, children2, inherit3);
          }
        }
        subgroups.push(children2);
        parents.push(node);
      }
    }
  }
  return new Transition(subgroups, parents, name, id2);
}

// node_modules/d3-transition/src/transition/selection.js
var Selection2 = selection_default.prototype.constructor;
function selection_default2() {
  return new Selection2(this._groups, this._parents);
}

// node_modules/d3-transition/src/transition/style.js
function styleNull(name, interpolate) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}
function styleRemove2(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function styleFunction2(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
    if (value1 == null)
      string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove2;
  return function() {
    var schedule = set2(this, id2), on = schedule.on, listener = schedule.value[key] == null ? remove2 || (remove2 = styleRemove2(name)) : void 0;
    if (on !== on0 || listener0 !== listener)
      (on1 = (on0 = on).copy()).on(event, listener0 = listener);
    schedule.on = on1;
  };
}
function style_default2(name, value, priority) {
  var i3 = (name += "") === "transform" ? interpolateTransformCss : interpolate_default;
  return value == null ? this.styleTween(name, styleNull(name, i3)).on("end.style." + name, styleRemove2(name)) : typeof value === "function" ? this.styleTween(name, styleFunction2(name, i3, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant2(name, i3, value), priority).on("end.style." + name, null);
}

// node_modules/d3-transition/src/transition/styleTween.js
function styleInterpolate(name, i3, priority) {
  return function(t4) {
    this.style.setProperty(name, i3.call(this, t4), priority);
  };
}
function styleTween(name, value, priority) {
  var t4, i0;
  function tween() {
    var i3 = value.apply(this, arguments);
    if (i3 !== i0)
      t4 = (i0 = i3) && styleInterpolate(name, i3, priority);
    return t4;
  }
  tween._value = value;
  return tween;
}
function styleTween_default(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}

// node_modules/d3-transition/src/transition/text.js
function textConstant2(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction2(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function text_default2(value) {
  return this.tween("text", typeof value === "function" ? textFunction2(tweenValue(this, "text", value)) : textConstant2(value == null ? "" : value + ""));
}

// node_modules/d3-transition/src/transition/textTween.js
function textInterpolate(i3) {
  return function(t4) {
    this.textContent = i3.call(this, t4);
  };
}
function textTween(value) {
  var t03, i0;
  function tween() {
    var i3 = value.apply(this, arguments);
    if (i3 !== i0)
      t03 = (i0 = i3) && textInterpolate(i3);
    return t03;
  }
  tween._value = value;
  return tween;
}
function textTween_default(value) {
  var key = "text";
  if (arguments.length < 1)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, textTween(value));
}

// node_modules/d3-transition/src/transition/transition.js
function transition_default() {
  var name = this._name, id0 = this._id, id1 = newId();
  for (var groups2 = this._groups, m3 = groups2.length, j3 = 0; j3 < m3; ++j3) {
    for (var group2 = groups2[j3], n2 = group2.length, node, i3 = 0; i3 < n2; ++i3) {
      if (node = group2[i3]) {
        var inherit3 = get2(node, id0);
        schedule_default(node, name, id1, i3, group2, {
          time: inherit3.time + inherit3.delay + inherit3.duration,
          delay: 0,
          duration: inherit3.duration,
          ease: inherit3.ease
        });
      }
    }
  }
  return new Transition(groups2, this._parents, name, id1);
}

// node_modules/d3-transition/src/transition/end.js
function end_default() {
  var on0, on1, that = this, id2 = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = { value: reject }, end = { value: function() {
      if (--size === 0)
        resolve();
    } };
    that.each(function() {
      var schedule = set2(this, id2), on = schedule.on;
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }
      schedule.on = on1;
    });
    if (size === 0)
      resolve();
  });
}

// node_modules/d3-transition/src/transition/index.js
var id = 0;
function Transition(groups2, parents, name, id2) {
  this._groups = groups2;
  this._parents = parents;
  this._name = name;
  this._id = id2;
}
function transition(name) {
  return selection_default().transition(name);
}
function newId() {
  return ++id;
}
var selection_prototype = selection_default.prototype;
Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: select_default3,
  selectAll: selectAll_default2,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: filter_default2,
  merge: merge_default2,
  selection: selection_default2,
  transition: transition_default,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: on_default2,
  attr: attr_default2,
  attrTween: attrTween_default,
  style: style_default2,
  styleTween: styleTween_default,
  text: text_default2,
  textTween: textTween_default,
  remove: remove_default2,
  tween: tween_default,
  delay: delay_default,
  duration: duration_default,
  ease: ease_default,
  easeVarying: easeVarying_default,
  end: end_default,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};

// node_modules/d3-ease/src/cubic.js
function cubicInOut(t4) {
  return ((t4 *= 2) <= 1 ? t4 * t4 * t4 : (t4 -= 2) * t4 * t4 + 2) / 2;
}

// node_modules/d3-transition/src/selection/transition.js
var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(node, id2) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id2])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id2} not found`);
    }
  }
  return timing;
}
function transition_default2(name) {
  var id2, timing;
  if (name instanceof Transition) {
    id2 = name._id, name = name._name;
  } else {
    id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }
  for (var groups2 = this._groups, m3 = groups2.length, j3 = 0; j3 < m3; ++j3) {
    for (var group2 = groups2[j3], n2 = group2.length, node, i3 = 0; i3 < n2; ++i3) {
      if (node = group2[i3]) {
        schedule_default(node, name, id2, i3, group2, timing || inherit(node, id2));
      }
    }
  }
  return new Transition(groups2, this._parents, name, id2);
}

// node_modules/d3-transition/src/selection/index.js
selection_default.prototype.interrupt = interrupt_default2;
selection_default.prototype.transition = transition_default2;

// node_modules/d3-brush/src/brush.js
var { abs, max: max2, min: min2 } = Math;
function number1(e3) {
  return [+e3[0], +e3[1]];
}
function number22(e3) {
  return [number1(e3[0]), number1(e3[1])];
}
var X = {
  name: "x",
  handles: ["w", "e"].map(type),
  input: function(x3, e3) {
    return x3 == null ? null : [[+x3[0], e3[0][1]], [+x3[1], e3[1][1]]];
  },
  output: function(xy) {
    return xy && [xy[0][0], xy[1][0]];
  }
};
var Y = {
  name: "y",
  handles: ["n", "s"].map(type),
  input: function(y3, e3) {
    return y3 == null ? null : [[e3[0][0], +y3[0]], [e3[1][0], +y3[1]]];
  },
  output: function(xy) {
    return xy && [xy[0][1], xy[1][1]];
  }
};
var XY = {
  name: "xy",
  handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
  input: function(xy) {
    return xy == null ? null : number22(xy);
  },
  output: function(xy) {
    return xy;
  }
};
function type(t4) {
  return { type: t4 };
}

// node_modules/d3-path/src/path.js
var pi = Math.PI;
var tau = 2 * pi;
var epsilon2 = 1e-6;
var tauEpsilon = tau - epsilon2;
function append(strings) {
  this._ += strings[0];
  for (let i3 = 1, n2 = strings.length; i3 < n2; ++i3) {
    this._ += arguments[i3] + strings[i3];
  }
}
function appendRound(digits) {
  let d3 = Math.floor(digits);
  if (!(d3 >= 0))
    throw new Error(`invalid digits: ${digits}`);
  if (d3 > 15)
    return append;
  const k4 = 10 ** d3;
  return function(strings) {
    this._ += strings[0];
    for (let i3 = 1, n2 = strings.length; i3 < n2; ++i3) {
      this._ += Math.round(arguments[i3] * k4) / k4 + strings[i3];
    }
  };
}
var Path = class {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
    this._append = digits == null ? append : appendRound(digits);
  }
  moveTo(x3, y3) {
    this._append`M${this._x0 = this._x1 = +x3},${this._y0 = this._y1 = +y3}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x3, y3) {
    this._append`L${this._x1 = +x3},${this._y1 = +y3}`;
  }
  quadraticCurveTo(x12, y12, x3, y3) {
    this._append`Q${+x12},${+y12},${this._x1 = +x3},${this._y1 = +y3}`;
  }
  bezierCurveTo(x12, y12, x22, y22, x3, y3) {
    this._append`C${+x12},${+y12},${+x22},${+y22},${this._x1 = +x3},${this._y1 = +y3}`;
  }
  arcTo(x12, y12, x22, y22, r3) {
    x12 = +x12, y12 = +y12, x22 = +x22, y22 = +y22, r3 = +r3;
    if (r3 < 0)
      throw new Error(`negative radius: ${r3}`);
    let x05 = this._x1, y05 = this._y1, x21 = x22 - x12, y21 = y22 - y12, x01 = x05 - x12, y01 = y05 - y12, l01_2 = x01 * x01 + y01 * y01;
    if (this._x1 === null) {
      this._append`M${this._x1 = x12},${this._y1 = y12}`;
    } else if (!(l01_2 > epsilon2))
      ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon2) || !r3) {
      this._append`L${this._x1 = x12},${this._y1 = y12}`;
    } else {
      let x20 = x22 - x05, y20 = y22 - y05, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l3 = r3 * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l3 / l01, t21 = l3 / l21;
      if (Math.abs(t01 - 1) > epsilon2) {
        this._append`L${x12 + t01 * x01},${y12 + t01 * y01}`;
      }
      this._append`A${r3},${r3},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x12 + t21 * x21},${this._y1 = y12 + t21 * y21}`;
    }
  }
  arc(x3, y3, r3, a0, a1, ccw) {
    x3 = +x3, y3 = +y3, r3 = +r3, ccw = !!ccw;
    if (r3 < 0)
      throw new Error(`negative radius: ${r3}`);
    let dx = r3 * Math.cos(a0), dy = r3 * Math.sin(a0), x05 = x3 + dx, y05 = y3 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (this._x1 === null) {
      this._append`M${x05},${y05}`;
    } else if (Math.abs(this._x1 - x05) > epsilon2 || Math.abs(this._y1 - y05) > epsilon2) {
      this._append`L${x05},${y05}`;
    }
    if (!r3)
      return;
    if (da < 0)
      da = da % tau + tau;
    if (da > tauEpsilon) {
      this._append`A${r3},${r3},0,1,${cw},${x3 - dx},${y3 - dy}A${r3},${r3},0,1,${cw},${this._x1 = x05},${this._y1 = y05}`;
    } else if (da > epsilon2) {
      this._append`A${r3},${r3},0,${+(da >= pi)},${cw},${this._x1 = x3 + r3 * Math.cos(a1)},${this._y1 = y3 + r3 * Math.sin(a1)}`;
    }
  }
  rect(x3, y3, w3, h3) {
    this._append`M${this._x0 = this._x1 = +x3},${this._y0 = this._y1 = +y3}h${w3 = +w3}v${+h3}h${-w3}Z`;
  }
  toString() {
    return this._;
  }
};
function path() {
  return new Path();
}
path.prototype = Path.prototype;
function pathRound(digits = 3) {
  return new Path(+digits);
}

// node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x3) {
  return Math.abs(x3 = Math.round(x3)) >= 1e21 ? x3.toLocaleString("en").replace(/,/g, "") : x3.toString(10);
}
function formatDecimalParts(x3, p3) {
  if ((i3 = (x3 = p3 ? x3.toExponential(p3 - 1) : x3.toExponential()).indexOf("e")) < 0)
    return null;
  var i3, coefficient = x3.slice(0, i3);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x3.slice(i3 + 1)
  ];
}

// node_modules/d3-format/src/exponent.js
function exponent_default(x3) {
  return x3 = formatDecimalParts(Math.abs(x3)), x3 ? x3[1] : NaN;
}

// node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value, width) {
    var i3 = value.length, t4 = [], j3 = 0, g3 = grouping[0], length3 = 0;
    while (i3 > 0 && g3 > 0) {
      if (length3 + g3 + 1 > width)
        g3 = Math.max(1, width - length3);
      t4.push(value.substring(i3 -= g3, i3 + g3));
      if ((length3 += g3 + 1) > width)
        break;
      g3 = grouping[j3 = (j3 + 1) % grouping.length];
    }
    return t4.reverse().join(thousands);
  };
}

// node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i3) {
      return numerals[+i3];
    });
  };
}

// node_modules/d3-format/src/formatSpecifier.js
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s4) {
  out:
    for (var n2 = s4.length, i3 = 1, i0 = -1, i1; i3 < n2; ++i3) {
      switch (s4[i3]) {
        case ".":
          i0 = i1 = i3;
          break;
        case "0":
          if (i0 === 0)
            i0 = i3;
          i1 = i3;
          break;
        default:
          if (!+s4[i3])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s4.slice(0, i0) + s4.slice(i1 + 1) : s4;
}

// node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent;
function formatPrefixAuto_default(x3, p3) {
  var d3 = formatDecimalParts(x3, p3);
  if (!d3)
    return x3 + "";
  var coefficient = d3[0], exponent = d3[1], i3 = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n2 = coefficient.length;
  return i3 === n2 ? coefficient : i3 > n2 ? coefficient + new Array(i3 - n2 + 1).join("0") : i3 > 0 ? coefficient.slice(0, i3) + "." + coefficient.slice(i3) : "0." + new Array(1 - i3).join("0") + formatDecimalParts(x3, Math.max(0, p3 + i3 - 1))[0];
}

// node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x3, p3) {
  var d3 = formatDecimalParts(x3, p3);
  if (!d3)
    return x3 + "";
  var coefficient = d3[0], exponent = d3[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

// node_modules/d3-format/src/formatTypes.js
var formatTypes_default = {
  "%": (x3, p3) => (x3 * 100).toFixed(p3),
  "b": (x3) => Math.round(x3).toString(2),
  "c": (x3) => x3 + "",
  "d": formatDecimal_default,
  "e": (x3, p3) => x3.toExponential(p3),
  "f": (x3, p3) => x3.toFixed(p3),
  "g": (x3, p3) => x3.toPrecision(p3),
  "o": (x3) => Math.round(x3).toString(8),
  "p": (x3, p3) => formatRounded_default(x3 * 100, p3),
  "r": formatRounded_default,
  "s": formatPrefixAuto_default,
  "X": (x3) => Math.round(x3).toString(16).toUpperCase(),
  "x": (x3) => Math.round(x3).toString(16)
};

// node_modules/d3-format/src/identity.js
function identity_default2(x3) {
  return x3;
}

// node_modules/d3-format/src/locale.js
var map = Array.prototype.map;
var prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default(locale3) {
  var group2 = locale3.grouping === void 0 || locale3.thousands === void 0 ? identity_default2 : formatGroup_default(map.call(locale3.grouping, Number), locale3.thousands + ""), currencyPrefix = locale3.currency === void 0 ? "" : locale3.currency[0] + "", currencySuffix = locale3.currency === void 0 ? "" : locale3.currency[1] + "", decimal = locale3.decimal === void 0 ? "." : locale3.decimal + "", numerals = locale3.numerals === void 0 ? identity_default2 : formatNumerals_default(map.call(locale3.numerals, String)), percent = locale3.percent === void 0 ? "%" : locale3.percent + "", minus = locale3.minus === void 0 ? "\u2212" : locale3.minus + "", nan = locale3.nan === void 0 ? "NaN" : locale3.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign2 = specifier.sign, symbol2 = specifier.symbol, zero3 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type2 = specifier.type;
    if (type2 === "n")
      comma = true, type2 = "g";
    else if (!formatTypes_default[type2])
      precision === void 0 && (precision = 12), trim = true, type2 = "g";
    if (zero3 || fill === "0" && align === "=")
      zero3 = true, fill = "0", align = "=";
    var prefix = symbol2 === "$" ? currencyPrefix : symbol2 === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "", suffix = symbol2 === "$" ? currencySuffix : /[%p]/.test(type2) ? percent : "";
    var formatType = formatTypes_default[type2], maybeSuffix = /[defgprs%]/.test(type2);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format3(value) {
      var valuePrefix = prefix, valueSuffix = suffix, i3, n2, c6;
      if (type2 === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim)
          value = formatTrim_default(value);
        if (valueNegative && +value === 0 && sign2 !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign2 === "(" ? sign2 : minus : sign2 === "-" || sign2 === "(" ? "" : sign2) + valuePrefix;
        valueSuffix = (type2 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign2 === "(" ? ")" : "");
        if (maybeSuffix) {
          i3 = -1, n2 = value.length;
          while (++i3 < n2) {
            if (c6 = value.charCodeAt(i3), 48 > c6 || c6 > 57) {
              valueSuffix = (c6 === 46 ? decimal + value.slice(i3 + 1) : value.slice(i3)) + valueSuffix;
              value = value.slice(0, i3);
              break;
            }
          }
        }
      }
      if (comma && !zero3)
        value = group2(value, Infinity);
      var length3 = valuePrefix.length + value.length + valueSuffix.length, padding = length3 < width ? new Array(width - length3 + 1).join(fill) : "";
      if (comma && zero3)
        value = group2(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length3 = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length3);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format3.toString = function() {
      return specifier + "";
    };
    return format3;
  }
  function formatPrefix2(specifier, value) {
    var f3 = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e3 = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k4 = Math.pow(10, -e3), prefix = prefixes[8 + e3 / 3];
    return function(value2) {
      return f3(k4 * value2) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}

// node_modules/d3-format/src/defaultLocale.js
var locale;
var format;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = locale_default(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

// node_modules/d3-format/src/precisionFixed.js
function precisionFixed_default(step) {
  return Math.max(0, -exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionPrefix.js
function precisionPrefix_default(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionRound.js
function precisionRound_default(step, max3) {
  step = Math.abs(step), max3 = Math.abs(max3) - step;
  return Math.max(0, exponent_default(max3) - exponent_default(step)) + 1;
}

// node_modules/d3-geo/src/math.js
var epsilon3 = 1e-6;
var epsilon22 = 1e-12;
var pi2 = Math.PI;
var halfPi = pi2 / 2;
var quarterPi = pi2 / 4;
var tau2 = pi2 * 2;
var degrees3 = 180 / pi2;
var radians2 = pi2 / 180;
var abs2 = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos = Math.cos;
var exp = Math.exp;
var log = Math.log;
var pow = Math.pow;
var sin = Math.sin;
var sign = Math.sign || function(x3) {
  return x3 > 0 ? 1 : x3 < 0 ? -1 : 0;
};
var sqrt = Math.sqrt;
var tan = Math.tan;
function acos(x3) {
  return x3 > 1 ? 0 : x3 < -1 ? pi2 : Math.acos(x3);
}
function asin(x3) {
  return x3 > 1 ? halfPi : x3 < -1 ? -halfPi : Math.asin(x3);
}

// node_modules/d3-geo/src/noop.js
function noop2() {
}

// node_modules/d3-geo/src/stream.js
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}
var streamObjectType = {
  Feature: function(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function(object, stream) {
    var features = object.features, i3 = -1, n2 = features.length;
    while (++i3 < n2)
      streamGeometry(features[i3].geometry, stream);
  }
};
var streamGeometryType = {
  Sphere: function(object, stream) {
    stream.sphere();
  },
  Point: function(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function(object, stream) {
    var coordinates = object.coordinates, i3 = -1, n2 = coordinates.length;
    while (++i3 < n2)
      object = coordinates[i3], stream.point(object[0], object[1], object[2]);
  },
  LineString: function(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function(object, stream) {
    var coordinates = object.coordinates, i3 = -1, n2 = coordinates.length;
    while (++i3 < n2)
      streamLine(coordinates[i3], stream, 0);
  },
  Polygon: function(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function(object, stream) {
    var coordinates = object.coordinates, i3 = -1, n2 = coordinates.length;
    while (++i3 < n2)
      streamPolygon(coordinates[i3], stream);
  },
  GeometryCollection: function(object, stream) {
    var geometries = object.geometries, i3 = -1, n2 = geometries.length;
    while (++i3 < n2)
      streamGeometry(geometries[i3], stream);
  }
};
function streamLine(coordinates, stream, closed) {
  var i3 = -1, n2 = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i3 < n2)
    coordinate = coordinates[i3], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}
function streamPolygon(coordinates, stream) {
  var i3 = -1, n2 = coordinates.length;
  stream.polygonStart();
  while (++i3 < n2)
    streamLine(coordinates[i3], stream, 1);
  stream.polygonEnd();
}
function stream_default(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
}

// node_modules/d3-geo/src/cartesian.js
function spherical(cartesian2) {
  return [atan2(cartesian2[1], cartesian2[0]), asin(cartesian2[2])];
}
function cartesian(spherical2) {
  var lambda = spherical2[0], phi = spherical2[1], cosPhi = cos(phi);
  return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
}
function cartesianDot(a4, b3) {
  return a4[0] * b3[0] + a4[1] * b3[1] + a4[2] * b3[2];
}
function cartesianCross(a4, b3) {
  return [a4[1] * b3[2] - a4[2] * b3[1], a4[2] * b3[0] - a4[0] * b3[2], a4[0] * b3[1] - a4[1] * b3[0]];
}
function cartesianAddInPlace(a4, b3) {
  a4[0] += b3[0], a4[1] += b3[1], a4[2] += b3[2];
}
function cartesianScale(vector, k4) {
  return [vector[0] * k4, vector[1] * k4, vector[2] * k4];
}
function cartesianNormalizeInPlace(d3) {
  var l3 = sqrt(d3[0] * d3[0] + d3[1] * d3[1] + d3[2] * d3[2]);
  d3[0] /= l3, d3[1] /= l3, d3[2] /= l3;
}

// node_modules/d3-geo/src/compose.js
function compose_default(a4, b3) {
  function compose(x3, y3) {
    return x3 = a4(x3, y3), b3(x3[0], x3[1]);
  }
  if (a4.invert && b3.invert)
    compose.invert = function(x3, y3) {
      return x3 = b3.invert(x3, y3), x3 && a4.invert(x3[0], x3[1]);
    };
  return compose;
}

// node_modules/d3-geo/src/rotation.js
function rotationIdentity(lambda, phi) {
  if (abs2(lambda) > pi2)
    lambda -= Math.round(lambda / tau2) * tau2;
  return [lambda, phi];
}
rotationIdentity.invert = rotationIdentity;
function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau2) ? deltaPhi || deltaGamma ? compose_default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}
function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi) {
    lambda += deltaLambda;
    if (abs2(lambda) > pi2)
      lambda -= Math.round(lambda / tau2) * tau2;
    return [lambda, phi];
  };
}
function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}
function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos(deltaPhi), sinDeltaPhi = sin(deltaPhi), cosDeltaGamma = cos(deltaGamma), sinDeltaGamma = sin(deltaGamma);
  function rotation(lambda, phi) {
    var cosPhi = cos(phi), x3 = cos(lambda) * cosPhi, y3 = sin(lambda) * cosPhi, z3 = sin(phi), k4 = z3 * cosDeltaPhi + x3 * sinDeltaPhi;
    return [
      atan2(y3 * cosDeltaGamma - k4 * sinDeltaGamma, x3 * cosDeltaPhi - z3 * sinDeltaPhi),
      asin(k4 * cosDeltaGamma + y3 * sinDeltaGamma)
    ];
  }
  rotation.invert = function(lambda, phi) {
    var cosPhi = cos(phi), x3 = cos(lambda) * cosPhi, y3 = sin(lambda) * cosPhi, z3 = sin(phi), k4 = z3 * cosDeltaGamma - y3 * sinDeltaGamma;
    return [
      atan2(y3 * cosDeltaGamma + z3 * sinDeltaGamma, x3 * cosDeltaPhi + k4 * sinDeltaPhi),
      asin(k4 * cosDeltaPhi - x3 * sinDeltaPhi)
    ];
  };
  return rotation;
}
function rotation_default(rotate) {
  rotate = rotateRadians(rotate[0] * radians2, rotate[1] * radians2, rotate.length > 2 ? rotate[2] * radians2 : 0);
  function forward(coordinates) {
    coordinates = rotate(coordinates[0] * radians2, coordinates[1] * radians2);
    return coordinates[0] *= degrees3, coordinates[1] *= degrees3, coordinates;
  }
  forward.invert = function(coordinates) {
    coordinates = rotate.invert(coordinates[0] * radians2, coordinates[1] * radians2);
    return coordinates[0] *= degrees3, coordinates[1] *= degrees3, coordinates;
  };
  return forward;
}

// node_modules/d3-geo/src/circle.js
function circleStream(stream, radius2, delta, direction, t03, t13) {
  if (!delta)
    return;
  var cosRadius = cos(radius2), sinRadius = sin(radius2), step = direction * delta;
  if (t03 == null) {
    t03 = radius2 + direction * tau2;
    t13 = radius2 - step / 2;
  } else {
    t03 = circleRadius(cosRadius, t03);
    t13 = circleRadius(cosRadius, t13);
    if (direction > 0 ? t03 < t13 : t03 > t13)
      t03 += direction * tau2;
  }
  for (var point2, t4 = t03; direction > 0 ? t4 > t13 : t4 < t13; t4 -= step) {
    point2 = spherical([cosRadius, -sinRadius * cos(t4), -sinRadius * sin(t4)]);
    stream.point(point2[0], point2[1]);
  }
}
function circleRadius(cosRadius, point2) {
  point2 = cartesian(point2), point2[0] -= cosRadius;
  cartesianNormalizeInPlace(point2);
  var radius2 = acos(-point2[1]);
  return ((-point2[2] < 0 ? -radius2 : radius2) + tau2 - epsilon3) % tau2;
}

// node_modules/d3-geo/src/clip/buffer.js
function buffer_default() {
  var lines = [], line;
  return {
    point: function(x3, y3, m3) {
      line.push([x3, y3, m3]);
    },
    lineStart: function() {
      lines.push(line = []);
    },
    lineEnd: noop2,
    rejoin: function() {
      if (lines.length > 1)
        lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
}

// node_modules/d3-geo/src/pointEqual.js
function pointEqual_default(a4, b3) {
  return abs2(a4[0] - b3[0]) < epsilon3 && abs2(a4[1] - b3[1]) < epsilon3;
}

// node_modules/d3-geo/src/clip/rejoin.js
function Intersection(point2, points, other, entry) {
  this.x = point2;
  this.z = points;
  this.o = other;
  this.e = entry;
  this.v = false;
  this.n = this.p = null;
}
function rejoin_default(segments, compareIntersection2, startInside, interpolate, stream) {
  var subject = [], clip = [], i3, n2;
  segments.forEach(function(segment) {
    if ((n3 = segment.length - 1) <= 0)
      return;
    var n3, p0 = segment[0], p1 = segment[n3], x3;
    if (pointEqual_default(p0, p1)) {
      if (!p0[2] && !p1[2]) {
        stream.lineStart();
        for (i3 = 0; i3 < n3; ++i3)
          stream.point((p0 = segment[i3])[0], p0[1]);
        stream.lineEnd();
        return;
      }
      p1[0] += 2 * epsilon3;
    }
    subject.push(x3 = new Intersection(p0, segment, null, true));
    clip.push(x3.o = new Intersection(p0, null, x3, false));
    subject.push(x3 = new Intersection(p1, segment, null, false));
    clip.push(x3.o = new Intersection(p1, null, x3, true));
  });
  if (!subject.length)
    return;
  clip.sort(compareIntersection2);
  link(subject);
  link(clip);
  for (i3 = 0, n2 = clip.length; i3 < n2; ++i3) {
    clip[i3].e = startInside = !startInside;
  }
  var start2 = subject[0], points, point2;
  while (1) {
    var current = start2, isSubject = true;
    while (current.v)
      if ((current = current.n) === start2)
        return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i3 = 0, n2 = points.length; i3 < n2; ++i3)
            stream.point((point2 = points[i3])[0], point2[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i3 = points.length - 1; i3 >= 0; --i3)
            stream.point((point2 = points[i3])[0], point2[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}
function link(array2) {
  if (!(n2 = array2.length))
    return;
  var n2, i3 = 0, a4 = array2[0], b3;
  while (++i3 < n2) {
    a4.n = b3 = array2[i3];
    b3.p = a4;
    a4 = b3;
  }
  a4.n = b3 = array2[0];
  b3.p = a4;
}

// node_modules/d3-geo/src/polygonContains.js
function longitude(point2) {
  return abs2(point2[0]) <= pi2 ? point2[0] : sign(point2[0]) * ((abs2(point2[0]) + pi2) % tau2 - pi2);
}
function polygonContains_default(polygon, point2) {
  var lambda = longitude(point2), phi = point2[1], sinPhi = sin(phi), normal = [sin(lambda), -cos(lambda), 0], angle = 0, winding = 0;
  var sum2 = new Adder();
  if (sinPhi === 1)
    phi = halfPi + epsilon3;
  else if (sinPhi === -1)
    phi = -halfPi - epsilon3;
  for (var i3 = 0, n2 = polygon.length; i3 < n2; ++i3) {
    if (!(m3 = (ring = polygon[i3]).length))
      continue;
    var ring, m3, point0 = ring[m3 - 1], lambda0 = longitude(point0), phi0 = point0[1] / 2 + quarterPi, sinPhi0 = sin(phi0), cosPhi0 = cos(phi0);
    for (var j3 = 0; j3 < m3; ++j3, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j3], lambda1 = longitude(point1), phi1 = point1[1] / 2 + quarterPi, sinPhi1 = sin(phi1), cosPhi1 = cos(phi1), delta = lambda1 - lambda0, sign2 = delta >= 0 ? 1 : -1, absDelta = sign2 * delta, antimeridian = absDelta > pi2, k4 = sinPhi0 * sinPhi1;
      sum2.add(atan2(k4 * sign2 * sin(absDelta), cosPhi0 * cosPhi1 + k4 * cos(absDelta)));
      angle += antimeridian ? delta + sign2 * tau2 : delta;
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = cartesianCross(cartesian(point0), cartesian(point1));
        cartesianNormalizeInPlace(arc);
        var intersection = cartesianCross(normal, arc);
        cartesianNormalizeInPlace(intersection);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }
  return (angle < -epsilon3 || angle < epsilon3 && sum2 < -epsilon22) ^ winding & 1;
}

// node_modules/d3-geo/src/clip/index.js
function clip_default(pointVisible, clipLine, interpolate, start2) {
  return function(sink) {
    var line = clipLine(sink), ringBuffer = buffer_default(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments, ring;
    var clip = {
      point: point2,
      lineStart,
      lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point2;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = merge(segments);
        var startInside = polygonContains_default(polygon, start2);
        if (segments.length) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          rejoin_default(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted)
          sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };
    function point2(lambda, phi) {
      if (pointVisible(lambda, phi))
        sink.point(lambda, phi);
    }
    function pointLine(lambda, phi) {
      line.point(lambda, phi);
    }
    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }
    function lineEnd() {
      clip.point = point2;
      line.lineEnd();
    }
    function pointRing(lambda, phi) {
      ring.push([lambda, phi]);
      ringSink.point(lambda, phi);
    }
    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }
    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i3, n2 = ringSegments.length, m3, segment, point3;
      ring.pop();
      polygon.push(ring);
      ring = null;
      if (!n2)
        return;
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m3 = segment.length - 1) > 0) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i3 = 0; i3 < m3; ++i3)
            sink.point((point3 = segment[i3])[0], point3[1]);
          sink.lineEnd();
        }
        return;
      }
      if (n2 > 1 && clean & 2)
        ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments.push(ringSegments.filter(validSegment));
    }
    return clip;
  };
}
function validSegment(segment) {
  return segment.length > 1;
}
function compareIntersection(a4, b3) {
  return ((a4 = a4.x)[0] < 0 ? a4[1] - halfPi - epsilon3 : halfPi - a4[1]) - ((b3 = b3.x)[0] < 0 ? b3[1] - halfPi - epsilon3 : halfPi - b3[1]);
}

// node_modules/d3-geo/src/clip/antimeridian.js
var antimeridian_default = clip_default(
  function() {
    return true;
  },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-pi2, -halfPi]
);
function clipAntimeridianLine(stream) {
  var lambda0 = NaN, phi0 = NaN, sign0 = NaN, clean;
  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? pi2 : -pi2, delta = abs2(lambda1 - lambda0);
      if (abs2(delta - pi2) < epsilon3) {
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi2) {
        if (abs2(lambda0 - sign0) < epsilon3)
          lambda0 -= sign0 * epsilon3;
        if (abs2(lambda1 - sign1) < epsilon3)
          lambda1 -= sign1 * epsilon3;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean;
    }
  };
}
function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0, cosPhi1, sinLambda0Lambda1 = sin(lambda0 - lambda1);
  return abs2(sinLambda0Lambda1) > epsilon3 ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1) - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
}
function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi;
  if (from == null) {
    phi = direction * halfPi;
    stream.point(-pi2, phi);
    stream.point(0, phi);
    stream.point(pi2, phi);
    stream.point(pi2, 0);
    stream.point(pi2, -phi);
    stream.point(0, -phi);
    stream.point(-pi2, -phi);
    stream.point(-pi2, 0);
    stream.point(-pi2, phi);
  } else if (abs2(from[0] - to[0]) > epsilon3) {
    var lambda = from[0] < to[0] ? pi2 : -pi2;
    phi = direction * lambda / 2;
    stream.point(-lambda, phi);
    stream.point(0, phi);
    stream.point(lambda, phi);
  } else {
    stream.point(to[0], to[1]);
  }
}

// node_modules/d3-geo/src/clip/circle.js
function circle_default(radius2) {
  var cr = cos(radius2), delta = 6 * radians2, smallRadius = cr > 0, notHemisphere = abs2(cr) > epsilon3;
  function interpolate(from, to, direction, stream) {
    circleStream(stream, radius2, delta, direction, from, to);
  }
  function visible(lambda, phi) {
    return cos(lambda) * cos(phi) > cr;
  }
  function clipLine(stream) {
    var point0, c0, v0, v00, clean;
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi) {
        var point1 = [lambda, phi], point2, v3 = visible(lambda, phi), c6 = smallRadius ? v3 ? 0 : code(lambda, phi) : v3 ? code(lambda + (lambda < 0 ? pi2 : -pi2), phi) : 0;
        if (!point0 && (v00 = v0 = v3))
          stream.lineStart();
        if (v3 !== v0) {
          point2 = intersect(point0, point1);
          if (!point2 || pointEqual_default(point0, point2) || pointEqual_default(point1, point2))
            point1[2] = 1;
        }
        if (v3 !== v0) {
          clean = 0;
          if (v3) {
            stream.lineStart();
            point2 = intersect(point1, point0);
            stream.point(point2[0], point2[1]);
          } else {
            point2 = intersect(point0, point1);
            stream.point(point2[0], point2[1], 2);
            stream.lineEnd();
          }
          point0 = point2;
        } else if (notHemisphere && point0 && smallRadius ^ v3) {
          var t4;
          if (!(c6 & c0) && (t4 = intersect(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t4[0][0], t4[0][1]);
              stream.point(t4[1][0], t4[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t4[1][0], t4[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t4[0][0], t4[0][1], 3);
            }
          }
        }
        if (v3 && (!point0 || !pointEqual_default(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v3, c0 = c6;
      },
      lineEnd: function() {
        if (v0)
          stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | (v00 && v0) << 1;
      }
    };
  }
  function intersect(a4, b3, two) {
    var pa = cartesian(a4), pb = cartesian(b3);
    var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
    if (!determinant)
      return !two && a4;
    var c1 = cr * n2n2 / determinant, c22 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A5 = cartesianScale(n1, c1), B4 = cartesianScale(n2, c22);
    cartesianAddInPlace(A5, B4);
    var u3 = n1xn2, w3 = cartesianDot(A5, u3), uu = cartesianDot(u3, u3), t23 = w3 * w3 - uu * (cartesianDot(A5, A5) - 1);
    if (t23 < 0)
      return;
    var t4 = sqrt(t23), q2 = cartesianScale(u3, (-w3 - t4) / uu);
    cartesianAddInPlace(q2, A5);
    q2 = spherical(q2);
    if (!two)
      return q2;
    var lambda0 = a4[0], lambda1 = b3[0], phi0 = a4[1], phi1 = b3[1], z3;
    if (lambda1 < lambda0)
      z3 = lambda0, lambda0 = lambda1, lambda1 = z3;
    var delta2 = lambda1 - lambda0, polar = abs2(delta2 - pi2) < epsilon3, meridian = polar || delta2 < epsilon3;
    if (!polar && phi1 < phi0)
      z3 = phi0, phi0 = phi1, phi1 = z3;
    if (meridian ? polar ? phi0 + phi1 > 0 ^ q2[1] < (abs2(q2[0] - lambda0) < epsilon3 ? phi0 : phi1) : phi0 <= q2[1] && q2[1] <= phi1 : delta2 > pi2 ^ (lambda0 <= q2[0] && q2[0] <= lambda1)) {
      var q1 = cartesianScale(u3, (-w3 + t4) / uu);
      cartesianAddInPlace(q1, A5);
      return [q2, spherical(q1)];
    }
  }
  function code(lambda, phi) {
    var r3 = smallRadius ? radius2 : pi2 - radius2, code2 = 0;
    if (lambda < -r3)
      code2 |= 1;
    else if (lambda > r3)
      code2 |= 2;
    if (phi < -r3)
      code2 |= 4;
    else if (phi > r3)
      code2 |= 8;
    return code2;
  }
  return clip_default(visible, clipLine, interpolate, smallRadius ? [0, -radius2] : [-pi2, radius2 - pi2]);
}

// node_modules/d3-geo/src/clip/line.js
function line_default(a4, b3, x05, y05, x12, y12) {
  var ax = a4[0], ay = a4[1], bx = b3[0], by = b3[1], t03 = 0, t13 = 1, dx = bx - ax, dy = by - ay, r3;
  r3 = x05 - ax;
  if (!dx && r3 > 0)
    return;
  r3 /= dx;
  if (dx < 0) {
    if (r3 < t03)
      return;
    if (r3 < t13)
      t13 = r3;
  } else if (dx > 0) {
    if (r3 > t13)
      return;
    if (r3 > t03)
      t03 = r3;
  }
  r3 = x12 - ax;
  if (!dx && r3 < 0)
    return;
  r3 /= dx;
  if (dx < 0) {
    if (r3 > t13)
      return;
    if (r3 > t03)
      t03 = r3;
  } else if (dx > 0) {
    if (r3 < t03)
      return;
    if (r3 < t13)
      t13 = r3;
  }
  r3 = y05 - ay;
  if (!dy && r3 > 0)
    return;
  r3 /= dy;
  if (dy < 0) {
    if (r3 < t03)
      return;
    if (r3 < t13)
      t13 = r3;
  } else if (dy > 0) {
    if (r3 > t13)
      return;
    if (r3 > t03)
      t03 = r3;
  }
  r3 = y12 - ay;
  if (!dy && r3 < 0)
    return;
  r3 /= dy;
  if (dy < 0) {
    if (r3 > t13)
      return;
    if (r3 > t03)
      t03 = r3;
  } else if (dy > 0) {
    if (r3 < t03)
      return;
    if (r3 < t13)
      t13 = r3;
  }
  if (t03 > 0)
    a4[0] = ax + t03 * dx, a4[1] = ay + t03 * dy;
  if (t13 < 1)
    b3[0] = ax + t13 * dx, b3[1] = ay + t13 * dy;
  return true;
}

// node_modules/d3-geo/src/clip/rectangle.js
var clipMax = 1e9;
var clipMin = -clipMax;
function clipRectangle(x05, y05, x12, y12) {
  function visible(x3, y3) {
    return x05 <= x3 && x3 <= x12 && y05 <= y3 && y3 <= y12;
  }
  function interpolate(from, to, direction, stream) {
    var a4 = 0, a1 = 0;
    if (from == null || (a4 = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
      do
        stream.point(a4 === 0 || a4 === 3 ? x05 : x12, a4 > 1 ? y12 : y05);
      while ((a4 = (a4 + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }
  function corner(p3, direction) {
    return abs2(p3[0] - x05) < epsilon3 ? direction > 0 ? 0 : 3 : abs2(p3[0] - x12) < epsilon3 ? direction > 0 ? 2 : 1 : abs2(p3[1] - y05) < epsilon3 ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
  }
  function compareIntersection2(a4, b3) {
    return comparePoint(a4.x, b3.x);
  }
  function comparePoint(a4, b3) {
    var ca = corner(a4, 1), cb = corner(b3, 1);
    return ca !== cb ? ca - cb : ca === 0 ? b3[1] - a4[1] : ca === 1 ? a4[0] - b3[0] : ca === 2 ? a4[1] - b3[1] : b3[0] - a4[0];
  }
  return function(stream) {
    var activeStream = stream, bufferStream = buffer_default(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first2, clean;
    var clipStream = {
      point: point2,
      lineStart,
      lineEnd,
      polygonStart,
      polygonEnd
    };
    function point2(x3, y3) {
      if (visible(x3, y3))
        activeStream.point(x3, y3);
    }
    function polygonInside() {
      var winding = 0;
      for (var i3 = 0, n2 = polygon.length; i3 < n2; ++i3) {
        for (var ring2 = polygon[i3], j3 = 1, m3 = ring2.length, point3 = ring2[0], a0, a1, b0 = point3[0], b1 = point3[1]; j3 < m3; ++j3) {
          a0 = b0, a1 = b1, point3 = ring2[j3], b0 = point3[0], b1 = point3[1];
          if (a1 <= y12) {
            if (b1 > y12 && (b0 - a0) * (y12 - a1) > (b1 - a1) * (x05 - a0))
              ++winding;
          } else {
            if (b1 <= y12 && (b0 - a0) * (y12 - a1) < (b1 - a1) * (x05 - a0))
              --winding;
          }
        }
      }
      return winding;
    }
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }
    function polygonEnd() {
      var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = merge(segments)).length;
      if (cleanInside || visible2) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible2) {
          rejoin_default(segments, compareIntersection2, startInside, interpolate, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }
    function lineStart() {
      clipStream.point = linePoint;
      if (polygon)
        polygon.push(ring = []);
      first2 = true;
      v_ = false;
      x_ = y_ = NaN;
    }
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_)
          bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point2;
      if (v_)
        activeStream.lineEnd();
    }
    function linePoint(x3, y3) {
      var v3 = visible(x3, y3);
      if (polygon)
        ring.push([x3, y3]);
      if (first2) {
        x__ = x3, y__ = y3, v__ = v3;
        first2 = false;
        if (v3) {
          activeStream.lineStart();
          activeStream.point(x3, y3);
        }
      } else {
        if (v3 && v_)
          activeStream.point(x3, y3);
        else {
          var a4 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b3 = [x3 = Math.max(clipMin, Math.min(clipMax, x3)), y3 = Math.max(clipMin, Math.min(clipMax, y3))];
          if (line_default(a4, b3, x05, y05, x12, y12)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a4[0], a4[1]);
            }
            activeStream.point(b3[0], b3[1]);
            if (!v3)
              activeStream.lineEnd();
            clean = false;
          } else if (v3) {
            activeStream.lineStart();
            activeStream.point(x3, y3);
            clean = false;
          }
        }
      }
      x_ = x3, y_ = y3, v_ = v3;
    }
    return clipStream;
  };
}

// node_modules/d3-geo/src/identity.js
var identity_default3 = (x3) => x3;

// node_modules/d3-geo/src/path/area.js
var areaSum = new Adder();
var areaRingSum = new Adder();
var x00;
var y00;
var x0;
var y0;
var areaStream = {
  point: noop2,
  lineStart: noop2,
  lineEnd: noop2,
  polygonStart: function() {
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    areaStream.lineStart = areaStream.lineEnd = areaStream.point = noop2;
    areaSum.add(abs2(areaRingSum));
    areaRingSum = new Adder();
  },
  result: function() {
    var area = areaSum / 2;
    areaSum = new Adder();
    return area;
  }
};
function areaRingStart() {
  areaStream.point = areaPointFirst;
}
function areaPointFirst(x3, y3) {
  areaStream.point = areaPoint;
  x00 = x0 = x3, y00 = y0 = y3;
}
function areaPoint(x3, y3) {
  areaRingSum.add(y0 * x3 - x0 * y3);
  x0 = x3, y0 = y3;
}
function areaRingEnd() {
  areaPoint(x00, y00);
}
var area_default = areaStream;

// node_modules/d3-geo/src/path/bounds.js
var x02 = Infinity;
var y02 = x02;
var x1 = -x02;
var y1 = x1;
var boundsStream = {
  point: boundsPoint,
  lineStart: noop2,
  lineEnd: noop2,
  polygonStart: noop2,
  polygonEnd: noop2,
  result: function() {
    var bounds = [[x02, y02], [x1, y1]];
    x1 = y1 = -(y02 = x02 = Infinity);
    return bounds;
  }
};
function boundsPoint(x3, y3) {
  if (x3 < x02)
    x02 = x3;
  if (x3 > x1)
    x1 = x3;
  if (y3 < y02)
    y02 = y3;
  if (y3 > y1)
    y1 = y3;
}
var bounds_default = boundsStream;

// node_modules/d3-geo/src/path/centroid.js
var X0 = 0;
var Y0 = 0;
var Z0 = 0;
var X1 = 0;
var Y1 = 0;
var Z1 = 0;
var X2 = 0;
var Y2 = 0;
var Z2 = 0;
var x002;
var y002;
var x03;
var y03;
var centroidStream = {
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.point = centroidPoint;
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  },
  result: function() {
    var centroid = Z2 ? [X2 / Z2, Y2 / Z2] : Z1 ? [X1 / Z1, Y1 / Z1] : Z0 ? [X0 / Z0, Y0 / Z0] : [NaN, NaN];
    X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
    return centroid;
  }
};
function centroidPoint(x3, y3) {
  X0 += x3;
  Y0 += y3;
  ++Z0;
}
function centroidLineStart() {
  centroidStream.point = centroidPointFirstLine;
}
function centroidPointFirstLine(x3, y3) {
  centroidStream.point = centroidPointLine;
  centroidPoint(x03 = x3, y03 = y3);
}
function centroidPointLine(x3, y3) {
  var dx = x3 - x03, dy = y3 - y03, z3 = sqrt(dx * dx + dy * dy);
  X1 += z3 * (x03 + x3) / 2;
  Y1 += z3 * (y03 + y3) / 2;
  Z1 += z3;
  centroidPoint(x03 = x3, y03 = y3);
}
function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}
function centroidRingStart() {
  centroidStream.point = centroidPointFirstRing;
}
function centroidRingEnd() {
  centroidPointRing(x002, y002);
}
function centroidPointFirstRing(x3, y3) {
  centroidStream.point = centroidPointRing;
  centroidPoint(x002 = x03 = x3, y002 = y03 = y3);
}
function centroidPointRing(x3, y3) {
  var dx = x3 - x03, dy = y3 - y03, z3 = sqrt(dx * dx + dy * dy);
  X1 += z3 * (x03 + x3) / 2;
  Y1 += z3 * (y03 + y3) / 2;
  Z1 += z3;
  z3 = y03 * x3 - x03 * y3;
  X2 += z3 * (x03 + x3);
  Y2 += z3 * (y03 + y3);
  Z2 += z3 * 3;
  centroidPoint(x03 = x3, y03 = y3);
}
var centroid_default = centroidStream;

// node_modules/d3-geo/src/path/context.js
function PathContext(context) {
  this._context = context;
}
PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_2) {
    return this._radius = _2, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0)
      this._context.closePath();
    this._point = NaN;
  },
  point: function(x3, y3) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x3, y3);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x3, y3);
        break;
      }
      default: {
        this._context.moveTo(x3 + this._radius, y3);
        this._context.arc(x3, y3, this._radius, 0, tau2);
        break;
      }
    }
  },
  result: noop2
};

// node_modules/d3-geo/src/path/measure.js
var lengthSum = new Adder();
var lengthRing;
var x003;
var y003;
var x04;
var y04;
var lengthStream = {
  point: noop2,
  lineStart: function() {
    lengthStream.point = lengthPointFirst;
  },
  lineEnd: function() {
    if (lengthRing)
      lengthPoint(x003, y003);
    lengthStream.point = noop2;
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length3 = +lengthSum;
    lengthSum = new Adder();
    return length3;
  }
};
function lengthPointFirst(x3, y3) {
  lengthStream.point = lengthPoint;
  x003 = x04 = x3, y003 = y04 = y3;
}
function lengthPoint(x3, y3) {
  x04 -= x3, y04 -= y3;
  lengthSum.add(sqrt(x04 * x04 + y04 * y04));
  x04 = x3, y04 = y3;
}
var measure_default = lengthStream;

// node_modules/d3-geo/src/path/string.js
var cacheDigits;
var cacheAppend;
var cacheRadius;
var cacheCircle;
var PathString = class {
  constructor(digits) {
    this._append = digits == null ? append2 : appendRound2(digits);
    this._radius = 4.5;
    this._ = "";
  }
  pointRadius(_2) {
    this._radius = +_2;
    return this;
  }
  polygonStart() {
    this._line = 0;
  }
  polygonEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line === 0)
      this._ += "Z";
    this._point = NaN;
  }
  point(x3, y3) {
    switch (this._point) {
      case 0: {
        this._append`M${x3},${y3}`;
        this._point = 1;
        break;
      }
      case 1: {
        this._append`L${x3},${y3}`;
        break;
      }
      default: {
        this._append`M${x3},${y3}`;
        if (this._radius !== cacheRadius || this._append !== cacheAppend) {
          const r3 = this._radius;
          const s4 = this._;
          this._ = "";
          this._append`m0,${r3}a${r3},${r3} 0 1,1 0,${-2 * r3}a${r3},${r3} 0 1,1 0,${2 * r3}z`;
          cacheRadius = r3;
          cacheAppend = this._append;
          cacheCircle = this._;
          this._ = s4;
        }
        this._ += cacheCircle;
        break;
      }
    }
  }
  result() {
    const result = this._;
    this._ = "";
    return result.length ? result : null;
  }
};
function append2(strings) {
  let i3 = 1;
  this._ += strings[0];
  for (const j3 = strings.length; i3 < j3; ++i3) {
    this._ += arguments[i3] + strings[i3];
  }
}
function appendRound2(digits) {
  const d3 = Math.floor(digits);
  if (!(d3 >= 0))
    throw new RangeError(`invalid digits: ${digits}`);
  if (d3 > 15)
    return append2;
  if (d3 !== cacheDigits) {
    const k4 = 10 ** d3;
    cacheDigits = d3;
    cacheAppend = function append3(strings) {
      let i3 = 1;
      this._ += strings[0];
      for (const j3 = strings.length; i3 < j3; ++i3) {
        this._ += Math.round(arguments[i3] * k4) / k4 + strings[i3];
      }
    };
  }
  return cacheAppend;
}

// node_modules/d3-geo/src/path/index.js
function path_default(projection3, context) {
  let digits = 3, pointRadius = 4.5, projectionStream, contextStream;
  function path2(object) {
    if (object) {
      if (typeof pointRadius === "function")
        contextStream.pointRadius(+pointRadius.apply(this, arguments));
      stream_default(object, projectionStream(contextStream));
    }
    return contextStream.result();
  }
  path2.area = function(object) {
    stream_default(object, projectionStream(area_default));
    return area_default.result();
  };
  path2.measure = function(object) {
    stream_default(object, projectionStream(measure_default));
    return measure_default.result();
  };
  path2.bounds = function(object) {
    stream_default(object, projectionStream(bounds_default));
    return bounds_default.result();
  };
  path2.centroid = function(object) {
    stream_default(object, projectionStream(centroid_default));
    return centroid_default.result();
  };
  path2.projection = function(_2) {
    if (!arguments.length)
      return projection3;
    projectionStream = _2 == null ? (projection3 = null, identity_default3) : (projection3 = _2).stream;
    return path2;
  };
  path2.context = function(_2) {
    if (!arguments.length)
      return context;
    contextStream = _2 == null ? (context = null, new PathString(digits)) : new PathContext(context = _2);
    if (typeof pointRadius !== "function")
      contextStream.pointRadius(pointRadius);
    return path2;
  };
  path2.pointRadius = function(_2) {
    if (!arguments.length)
      return pointRadius;
    pointRadius = typeof _2 === "function" ? _2 : (contextStream.pointRadius(+_2), +_2);
    return path2;
  };
  path2.digits = function(_2) {
    if (!arguments.length)
      return digits;
    if (_2 == null)
      digits = null;
    else {
      const d3 = Math.floor(_2);
      if (!(d3 >= 0))
        throw new RangeError(`invalid digits: ${_2}`);
      digits = d3;
    }
    if (context === null)
      contextStream = new PathString(digits);
    return path2;
  };
  return path2.projection(projection3).digits(digits).context(context);
}

// node_modules/d3-geo/src/transform.js
function transform_default(methods) {
  return {
    stream: transformer(methods)
  };
}
function transformer(methods) {
  return function(stream) {
    var s4 = new TransformStream();
    for (var key in methods)
      s4[key] = methods[key];
    s4.stream = stream;
    return s4;
  };
}
function TransformStream() {
}
TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x3, y3) {
    this.stream.point(x3, y3);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};

// node_modules/d3-geo/src/projection/fit.js
function fit(projection3, fitBounds, object) {
  var clip = projection3.clipExtent && projection3.clipExtent();
  projection3.scale(150).translate([0, 0]);
  if (clip != null)
    projection3.clipExtent(null);
  stream_default(object, projection3.stream(bounds_default));
  fitBounds(bounds_default.result());
  if (clip != null)
    projection3.clipExtent(clip);
  return projection3;
}
function fitExtent(projection3, extent2, object) {
  return fit(projection3, function(b3) {
    var w3 = extent2[1][0] - extent2[0][0], h3 = extent2[1][1] - extent2[0][1], k4 = Math.min(w3 / (b3[1][0] - b3[0][0]), h3 / (b3[1][1] - b3[0][1])), x3 = +extent2[0][0] + (w3 - k4 * (b3[1][0] + b3[0][0])) / 2, y3 = +extent2[0][1] + (h3 - k4 * (b3[1][1] + b3[0][1])) / 2;
    projection3.scale(150 * k4).translate([x3, y3]);
  }, object);
}
function fitSize(projection3, size, object) {
  return fitExtent(projection3, [[0, 0], size], object);
}
function fitWidth(projection3, width, object) {
  return fit(projection3, function(b3) {
    var w3 = +width, k4 = w3 / (b3[1][0] - b3[0][0]), x3 = (w3 - k4 * (b3[1][0] + b3[0][0])) / 2, y3 = -k4 * b3[0][1];
    projection3.scale(150 * k4).translate([x3, y3]);
  }, object);
}
function fitHeight(projection3, height, object) {
  return fit(projection3, function(b3) {
    var h3 = +height, k4 = h3 / (b3[1][1] - b3[0][1]), x3 = -k4 * b3[0][0], y3 = (h3 - k4 * (b3[1][1] + b3[0][1])) / 2;
    projection3.scale(150 * k4).translate([x3, y3]);
  }, object);
}

// node_modules/d3-geo/src/projection/resample.js
var maxDepth = 16;
var cosMinDistance = cos(30 * radians2);
function resample_default(project2, delta2) {
  return +delta2 ? resample(project2, delta2) : resampleNone(project2);
}
function resampleNone(project2) {
  return transformer({
    point: function(x3, y3) {
      x3 = project2(x3, y3);
      this.stream.point(x3[0], x3[1]);
    }
  });
}
function resample(project2, delta2) {
  function resampleLineTo(x05, y05, lambda0, a0, b0, c0, x12, y12, lambda1, a1, b1, c1, depth, stream) {
    var dx = x12 - x05, dy = y12 - y05, d22 = dx * dx + dy * dy;
    if (d22 > 4 * delta2 && depth--) {
      var a4 = a0 + a1, b3 = b0 + b1, c6 = c0 + c1, m3 = sqrt(a4 * a4 + b3 * b3 + c6 * c6), phi2 = asin(c6 /= m3), lambda2 = abs2(abs2(c6) - 1) < epsilon3 || abs2(lambda0 - lambda1) < epsilon3 ? (lambda0 + lambda1) / 2 : atan2(b3, a4), p3 = project2(lambda2, phi2), x22 = p3[0], y22 = p3[1], dx2 = x22 - x05, dy2 = y22 - y05, dz = dy * dx2 - dx * dy2;
      if (dz * dz / d22 > delta2 || abs2((dx * dx2 + dy * dy2) / d22 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
        resampleLineTo(x05, y05, lambda0, a0, b0, c0, x22, y22, lambda2, a4 /= m3, b3 /= m3, c6, depth, stream);
        stream.point(x22, y22);
        resampleLineTo(x22, y22, lambda2, a4, b3, c6, x12, y12, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda00, x004, y004, a00, b00, c00, lambda0, x05, y05, a0, b0, c0;
    var resampleStream = {
      point: point2,
      lineStart,
      lineEnd,
      polygonStart: function() {
        stream.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function() {
        stream.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };
    function point2(x3, y3) {
      x3 = project2(x3, y3);
      stream.point(x3[0], x3[1]);
    }
    function lineStart() {
      x05 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }
    function linePoint(lambda, phi) {
      var c6 = cartesian([lambda, phi]), p3 = project2(lambda, phi);
      resampleLineTo(x05, y05, lambda0, a0, b0, c0, x05 = p3[0], y05 = p3[1], lambda0 = lambda, a0 = c6[0], b0 = c6[1], c0 = c6[2], maxDepth, stream);
      stream.point(x05, y05);
    }
    function lineEnd() {
      resampleStream.point = point2;
      stream.lineEnd();
    }
    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }
    function ringPoint(lambda, phi) {
      linePoint(lambda00 = lambda, phi), x004 = x05, y004 = y05, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }
    function ringEnd() {
      resampleLineTo(x05, y05, lambda0, a0, b0, c0, x004, y004, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }
    return resampleStream;
  };
}

// node_modules/d3-geo/src/projection/index.js
var transformRadians = transformer({
  point: function(x3, y3) {
    this.stream.point(x3 * radians2, y3 * radians2);
  }
});
function transformRotate(rotate) {
  return transformer({
    point: function(x3, y3) {
      var r3 = rotate(x3, y3);
      return this.stream.point(r3[0], r3[1]);
    }
  });
}
function scaleTranslate(k4, dx, dy, sx, sy) {
  function transform2(x3, y3) {
    x3 *= sx;
    y3 *= sy;
    return [dx + k4 * x3, dy - k4 * y3];
  }
  transform2.invert = function(x3, y3) {
    return [(x3 - dx) / k4 * sx, (dy - y3) / k4 * sy];
  };
  return transform2;
}
function scaleTranslateRotate(k4, dx, dy, sx, sy, alpha) {
  if (!alpha)
    return scaleTranslate(k4, dx, dy, sx, sy);
  var cosAlpha = cos(alpha), sinAlpha = sin(alpha), a4 = cosAlpha * k4, b3 = sinAlpha * k4, ai = cosAlpha / k4, bi = sinAlpha / k4, ci = (sinAlpha * dy - cosAlpha * dx) / k4, fi = (sinAlpha * dx + cosAlpha * dy) / k4;
  function transform2(x3, y3) {
    x3 *= sx;
    y3 *= sy;
    return [a4 * x3 - b3 * y3 + dx, dy - b3 * x3 - a4 * y3];
  }
  transform2.invert = function(x3, y3) {
    return [sx * (ai * x3 - bi * y3 + ci), sy * (fi - bi * x3 - ai * y3)];
  };
  return transform2;
}
function projection(project2) {
  return projectionMutator(function() {
    return project2;
  })();
}
function projectionMutator(projectAt) {
  var project2, k4 = 150, x3 = 480, y3 = 250, lambda = 0, phi = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, alpha = 0, sx = 1, sy = 1, theta = null, preclip = antimeridian_default, x05 = null, y05, x12, y12, postclip = identity_default3, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache, cacheStream;
  function projection3(point2) {
    return projectRotateTransform(point2[0] * radians2, point2[1] * radians2);
  }
  function invert(point2) {
    point2 = projectRotateTransform.invert(point2[0], point2[1]);
    return point2 && [point2[0] * degrees3, point2[1] * degrees3];
  }
  projection3.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
  };
  projection3.preclip = function(_2) {
    return arguments.length ? (preclip = _2, theta = void 0, reset()) : preclip;
  };
  projection3.postclip = function(_2) {
    return arguments.length ? (postclip = _2, x05 = y05 = x12 = y12 = null, reset()) : postclip;
  };
  projection3.clipAngle = function(_2) {
    return arguments.length ? (preclip = +_2 ? circle_default(theta = _2 * radians2) : (theta = null, antimeridian_default), reset()) : theta * degrees3;
  };
  projection3.clipExtent = function(_2) {
    return arguments.length ? (postclip = _2 == null ? (x05 = y05 = x12 = y12 = null, identity_default3) : clipRectangle(x05 = +_2[0][0], y05 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reset()) : x05 == null ? null : [[x05, y05], [x12, y12]];
  };
  projection3.scale = function(_2) {
    return arguments.length ? (k4 = +_2, recenter()) : k4;
  };
  projection3.translate = function(_2) {
    return arguments.length ? (x3 = +_2[0], y3 = +_2[1], recenter()) : [x3, y3];
  };
  projection3.center = function(_2) {
    return arguments.length ? (lambda = _2[0] % 360 * radians2, phi = _2[1] % 360 * radians2, recenter()) : [lambda * degrees3, phi * degrees3];
  };
  projection3.rotate = function(_2) {
    return arguments.length ? (deltaLambda = _2[0] % 360 * radians2, deltaPhi = _2[1] % 360 * radians2, deltaGamma = _2.length > 2 ? _2[2] % 360 * radians2 : 0, recenter()) : [deltaLambda * degrees3, deltaPhi * degrees3, deltaGamma * degrees3];
  };
  projection3.angle = function(_2) {
    return arguments.length ? (alpha = _2 % 360 * radians2, recenter()) : alpha * degrees3;
  };
  projection3.reflectX = function(_2) {
    return arguments.length ? (sx = _2 ? -1 : 1, recenter()) : sx < 0;
  };
  projection3.reflectY = function(_2) {
    return arguments.length ? (sy = _2 ? -1 : 1, recenter()) : sy < 0;
  };
  projection3.precision = function(_2) {
    return arguments.length ? (projectResample = resample_default(projectTransform, delta2 = _2 * _2), reset()) : sqrt(delta2);
  };
  projection3.fitExtent = function(extent2, object) {
    return fitExtent(projection3, extent2, object);
  };
  projection3.fitSize = function(size, object) {
    return fitSize(projection3, size, object);
  };
  projection3.fitWidth = function(width, object) {
    return fitWidth(projection3, width, object);
  };
  projection3.fitHeight = function(height, object) {
    return fitHeight(projection3, height, object);
  };
  function recenter() {
    var center2 = scaleTranslateRotate(k4, 0, 0, sx, sy, alpha).apply(null, project2(lambda, phi)), transform2 = scaleTranslateRotate(k4, x3 - center2[0], y3 - center2[1], sx, sy, alpha);
    rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = compose_default(project2, transform2);
    projectRotateTransform = compose_default(rotate, projectTransform);
    projectResample = resample_default(projectTransform, delta2);
    return reset();
  }
  function reset() {
    cache = cacheStream = null;
    return projection3;
  }
  return function() {
    project2 = projectAt.apply(this, arguments);
    projection3.invert = project2.invert && invert;
    return recenter();
  };
}

// node_modules/d3-geo/src/projection/conic.js
function conicProjection(projectAt) {
  var phi0 = 0, phi1 = pi2 / 3, m3 = projectionMutator(projectAt), p3 = m3(phi0, phi1);
  p3.parallels = function(_2) {
    return arguments.length ? m3(phi0 = _2[0] * radians2, phi1 = _2[1] * radians2) : [phi0 * degrees3, phi1 * degrees3];
  };
  return p3;
}

// node_modules/d3-geo/src/projection/cylindricalEqualArea.js
function cylindricalEqualAreaRaw(phi0) {
  var cosPhi0 = cos(phi0);
  function forward(lambda, phi) {
    return [lambda * cosPhi0, sin(phi) / cosPhi0];
  }
  forward.invert = function(x3, y3) {
    return [x3 / cosPhi0, asin(y3 * cosPhi0)];
  };
  return forward;
}

// node_modules/d3-geo/src/projection/conicEqualArea.js
function conicEqualAreaRaw(y05, y12) {
  var sy0 = sin(y05), n2 = (sy0 + sin(y12)) / 2;
  if (abs2(n2) < epsilon3)
    return cylindricalEqualAreaRaw(y05);
  var c6 = 1 + sy0 * (2 * n2 - sy0), r0 = sqrt(c6) / n2;
  function project2(x3, y3) {
    var r3 = sqrt(c6 - 2 * n2 * sin(y3)) / n2;
    return [r3 * sin(x3 *= n2), r0 - r3 * cos(x3)];
  }
  project2.invert = function(x3, y3) {
    var r0y = r0 - y3, l3 = atan2(x3, abs2(r0y)) * sign(r0y);
    if (r0y * n2 < 0)
      l3 -= pi2 * sign(x3) * sign(r0y);
    return [l3 / n2, asin((c6 - (x3 * x3 + r0y * r0y) * n2 * n2) / (2 * n2))];
  };
  return project2;
}
function conicEqualArea_default() {
  return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
}

// node_modules/d3-geo/src/projection/albers.js
function albers_default() {
  return conicEqualArea_default().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}

// node_modules/d3-geo/src/projection/albersUsa.js
function multiplex(streams) {
  var n2 = streams.length;
  return {
    point: function(x3, y3) {
      var i3 = -1;
      while (++i3 < n2)
        streams[i3].point(x3, y3);
    },
    sphere: function() {
      var i3 = -1;
      while (++i3 < n2)
        streams[i3].sphere();
    },
    lineStart: function() {
      var i3 = -1;
      while (++i3 < n2)
        streams[i3].lineStart();
    },
    lineEnd: function() {
      var i3 = -1;
      while (++i3 < n2)
        streams[i3].lineEnd();
    },
    polygonStart: function() {
      var i3 = -1;
      while (++i3 < n2)
        streams[i3].polygonStart();
    },
    polygonEnd: function() {
      var i3 = -1;
      while (++i3 < n2)
        streams[i3].polygonEnd();
    }
  };
}
function albersUsa_default() {
  var cache, cacheStream, lower48 = albers_default(), lower48Point, alaska = conicEqualArea_default().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea_default().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point2, pointStream = { point: function(x3, y3) {
    point2 = [x3, y3];
  } };
  function albersUsa(coordinates) {
    var x3 = coordinates[0], y3 = coordinates[1];
    return point2 = null, (lower48Point.point(x3, y3), point2) || (alaskaPoint.point(x3, y3), point2) || (hawaiiPoint.point(x3, y3), point2);
  }
  albersUsa.invert = function(coordinates) {
    var k4 = lower48.scale(), t4 = lower48.translate(), x3 = (coordinates[0] - t4[0]) / k4, y3 = (coordinates[1] - t4[1]) / k4;
    return (y3 >= 0.12 && y3 < 0.234 && x3 >= -0.425 && x3 < -0.214 ? alaska : y3 >= 0.166 && y3 < 0.234 && x3 >= -0.214 && x3 < -0.115 ? hawaii : lower48).invert(coordinates);
  };
  albersUsa.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };
  albersUsa.precision = function(_2) {
    if (!arguments.length)
      return lower48.precision();
    lower48.precision(_2), alaska.precision(_2), hawaii.precision(_2);
    return reset();
  };
  albersUsa.scale = function(_2) {
    if (!arguments.length)
      return lower48.scale();
    lower48.scale(_2), alaska.scale(_2 * 0.35), hawaii.scale(_2);
    return albersUsa.translate(lower48.translate());
  };
  albersUsa.translate = function(_2) {
    if (!arguments.length)
      return lower48.translate();
    var k4 = lower48.scale(), x3 = +_2[0], y3 = +_2[1];
    lower48Point = lower48.translate(_2).clipExtent([[x3 - 0.455 * k4, y3 - 0.238 * k4], [x3 + 0.455 * k4, y3 + 0.238 * k4]]).stream(pointStream);
    alaskaPoint = alaska.translate([x3 - 0.307 * k4, y3 + 0.201 * k4]).clipExtent([[x3 - 0.425 * k4 + epsilon3, y3 + 0.12 * k4 + epsilon3], [x3 - 0.214 * k4 - epsilon3, y3 + 0.234 * k4 - epsilon3]]).stream(pointStream);
    hawaiiPoint = hawaii.translate([x3 - 0.205 * k4, y3 + 0.212 * k4]).clipExtent([[x3 - 0.214 * k4 + epsilon3, y3 + 0.166 * k4 + epsilon3], [x3 - 0.115 * k4 - epsilon3, y3 + 0.234 * k4 - epsilon3]]).stream(pointStream);
    return reset();
  };
  albersUsa.fitExtent = function(extent2, object) {
    return fitExtent(albersUsa, extent2, object);
  };
  albersUsa.fitSize = function(size, object) {
    return fitSize(albersUsa, size, object);
  };
  albersUsa.fitWidth = function(width, object) {
    return fitWidth(albersUsa, width, object);
  };
  albersUsa.fitHeight = function(height, object) {
    return fitHeight(albersUsa, height, object);
  };
  function reset() {
    cache = cacheStream = null;
    return albersUsa;
  }
  return albersUsa.scale(1070);
}

// node_modules/d3-geo/src/projection/azimuthal.js
function azimuthalRaw(scale) {
  return function(x3, y3) {
    var cx = cos(x3), cy = cos(y3), k4 = scale(cx * cy);
    if (k4 === Infinity)
      return [2, 0];
    return [
      k4 * cy * sin(x3),
      k4 * sin(y3)
    ];
  };
}
function azimuthalInvert(angle) {
  return function(x3, y3) {
    var z3 = sqrt(x3 * x3 + y3 * y3), c6 = angle(z3), sc = sin(c6), cc = cos(c6);
    return [
      atan2(x3 * sc, z3 * cc),
      asin(z3 && y3 * sc / z3)
    ];
  };
}

// node_modules/d3-geo/src/projection/azimuthalEqualArea.js
var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt(2 / (1 + cxcy));
});
azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z3) {
  return 2 * asin(z3 / 2);
});
function azimuthalEqualArea_default() {
  return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
}

// node_modules/d3-geo/src/projection/azimuthalEquidistant.js
var azimuthalEquidistantRaw = azimuthalRaw(function(c6) {
  return (c6 = acos(c6)) && c6 / sin(c6);
});
azimuthalEquidistantRaw.invert = azimuthalInvert(function(z3) {
  return z3;
});
function azimuthalEquidistant_default() {
  return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
}

// node_modules/d3-geo/src/projection/mercator.js
function mercatorRaw(lambda, phi) {
  return [lambda, log(tan((halfPi + phi) / 2))];
}
mercatorRaw.invert = function(x3, y3) {
  return [x3, 2 * atan(exp(y3)) - halfPi];
};
function mercator_default() {
  return mercatorProjection(mercatorRaw).scale(961 / tau2);
}
function mercatorProjection(project2) {
  var m3 = projection(project2), center2 = m3.center, scale = m3.scale, translate = m3.translate, clipExtent = m3.clipExtent, x05 = null, y05, x12, y12;
  m3.scale = function(_2) {
    return arguments.length ? (scale(_2), reclip()) : scale();
  };
  m3.translate = function(_2) {
    return arguments.length ? (translate(_2), reclip()) : translate();
  };
  m3.center = function(_2) {
    return arguments.length ? (center2(_2), reclip()) : center2();
  };
  m3.clipExtent = function(_2) {
    return arguments.length ? (_2 == null ? x05 = y05 = x12 = y12 = null : (x05 = +_2[0][0], y05 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reclip()) : x05 == null ? null : [[x05, y05], [x12, y12]];
  };
  function reclip() {
    var k4 = pi2 * scale(), t4 = m3(rotation_default(m3.rotate()).invert([0, 0]));
    return clipExtent(x05 == null ? [[t4[0] - k4, t4[1] - k4], [t4[0] + k4, t4[1] + k4]] : project2 === mercatorRaw ? [[Math.max(t4[0] - k4, x05), y05], [Math.min(t4[0] + k4, x12), y12]] : [[x05, Math.max(t4[1] - k4, y05)], [x12, Math.min(t4[1] + k4, y12)]]);
  }
  return reclip();
}

// node_modules/d3-geo/src/projection/conicConformal.js
function tany(y3) {
  return tan((halfPi + y3) / 2);
}
function conicConformalRaw(y05, y12) {
  var cy0 = cos(y05), n2 = y05 === y12 ? sin(y05) : log(cy0 / cos(y12)) / log(tany(y12) / tany(y05)), f3 = cy0 * pow(tany(y05), n2) / n2;
  if (!n2)
    return mercatorRaw;
  function project2(x3, y3) {
    if (f3 > 0) {
      if (y3 < -halfPi + epsilon3)
        y3 = -halfPi + epsilon3;
    } else {
      if (y3 > halfPi - epsilon3)
        y3 = halfPi - epsilon3;
    }
    var r3 = f3 / pow(tany(y3), n2);
    return [r3 * sin(n2 * x3), f3 - r3 * cos(n2 * x3)];
  }
  project2.invert = function(x3, y3) {
    var fy = f3 - y3, r3 = sign(n2) * sqrt(x3 * x3 + fy * fy), l3 = atan2(x3, abs2(fy)) * sign(fy);
    if (fy * n2 < 0)
      l3 -= pi2 * sign(x3) * sign(fy);
    return [l3 / n2, 2 * atan(pow(f3 / r3, 1 / n2)) - halfPi];
  };
  return project2;
}
function conicConformal_default() {
  return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
}

// node_modules/d3-geo/src/projection/equirectangular.js
function equirectangularRaw(lambda, phi) {
  return [lambda, phi];
}
equirectangularRaw.invert = equirectangularRaw;
function equirectangular_default() {
  return projection(equirectangularRaw).scale(152.63);
}

// node_modules/d3-geo/src/projection/conicEquidistant.js
function conicEquidistantRaw(y05, y12) {
  var cy0 = cos(y05), n2 = y05 === y12 ? sin(y05) : (cy0 - cos(y12)) / (y12 - y05), g3 = cy0 / n2 + y05;
  if (abs2(n2) < epsilon3)
    return equirectangularRaw;
  function project2(x3, y3) {
    var gy = g3 - y3, nx = n2 * x3;
    return [gy * sin(nx), g3 - gy * cos(nx)];
  }
  project2.invert = function(x3, y3) {
    var gy = g3 - y3, l3 = atan2(x3, abs2(gy)) * sign(gy);
    if (gy * n2 < 0)
      l3 -= pi2 * sign(x3) * sign(gy);
    return [l3 / n2, g3 - sign(n2) * sqrt(x3 * x3 + gy * gy)];
  };
  return project2;
}
function conicEquidistant_default() {
  return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
}

// node_modules/d3-geo/src/projection/equalEarth.js
var A1 = 1.340264;
var A22 = -0.081106;
var A3 = 893e-6;
var A4 = 3796e-6;
var M2 = sqrt(3) / 2;
var iterations = 12;
function equalEarthRaw(lambda, phi) {
  var l3 = asin(M2 * sin(phi)), l22 = l3 * l3, l6 = l22 * l22 * l22;
  return [
    lambda * cos(l3) / (M2 * (A1 + 3 * A22 * l22 + l6 * (7 * A3 + 9 * A4 * l22))),
    l3 * (A1 + A22 * l22 + l6 * (A3 + A4 * l22))
  ];
}
equalEarthRaw.invert = function(x3, y3) {
  var l3 = y3, l22 = l3 * l3, l6 = l22 * l22 * l22;
  for (var i3 = 0, delta, fy, fpy; i3 < iterations; ++i3) {
    fy = l3 * (A1 + A22 * l22 + l6 * (A3 + A4 * l22)) - y3;
    fpy = A1 + 3 * A22 * l22 + l6 * (7 * A3 + 9 * A4 * l22);
    l3 -= delta = fy / fpy, l22 = l3 * l3, l6 = l22 * l22 * l22;
    if (abs2(delta) < epsilon22)
      break;
  }
  return [
    M2 * x3 * (A1 + 3 * A22 * l22 + l6 * (7 * A3 + 9 * A4 * l22)) / cos(l3),
    asin(sin(l3) / M2)
  ];
};
function equalEarth_default() {
  return projection(equalEarthRaw).scale(177.158);
}

// node_modules/d3-geo/src/projection/gnomonic.js
function gnomonicRaw(x3, y3) {
  var cy = cos(y3), k4 = cos(x3) * cy;
  return [cy * sin(x3) / k4, sin(y3) / k4];
}
gnomonicRaw.invert = azimuthalInvert(atan);
function gnomonic_default() {
  return projection(gnomonicRaw).scale(144.049).clipAngle(60);
}

// node_modules/d3-geo/src/projection/orthographic.js
function orthographicRaw(x3, y3) {
  return [cos(y3) * sin(x3), sin(y3)];
}
orthographicRaw.invert = azimuthalInvert(asin);
function orthographic_default() {
  return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon3);
}

// node_modules/d3-geo/src/projection/stereographic.js
function stereographicRaw(x3, y3) {
  var cy = cos(y3), k4 = 1 + cos(x3) * cy;
  return [cy * sin(x3) / k4, sin(y3) / k4];
}
stereographicRaw.invert = azimuthalInvert(function(z3) {
  return 2 * atan(z3);
});
function stereographic_default() {
  return projection(stereographicRaw).scale(250).clipAngle(142);
}

// node_modules/d3-geo/src/projection/transverseMercator.js
function transverseMercatorRaw(lambda, phi) {
  return [log(tan((halfPi + phi) / 2)), -lambda];
}
transverseMercatorRaw.invert = function(x3, y3) {
  return [-y3, 2 * atan(exp(x3)) - halfPi];
};
function transverseMercator_default() {
  var m3 = mercatorProjection(transverseMercatorRaw), center2 = m3.center, rotate = m3.rotate;
  m3.center = function(_2) {
    return arguments.length ? center2([-_2[1], _2[0]]) : (_2 = center2(), [_2[1], -_2[0]]);
  };
  m3.rotate = function(_2) {
    return arguments.length ? rotate([_2[0], _2[1], _2.length > 2 ? _2[2] + 90 : 90]) : (_2 = rotate(), [_2[0], _2[1], _2[2] - 90]);
  };
  return rotate([0, 0, 90]).scale(159.155);
}

// node_modules/d3-scale/src/init.js
function initRange(domain, range3) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range3).domain(domain);
      break;
  }
  return this;
}
function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      if (typeof domain === "function")
        this.interpolator(domain);
      else
        this.range(domain);
      break;
    }
    default: {
      this.domain(domain);
      if (typeof interpolator === "function")
        this.interpolator(interpolator);
      else
        this.range(interpolator);
      break;
    }
  }
  return this;
}

// node_modules/d3-scale/src/ordinal.js
var implicit = Symbol("implicit");
function ordinal() {
  var index2 = new InternMap(), domain = [], range3 = [], unknown = implicit;
  function scale(d3) {
    let i3 = index2.get(d3);
    if (i3 === void 0) {
      if (unknown !== implicit)
        return unknown;
      index2.set(d3, i3 = domain.push(d3) - 1);
    }
    return range3[i3 % range3.length];
  }
  scale.domain = function(_2) {
    if (!arguments.length)
      return domain.slice();
    domain = [], index2 = new InternMap();
    for (const value of _2) {
      if (index2.has(value))
        continue;
      index2.set(value, domain.push(value) - 1);
    }
    return scale;
  };
  scale.range = function(_2) {
    return arguments.length ? (range3 = Array.from(_2), scale) : range3.slice();
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  scale.copy = function() {
    return ordinal(domain, range3).unknown(unknown);
  };
  initRange.apply(scale, arguments);
  return scale;
}

// node_modules/d3-scale/src/band.js
function band() {
  var scale = ordinal().unknown(void 0), domain = scale.domain, ordinalRange2 = scale.range, r0 = 0, r1 = 1, step, bandwidth, round = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
  delete scale.unknown;
  function rescale() {
    var n2 = domain().length, reverse2 = r1 < r0, start2 = reverse2 ? r1 : r0, stop = reverse2 ? r0 : r1;
    step = (stop - start2) / Math.max(1, n2 - paddingInner + paddingOuter * 2);
    if (round)
      step = Math.floor(step);
    start2 += (stop - start2 - step * (n2 - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round)
      start2 = Math.round(start2), bandwidth = Math.round(bandwidth);
    var values2 = range(n2).map(function(i3) {
      return start2 + step * i3;
    });
    return ordinalRange2(reverse2 ? values2.reverse() : values2);
  }
  scale.domain = function(_2) {
    return arguments.length ? (domain(_2), rescale()) : domain();
  };
  scale.range = function(_2) {
    return arguments.length ? ([r0, r1] = _2, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };
  scale.rangeRound = function(_2) {
    return [r0, r1] = _2, r0 = +r0, r1 = +r1, round = true, rescale();
  };
  scale.bandwidth = function() {
    return bandwidth;
  };
  scale.step = function() {
    return step;
  };
  scale.round = function(_2) {
    return arguments.length ? (round = !!_2, rescale()) : round;
  };
  scale.padding = function(_2) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_2), rescale()) : paddingInner;
  };
  scale.paddingInner = function(_2) {
    return arguments.length ? (paddingInner = Math.min(1, _2), rescale()) : paddingInner;
  };
  scale.paddingOuter = function(_2) {
    return arguments.length ? (paddingOuter = +_2, rescale()) : paddingOuter;
  };
  scale.align = function(_2) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _2)), rescale()) : align;
  };
  scale.copy = function() {
    return band(domain(), [r0, r1]).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };
  return initRange.apply(rescale(), arguments);
}
function pointish(scale) {
  var copy3 = scale.copy;
  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;
  scale.copy = function() {
    return pointish(copy3());
  };
  return scale;
}
function point() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}

// node_modules/d3-scale/src/constant.js
function constants(x3) {
  return function() {
    return x3;
  };
}

// node_modules/d3-scale/src/number.js
function number3(x3) {
  return +x3;
}

// node_modules/d3-scale/src/continuous.js
var unit = [0, 1];
function identity3(x3) {
  return x3;
}
function normalize(a4, b3) {
  return (b3 -= a4 = +a4) ? function(x3) {
    return (x3 - a4) / b3;
  } : constants(isNaN(b3) ? NaN : 0.5);
}
function clamper(a4, b3) {
  var t4;
  if (a4 > b3)
    t4 = a4, a4 = b3, b3 = t4;
  return function(x3) {
    return Math.max(a4, Math.min(b3, x3));
  };
}
function bimap(domain, range3, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range3[0], r1 = range3[1];
  if (d1 < d0)
    d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else
    d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x3) {
    return r0(d0(x3));
  };
}
function polymap(domain, range3, interpolate) {
  var j3 = Math.min(domain.length, range3.length) - 1, d3 = new Array(j3), r3 = new Array(j3), i3 = -1;
  if (domain[j3] < domain[0]) {
    domain = domain.slice().reverse();
    range3 = range3.slice().reverse();
  }
  while (++i3 < j3) {
    d3[i3] = normalize(domain[i3], domain[i3 + 1]);
    r3[i3] = interpolate(range3[i3], range3[i3 + 1]);
  }
  return function(x3) {
    var i4 = bisect_default(domain, x3, 1, j3) - 1;
    return r3[i4](d3[i4](x3));
  };
}
function copy(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer2() {
  var domain = unit, range3 = unit, interpolate = value_default, transform2, untransform, unknown, clamp = identity3, piecewise2, output, input;
  function rescale() {
    var n2 = Math.min(domain.length, range3.length);
    if (clamp !== identity3)
      clamp = clamper(domain[0], domain[n2 - 1]);
    piecewise2 = n2 > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }
  function scale(x3) {
    return x3 == null || isNaN(x3 = +x3) ? unknown : (output || (output = piecewise2(domain.map(transform2), range3, interpolate)))(transform2(clamp(x3)));
  }
  scale.invert = function(y3) {
    return clamp(untransform((input || (input = piecewise2(range3, domain.map(transform2), number_default)))(y3)));
  };
  scale.domain = function(_2) {
    return arguments.length ? (domain = Array.from(_2, number3), rescale()) : domain.slice();
  };
  scale.range = function(_2) {
    return arguments.length ? (range3 = Array.from(_2), rescale()) : range3.slice();
  };
  scale.rangeRound = function(_2) {
    return range3 = Array.from(_2), interpolate = round_default, rescale();
  };
  scale.clamp = function(_2) {
    return arguments.length ? (clamp = _2 ? true : identity3, rescale()) : clamp !== identity3;
  };
  scale.interpolate = function(_2) {
    return arguments.length ? (interpolate = _2, rescale()) : interpolate;
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  return function(t4, u3) {
    transform2 = t4, untransform = u3;
    return rescale();
  };
}
function continuous() {
  return transformer2()(identity3, identity3);
}

// node_modules/d3-scale/src/tickFormat.js
function tickFormat(start2, stop, count2, specifier) {
  var step = tickStep(start2, stop, count2), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start2), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value)))
        specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start2), Math.abs(stop)))))
        specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step)))
        specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}

// node_modules/d3-scale/src/linear.js
function linearish(scale) {
  var domain = scale.domain;
  scale.ticks = function(count2) {
    var d3 = domain();
    return ticks(d3[0], d3[d3.length - 1], count2 == null ? 10 : count2);
  };
  scale.tickFormat = function(count2, specifier) {
    var d3 = domain();
    return tickFormat(d3[0], d3[d3.length - 1], count2 == null ? 10 : count2, specifier);
  };
  scale.nice = function(count2) {
    if (count2 == null)
      count2 = 10;
    var d3 = domain();
    var i0 = 0;
    var i1 = d3.length - 1;
    var start2 = d3[i0];
    var stop = d3[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start2) {
      step = start2, start2 = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start2, stop, count2);
      if (step === prestep) {
        d3[i0] = start2;
        d3[i1] = stop;
        return domain(d3);
      } else if (step > 0) {
        start2 = Math.floor(start2 / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start2 = Math.ceil(start2 * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale;
  };
  return scale;
}
function linear2() {
  var scale = continuous();
  scale.copy = function() {
    return copy(scale, linear2());
  };
  initRange.apply(scale, arguments);
  return linearish(scale);
}

// node_modules/d3-scale/src/identity.js
function identity4(domain) {
  var unknown;
  function scale(x3) {
    return x3 == null || isNaN(x3 = +x3) ? unknown : x3;
  }
  scale.invert = scale;
  scale.domain = scale.range = function(_2) {
    return arguments.length ? (domain = Array.from(_2, number3), scale) : domain.slice();
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  scale.copy = function() {
    return identity4(domain).unknown(unknown);
  };
  domain = arguments.length ? Array.from(domain, number3) : [0, 1];
  return linearish(scale);
}

// node_modules/d3-scale/src/nice.js
function nice(domain, interval2) {
  domain = domain.slice();
  var i0 = 0, i1 = domain.length - 1, x05 = domain[i0], x12 = domain[i1], t4;
  if (x12 < x05) {
    t4 = i0, i0 = i1, i1 = t4;
    t4 = x05, x05 = x12, x12 = t4;
  }
  domain[i0] = interval2.floor(x05);
  domain[i1] = interval2.ceil(x12);
  return domain;
}

// node_modules/d3-scale/src/log.js
function transformLog(x3) {
  return Math.log(x3);
}
function transformExp(x3) {
  return Math.exp(x3);
}
function transformLogn(x3) {
  return -Math.log(-x3);
}
function transformExpn(x3) {
  return -Math.exp(-x3);
}
function pow10(x3) {
  return isFinite(x3) ? +("1e" + x3) : x3 < 0 ? 0 : x3;
}
function powp(base) {
  return base === 10 ? pow10 : base === Math.E ? Math.exp : (x3) => Math.pow(base, x3);
}
function logp(base) {
  return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), (x3) => Math.log(x3) / base);
}
function reflect(f3) {
  return (x3, k4) => -f3(-x3, k4);
}
function loggish(transform2) {
  const scale = transform2(transformLog, transformExp);
  const domain = scale.domain;
  let base = 10;
  let logs;
  let pows;
  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform2(transformLogn, transformExpn);
    } else {
      transform2(transformLog, transformExp);
    }
    return scale;
  }
  scale.base = function(_2) {
    return arguments.length ? (base = +_2, rescale()) : base;
  };
  scale.domain = function(_2) {
    return arguments.length ? (domain(_2), rescale()) : domain();
  };
  scale.ticks = (count2) => {
    const d3 = domain();
    let u3 = d3[0];
    let v3 = d3[d3.length - 1];
    const r3 = v3 < u3;
    if (r3)
      [u3, v3] = [v3, u3];
    let i3 = logs(u3);
    let j3 = logs(v3);
    let k4;
    let t4;
    const n2 = count2 == null ? 10 : +count2;
    let z3 = [];
    if (!(base % 1) && j3 - i3 < n2) {
      i3 = Math.floor(i3), j3 = Math.ceil(j3);
      if (u3 > 0)
        for (; i3 <= j3; ++i3) {
          for (k4 = 1; k4 < base; ++k4) {
            t4 = i3 < 0 ? k4 / pows(-i3) : k4 * pows(i3);
            if (t4 < u3)
              continue;
            if (t4 > v3)
              break;
            z3.push(t4);
          }
        }
      else
        for (; i3 <= j3; ++i3) {
          for (k4 = base - 1; k4 >= 1; --k4) {
            t4 = i3 > 0 ? k4 / pows(-i3) : k4 * pows(i3);
            if (t4 < u3)
              continue;
            if (t4 > v3)
              break;
            z3.push(t4);
          }
        }
      if (z3.length * 2 < n2)
        z3 = ticks(u3, v3, n2);
    } else {
      z3 = ticks(i3, j3, Math.min(j3 - i3, n2)).map(pows);
    }
    return r3 ? z3.reverse() : z3;
  };
  scale.tickFormat = (count2, specifier) => {
    if (count2 == null)
      count2 = 10;
    if (specifier == null)
      specifier = base === 10 ? "s" : ",";
    if (typeof specifier !== "function") {
      if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null)
        specifier.trim = true;
      specifier = format(specifier);
    }
    if (count2 === Infinity)
      return specifier;
    const k4 = Math.max(1, base * count2 / scale.ticks().length);
    return (d3) => {
      let i3 = d3 / pows(Math.round(logs(d3)));
      if (i3 * base < base - 0.5)
        i3 *= base;
      return i3 <= k4 ? specifier(d3) : "";
    };
  };
  scale.nice = () => {
    return domain(nice(domain(), {
      floor: (x3) => pows(Math.floor(logs(x3))),
      ceil: (x3) => pows(Math.ceil(logs(x3)))
    }));
  };
  return scale;
}
function log2() {
  const scale = loggish(transformer2()).domain([1, 10]);
  scale.copy = () => copy(scale, log2()).base(scale.base());
  initRange.apply(scale, arguments);
  return scale;
}

// node_modules/d3-scale/src/symlog.js
function transformSymlog(c6) {
  return function(x3) {
    return Math.sign(x3) * Math.log1p(Math.abs(x3 / c6));
  };
}
function transformSymexp(c6) {
  return function(x3) {
    return Math.sign(x3) * Math.expm1(Math.abs(x3)) * c6;
  };
}
function symlogish(transform2) {
  var c6 = 1, scale = transform2(transformSymlog(c6), transformSymexp(c6));
  scale.constant = function(_2) {
    return arguments.length ? transform2(transformSymlog(c6 = +_2), transformSymexp(c6)) : c6;
  };
  return linearish(scale);
}
function symlog() {
  var scale = symlogish(transformer2());
  scale.copy = function() {
    return copy(scale, symlog()).constant(scale.constant());
  };
  return initRange.apply(scale, arguments);
}

// node_modules/d3-scale/src/pow.js
function transformPow(exponent) {
  return function(x3) {
    return x3 < 0 ? -Math.pow(-x3, exponent) : Math.pow(x3, exponent);
  };
}
function transformSqrt(x3) {
  return x3 < 0 ? -Math.sqrt(-x3) : Math.sqrt(x3);
}
function transformSquare(x3) {
  return x3 < 0 ? -x3 * x3 : x3 * x3;
}
function powish(transform2) {
  var scale = transform2(identity3, identity3), exponent = 1;
  function rescale() {
    return exponent === 1 ? transform2(identity3, identity3) : exponent === 0.5 ? transform2(transformSqrt, transformSquare) : transform2(transformPow(exponent), transformPow(1 / exponent));
  }
  scale.exponent = function(_2) {
    return arguments.length ? (exponent = +_2, rescale()) : exponent;
  };
  return linearish(scale);
}
function pow2() {
  var scale = powish(transformer2());
  scale.copy = function() {
    return copy(scale, pow2()).exponent(scale.exponent());
  };
  initRange.apply(scale, arguments);
  return scale;
}

// node_modules/d3-scale/src/quantile.js
function quantile2() {
  var domain = [], range3 = [], thresholds = [], unknown;
  function rescale() {
    var i3 = 0, n2 = Math.max(1, range3.length);
    thresholds = new Array(n2 - 1);
    while (++i3 < n2)
      thresholds[i3 - 1] = quantileSorted(domain, i3 / n2);
    return scale;
  }
  function scale(x3) {
    return x3 == null || isNaN(x3 = +x3) ? unknown : range3[bisect_default(thresholds, x3)];
  }
  scale.invertExtent = function(y3) {
    var i3 = range3.indexOf(y3);
    return i3 < 0 ? [NaN, NaN] : [
      i3 > 0 ? thresholds[i3 - 1] : domain[0],
      i3 < thresholds.length ? thresholds[i3] : domain[domain.length - 1]
    ];
  };
  scale.domain = function(_2) {
    if (!arguments.length)
      return domain.slice();
    domain = [];
    for (let d3 of _2)
      if (d3 != null && !isNaN(d3 = +d3))
        domain.push(d3);
    domain.sort(ascending);
    return rescale();
  };
  scale.range = function(_2) {
    return arguments.length ? (range3 = Array.from(_2), rescale()) : range3.slice();
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  scale.quantiles = function() {
    return thresholds.slice();
  };
  scale.copy = function() {
    return quantile2().domain(domain).range(range3).unknown(unknown);
  };
  return initRange.apply(scale, arguments);
}

// node_modules/d3-scale/src/threshold.js
function threshold() {
  var domain = [0.5], range3 = [0, 1], unknown, n2 = 1;
  function scale(x3) {
    return x3 != null && x3 <= x3 ? range3[bisect_default(domain, x3, 0, n2)] : unknown;
  }
  scale.domain = function(_2) {
    return arguments.length ? (domain = Array.from(_2), n2 = Math.min(domain.length, range3.length - 1), scale) : domain.slice();
  };
  scale.range = function(_2) {
    return arguments.length ? (range3 = Array.from(_2), n2 = Math.min(domain.length, range3.length - 1), scale) : range3.slice();
  };
  scale.invertExtent = function(y3) {
    var i3 = range3.indexOf(y3);
    return [domain[i3 - 1], domain[i3]];
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  scale.copy = function() {
    return threshold().domain(domain).range(range3).unknown(unknown);
  };
  return initRange.apply(scale, arguments);
}

// node_modules/d3-time/src/interval.js
var t02 = /* @__PURE__ */ new Date();
var t12 = /* @__PURE__ */ new Date();
function timeInterval(floori, offseti, count2, field2) {
  function interval2(date2) {
    return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;
  }
  interval2.floor = (date2) => {
    return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;
  };
  interval2.ceil = (date2) => {
    return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
  };
  interval2.round = (date2) => {
    const d0 = interval2(date2), d1 = interval2.ceil(date2);
    return date2 - d0 < d1 - date2 ? d0 : d1;
  };
  interval2.offset = (date2, step) => {
    return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
  };
  interval2.range = (start2, stop, step) => {
    const range3 = [];
    start2 = interval2.ceil(start2);
    step = step == null ? 1 : Math.floor(step);
    if (!(start2 < stop) || !(step > 0))
      return range3;
    let previous;
    do
      range3.push(previous = /* @__PURE__ */ new Date(+start2)), offseti(start2, step), floori(start2);
    while (previous < start2 && start2 < stop);
    return range3;
  };
  interval2.filter = (test) => {
    return timeInterval((date2) => {
      if (date2 >= date2)
        while (floori(date2), !test(date2))
          date2.setTime(date2 - 1);
    }, (date2, step) => {
      if (date2 >= date2) {
        if (step < 0)
          while (++step <= 0) {
            while (offseti(date2, -1), !test(date2)) {
            }
          }
        else
          while (--step >= 0) {
            while (offseti(date2, 1), !test(date2)) {
            }
          }
      }
    });
  };
  if (count2) {
    interval2.count = (start2, end) => {
      t02.setTime(+start2), t12.setTime(+end);
      floori(t02), floori(t12);
      return Math.floor(count2(t02, t12));
    };
    interval2.every = (step) => {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval2 : interval2.filter(field2 ? (d3) => field2(d3) % step === 0 : (d3) => interval2.count(0, d3) % step === 0);
    };
  }
  return interval2;
}

// node_modules/d3-time/src/millisecond.js
var millisecond = timeInterval(() => {
}, (date2, step) => {
  date2.setTime(+date2 + step);
}, (start2, end) => {
  return end - start2;
});
millisecond.every = (k4) => {
  k4 = Math.floor(k4);
  if (!isFinite(k4) || !(k4 > 0))
    return null;
  if (!(k4 > 1))
    return millisecond;
  return timeInterval((date2) => {
    date2.setTime(Math.floor(date2 / k4) * k4);
  }, (date2, step) => {
    date2.setTime(+date2 + step * k4);
  }, (start2, end) => {
    return (end - start2) / k4;
  });
};
var milliseconds = millisecond.range;

// node_modules/d3-time/src/duration.js
var durationSecond = 1e3;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;

// node_modules/d3-time/src/second.js
var second = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds());
}, (date2, step) => {
  date2.setTime(+date2 + step * durationSecond);
}, (start2, end) => {
  return (end - start2) / durationSecond;
}, (date2) => {
  return date2.getUTCSeconds();
});
var seconds = second.range;

// node_modules/d3-time/src/minute.js
var timeMinute = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationMinute);
}, (start2, end) => {
  return (end - start2) / durationMinute;
}, (date2) => {
  return date2.getMinutes();
});
var timeMinutes = timeMinute.range;
var utcMinute = timeInterval((date2) => {
  date2.setUTCSeconds(0, 0);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationMinute);
}, (start2, end) => {
  return (end - start2) / durationMinute;
}, (date2) => {
  return date2.getUTCMinutes();
});
var utcMinutes = utcMinute.range;

// node_modules/d3-time/src/hour.js
var timeHour = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationHour);
}, (start2, end) => {
  return (end - start2) / durationHour;
}, (date2) => {
  return date2.getHours();
});
var timeHours = timeHour.range;
var utcHour = timeInterval((date2) => {
  date2.setUTCMinutes(0, 0, 0);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationHour);
}, (start2, end) => {
  return (end - start2) / durationHour;
}, (date2) => {
  return date2.getUTCHours();
});
var utcHours = utcHour.range;

// node_modules/d3-time/src/day.js
var timeDay = timeInterval(
  (date2) => date2.setHours(0, 0, 0, 0),
  (date2, step) => date2.setDate(date2.getDate() + step),
  (start2, end) => (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationDay,
  (date2) => date2.getDate() - 1
);
var timeDays = timeDay.range;
var utcDay = timeInterval((date2) => {
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCDate(date2.getUTCDate() + step);
}, (start2, end) => {
  return (end - start2) / durationDay;
}, (date2) => {
  return date2.getUTCDate() - 1;
});
var utcDays = utcDay.range;
var unixDay = timeInterval((date2) => {
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCDate(date2.getUTCDate() + step);
}, (start2, end) => {
  return (end - start2) / durationDay;
}, (date2) => {
  return Math.floor(date2 / durationDay);
});
var unixDays = unixDay.range;

// node_modules/d3-time/src/week.js
function timeWeekday(i3) {
  return timeInterval((date2) => {
    date2.setDate(date2.getDate() - (date2.getDay() + 7 - i3) % 7);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setDate(date2.getDate() + step * 7);
  }, (start2, end) => {
    return (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}
var timeSunday = timeWeekday(0);
var timeMonday = timeWeekday(1);
var timeTuesday = timeWeekday(2);
var timeWednesday = timeWeekday(3);
var timeThursday = timeWeekday(4);
var timeFriday = timeWeekday(5);
var timeSaturday = timeWeekday(6);
var timeSundays = timeSunday.range;
var timeMondays = timeMonday.range;
var timeTuesdays = timeTuesday.range;
var timeWednesdays = timeWednesday.range;
var timeThursdays = timeThursday.range;
var timeFridays = timeFriday.range;
var timeSaturdays = timeSaturday.range;
function utcWeekday(i3) {
  return timeInterval((date2) => {
    date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i3) % 7);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCDate(date2.getUTCDate() + step * 7);
  }, (start2, end) => {
    return (end - start2) / durationWeek;
  });
}
var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);
var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

// node_modules/d3-time/src/month.js
var timeMonth = timeInterval((date2) => {
  date2.setDate(1);
  date2.setHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setMonth(date2.getMonth() + step);
}, (start2, end) => {
  return end.getMonth() - start2.getMonth() + (end.getFullYear() - start2.getFullYear()) * 12;
}, (date2) => {
  return date2.getMonth();
});
var timeMonths = timeMonth.range;
var utcMonth = timeInterval((date2) => {
  date2.setUTCDate(1);
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCMonth(date2.getUTCMonth() + step);
}, (start2, end) => {
  return end.getUTCMonth() - start2.getUTCMonth() + (end.getUTCFullYear() - start2.getUTCFullYear()) * 12;
}, (date2) => {
  return date2.getUTCMonth();
});
var utcMonths = utcMonth.range;

// node_modules/d3-time/src/year.js
var timeYear = timeInterval((date2) => {
  date2.setMonth(0, 1);
  date2.setHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setFullYear(date2.getFullYear() + step);
}, (start2, end) => {
  return end.getFullYear() - start2.getFullYear();
}, (date2) => {
  return date2.getFullYear();
});
timeYear.every = (k4) => {
  return !isFinite(k4 = Math.floor(k4)) || !(k4 > 0) ? null : timeInterval((date2) => {
    date2.setFullYear(Math.floor(date2.getFullYear() / k4) * k4);
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setFullYear(date2.getFullYear() + step * k4);
  });
};
var timeYears = timeYear.range;
var utcYear = timeInterval((date2) => {
  date2.setUTCMonth(0, 1);
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCFullYear(date2.getUTCFullYear() + step);
}, (start2, end) => {
  return end.getUTCFullYear() - start2.getUTCFullYear();
}, (date2) => {
  return date2.getUTCFullYear();
});
utcYear.every = (k4) => {
  return !isFinite(k4 = Math.floor(k4)) || !(k4 > 0) ? null : timeInterval((date2) => {
    date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k4) * k4);
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCFullYear(date2.getUTCFullYear() + step * k4);
  });
};
var utcYears = utcYear.range;

// node_modules/d3-time/src/ticks.js
function ticker(year, month, week, day, hour, minute) {
  const tickIntervals2 = [
    [second, 1, durationSecond],
    [second, 5, 5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute, 1, durationMinute],
    [minute, 5, 5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [hour, 1, durationHour],
    [hour, 3, 3 * durationHour],
    [hour, 6, 6 * durationHour],
    [hour, 12, 12 * durationHour],
    [day, 1, durationDay],
    [day, 2, 2 * durationDay],
    [week, 1, durationWeek],
    [month, 1, durationMonth],
    [month, 3, 3 * durationMonth],
    [year, 1, durationYear]
  ];
  function ticks2(start2, stop, count2) {
    const reverse2 = stop < start2;
    if (reverse2)
      [start2, stop] = [stop, start2];
    const interval2 = count2 && typeof count2.range === "function" ? count2 : tickInterval(start2, stop, count2);
    const ticks3 = interval2 ? interval2.range(start2, +stop + 1) : [];
    return reverse2 ? ticks3.reverse() : ticks3;
  }
  function tickInterval(start2, stop, count2) {
    const target = Math.abs(stop - start2) / count2;
    const i3 = bisector(([, , step2]) => step2).right(tickIntervals2, target);
    if (i3 === tickIntervals2.length)
      return year.every(tickStep(start2 / durationYear, stop / durationYear, count2));
    if (i3 === 0)
      return millisecond.every(Math.max(tickStep(start2, stop, count2), 1));
    const [t4, step] = tickIntervals2[target / tickIntervals2[i3 - 1][2] < tickIntervals2[i3][2] / target ? i3 - 1 : i3];
    return t4.every(step);
  }
  return [ticks2, tickInterval];
}
var [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
var [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);

// node_modules/d3-time-format/src/locale.js
function localDate(d3) {
  if (0 <= d3.y && d3.y < 100) {
    var date2 = new Date(-1, d3.m, d3.d, d3.H, d3.M, d3.S, d3.L);
    date2.setFullYear(d3.y);
    return date2;
  }
  return new Date(d3.y, d3.m, d3.d, d3.H, d3.M, d3.S, d3.L);
}
function utcDate(d3) {
  if (0 <= d3.y && d3.y < 100) {
    var date2 = new Date(Date.UTC(-1, d3.m, d3.d, d3.H, d3.M, d3.S, d3.L));
    date2.setUTCFullYear(d3.y);
    return date2;
  }
  return new Date(Date.UTC(d3.y, d3.m, d3.d, d3.H, d3.M, d3.S, d3.L));
}
function newDate(y3, m3, d3) {
  return { y: y3, m: m3, d: d3, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale(locale3) {
  var locale_dateTime = locale3.dateTime, locale_date = locale3.date, locale_time = locale3.time, locale_periods = locale3.periods, locale_weekdays = locale3.days, locale_shortWeekdays = locale3.shortDays, locale_months = locale3.months, locale_shortMonths = locale3.shortMonths;
  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats2) {
    return function(date2) {
      var string2 = [], i3 = -1, j3 = 0, n2 = specifier.length, c6, pad3, format3;
      if (!(date2 instanceof Date))
        date2 = /* @__PURE__ */ new Date(+date2);
      while (++i3 < n2) {
        if (specifier.charCodeAt(i3) === 37) {
          string2.push(specifier.slice(j3, i3));
          if ((pad3 = pads[c6 = specifier.charAt(++i3)]) != null)
            c6 = specifier.charAt(++i3);
          else
            pad3 = c6 === "e" ? " " : "0";
          if (format3 = formats2[c6])
            c6 = format3(date2, pad3);
          string2.push(c6);
          j3 = i3 + 1;
        }
      }
      string2.push(specifier.slice(j3, i3));
      return string2.join("");
    };
  }
  function newParse(specifier, Z) {
    return function(string2) {
      var d3 = newDate(1900, void 0, 1), i3 = parseSpecifier(d3, specifier, string2 += "", 0), week, day;
      if (i3 != string2.length)
        return null;
      if ("Q" in d3)
        return new Date(d3.Q);
      if ("s" in d3)
        return new Date(d3.s * 1e3 + ("L" in d3 ? d3.L : 0));
      if (Z && !("Z" in d3))
        d3.Z = 0;
      if ("p" in d3)
        d3.H = d3.H % 12 + d3.p * 12;
      if (d3.m === void 0)
        d3.m = "q" in d3 ? d3.q : 0;
      if ("V" in d3) {
        if (d3.V < 1 || d3.V > 53)
          return null;
        if (!("w" in d3))
          d3.w = 1;
        if ("Z" in d3) {
          week = utcDate(newDate(d3.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay.offset(week, (d3.V - 1) * 7);
          d3.y = week.getUTCFullYear();
          d3.m = week.getUTCMonth();
          d3.d = week.getUTCDate() + (d3.w + 6) % 7;
        } else {
          week = localDate(newDate(d3.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
          week = timeDay.offset(week, (d3.V - 1) * 7);
          d3.y = week.getFullYear();
          d3.m = week.getMonth();
          d3.d = week.getDate() + (d3.w + 6) % 7;
        }
      } else if ("W" in d3 || "U" in d3) {
        if (!("w" in d3))
          d3.w = "u" in d3 ? d3.u % 7 : "W" in d3 ? 1 : 0;
        day = "Z" in d3 ? utcDate(newDate(d3.y, 0, 1)).getUTCDay() : localDate(newDate(d3.y, 0, 1)).getDay();
        d3.m = 0;
        d3.d = "W" in d3 ? (d3.w + 6) % 7 + d3.W * 7 - (day + 5) % 7 : d3.w + d3.U * 7 - (day + 6) % 7;
      }
      if ("Z" in d3) {
        d3.H += d3.Z / 100 | 0;
        d3.M += d3.Z % 100;
        return utcDate(d3);
      }
      return localDate(d3);
    };
  }
  function parseSpecifier(d3, specifier, string2, j3) {
    var i3 = 0, n2 = specifier.length, m3 = string2.length, c6, parse2;
    while (i3 < n2) {
      if (j3 >= m3)
        return -1;
      c6 = specifier.charCodeAt(i3++);
      if (c6 === 37) {
        c6 = specifier.charAt(i3++);
        parse2 = parses[c6 in pads ? specifier.charAt(i3++) : c6];
        if (!parse2 || (j3 = parse2(d3, string2, j3)) < 0)
          return -1;
      } else if (c6 != string2.charCodeAt(j3++)) {
        return -1;
      }
    }
    return j3;
  }
  function parsePeriod(d3, string2, i3) {
    var n2 = periodRe.exec(string2.slice(i3));
    return n2 ? (d3.p = periodLookup.get(n2[0].toLowerCase()), i3 + n2[0].length) : -1;
  }
  function parseShortWeekday(d3, string2, i3) {
    var n2 = shortWeekdayRe.exec(string2.slice(i3));
    return n2 ? (d3.w = shortWeekdayLookup.get(n2[0].toLowerCase()), i3 + n2[0].length) : -1;
  }
  function parseWeekday(d3, string2, i3) {
    var n2 = weekdayRe.exec(string2.slice(i3));
    return n2 ? (d3.w = weekdayLookup.get(n2[0].toLowerCase()), i3 + n2[0].length) : -1;
  }
  function parseShortMonth(d3, string2, i3) {
    var n2 = shortMonthRe.exec(string2.slice(i3));
    return n2 ? (d3.m = shortMonthLookup.get(n2[0].toLowerCase()), i3 + n2[0].length) : -1;
  }
  function parseMonth(d3, string2, i3) {
    var n2 = monthRe.exec(string2.slice(i3));
    return n2 ? (d3.m = monthLookup.get(n2[0].toLowerCase()), i3 + n2[0].length) : -1;
  }
  function parseLocaleDateTime(d3, string2, i3) {
    return parseSpecifier(d3, locale_dateTime, string2, i3);
  }
  function parseLocaleDate(d3, string2, i3) {
    return parseSpecifier(d3, locale_date, string2, i3);
  }
  function parseLocaleTime(d3, string2, i3) {
    return parseSpecifier(d3, locale_time, string2, i3);
  }
  function formatShortWeekday(d3) {
    return locale_shortWeekdays[d3.getDay()];
  }
  function formatWeekday(d3) {
    return locale_weekdays[d3.getDay()];
  }
  function formatShortMonth(d3) {
    return locale_shortMonths[d3.getMonth()];
  }
  function formatMonth(d3) {
    return locale_months[d3.getMonth()];
  }
  function formatPeriod(d3) {
    return locale_periods[+(d3.getHours() >= 12)];
  }
  function formatQuarter(d3) {
    return 1 + ~~(d3.getMonth() / 3);
  }
  function formatUTCShortWeekday(d3) {
    return locale_shortWeekdays[d3.getUTCDay()];
  }
  function formatUTCWeekday(d3) {
    return locale_weekdays[d3.getUTCDay()];
  }
  function formatUTCShortMonth(d3) {
    return locale_shortMonths[d3.getUTCMonth()];
  }
  function formatUTCMonth(d3) {
    return locale_months[d3.getUTCMonth()];
  }
  function formatUTCPeriod(d3) {
    return locale_periods[+(d3.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d3) {
    return 1 + ~~(d3.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f3 = newFormat(specifier += "", formats);
      f3.toString = function() {
        return specifier;
      };
      return f3;
    },
    parse: function(specifier) {
      var p3 = newParse(specifier += "", false);
      p3.toString = function() {
        return specifier;
      };
      return p3;
    },
    utcFormat: function(specifier) {
      var f3 = newFormat(specifier += "", utcFormats);
      f3.toString = function() {
        return specifier;
      };
      return f3;
    },
    utcParse: function(specifier) {
      var p3 = newParse(specifier += "", true);
      p3.toString = function() {
        return specifier;
      };
      return p3;
    }
  };
}
var pads = { "-": "", "_": " ", "0": "0" };
var numberRe = /^\s*\d+/;
var percentRe = /^%/;
var requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad(value, fill, width) {
  var sign2 = value < 0 ? "-" : "", string2 = (sign2 ? -value : value) + "", length3 = string2.length;
  return sign2 + (length3 < width ? new Array(width - length3 + 1).join(fill) + string2 : string2);
}
function requote(s4) {
  return s4.replace(requoteRe, "\\$&");
}
function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
  return new Map(names.map((name, i3) => [name.toLowerCase(), i3]));
}
function parseWeekdayNumberSunday(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3, i3 + 1));
  return n2 ? (d3.w = +n2[0], i3 + n2[0].length) : -1;
}
function parseWeekdayNumberMonday(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3, i3 + 1));
  return n2 ? (d3.u = +n2[0], i3 + n2[0].length) : -1;
}
function parseWeekNumberSunday(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3, i3 + 2));
  return n2 ? (d3.U = +n2[0], i3 + n2[0].length) : -1;
}
function parseWeekNumberISO(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3, i3 + 2));
  return n2 ? (d3.V = +n2[0], i3 + n2[0].length) : -1;
}
function parseWeekNumberMonday(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3, i3 + 2));
  return n2 ? (d3.W = +n2[0], i3 + n2[0].length) : -1;
}
function parseFullYear(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3, i3 + 4));
  return n2 ? (d3.y = +n2[0], i3 + n2[0].length) : -1;
}
function parseYear(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3, i3 + 2));
  return n2 ? (d3.y = +n2[0] + (+n2[0] > 68 ? 1900 : 2e3), i3 + n2[0].length) : -1;
}
function parseZone(d3, string2, i3) {
  var n2 = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string2.slice(i3, i3 + 6));
  return n2 ? (d3.Z = n2[1] ? 0 : -(n2[2] + (n2[3] || "00")), i3 + n2[0].length) : -1;
}
function parseQuarter(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3, i3 + 1));
  return n2 ? (d3.q = n2[0] * 3 - 3, i3 + n2[0].length) : -1;
}
function parseMonthNumber(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3, i3 + 2));
  return n2 ? (d3.m = n2[0] - 1, i3 + n2[0].length) : -1;
}
function parseDayOfMonth(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3, i3 + 2));
  return n2 ? (d3.d = +n2[0], i3 + n2[0].length) : -1;
}
function parseDayOfYear(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3, i3 + 3));
  return n2 ? (d3.m = 0, d3.d = +n2[0], i3 + n2[0].length) : -1;
}
function parseHour24(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3, i3 + 2));
  return n2 ? (d3.H = +n2[0], i3 + n2[0].length) : -1;
}
function parseMinutes(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3, i3 + 2));
  return n2 ? (d3.M = +n2[0], i3 + n2[0].length) : -1;
}
function parseSeconds(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3, i3 + 2));
  return n2 ? (d3.S = +n2[0], i3 + n2[0].length) : -1;
}
function parseMilliseconds(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3, i3 + 3));
  return n2 ? (d3.L = +n2[0], i3 + n2[0].length) : -1;
}
function parseMicroseconds(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3, i3 + 6));
  return n2 ? (d3.L = Math.floor(n2[0] / 1e3), i3 + n2[0].length) : -1;
}
function parseLiteralPercent(d3, string2, i3) {
  var n2 = percentRe.exec(string2.slice(i3, i3 + 1));
  return n2 ? i3 + n2[0].length : -1;
}
function parseUnixTimestamp(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3));
  return n2 ? (d3.Q = +n2[0], i3 + n2[0].length) : -1;
}
function parseUnixTimestampSeconds(d3, string2, i3) {
  var n2 = numberRe.exec(string2.slice(i3));
  return n2 ? (d3.s = +n2[0], i3 + n2[0].length) : -1;
}
function formatDayOfMonth(d3, p3) {
  return pad(d3.getDate(), p3, 2);
}
function formatHour24(d3, p3) {
  return pad(d3.getHours(), p3, 2);
}
function formatHour12(d3, p3) {
  return pad(d3.getHours() % 12 || 12, p3, 2);
}
function formatDayOfYear(d3, p3) {
  return pad(1 + timeDay.count(timeYear(d3), d3), p3, 3);
}
function formatMilliseconds(d3, p3) {
  return pad(d3.getMilliseconds(), p3, 3);
}
function formatMicroseconds(d3, p3) {
  return formatMilliseconds(d3, p3) + "000";
}
function formatMonthNumber(d3, p3) {
  return pad(d3.getMonth() + 1, p3, 2);
}
function formatMinutes(d3, p3) {
  return pad(d3.getMinutes(), p3, 2);
}
function formatSeconds(d3, p3) {
  return pad(d3.getSeconds(), p3, 2);
}
function formatWeekdayNumberMonday(d3) {
  var day = d3.getDay();
  return day === 0 ? 7 : day;
}
function formatWeekNumberSunday(d3, p3) {
  return pad(timeSunday.count(timeYear(d3) - 1, d3), p3, 2);
}
function dISO(d3) {
  var day = d3.getDay();
  return day >= 4 || day === 0 ? timeThursday(d3) : timeThursday.ceil(d3);
}
function formatWeekNumberISO(d3, p3) {
  d3 = dISO(d3);
  return pad(timeThursday.count(timeYear(d3), d3) + (timeYear(d3).getDay() === 4), p3, 2);
}
function formatWeekdayNumberSunday(d3) {
  return d3.getDay();
}
function formatWeekNumberMonday(d3, p3) {
  return pad(timeMonday.count(timeYear(d3) - 1, d3), p3, 2);
}
function formatYear(d3, p3) {
  return pad(d3.getFullYear() % 100, p3, 2);
}
function formatYearISO(d3, p3) {
  d3 = dISO(d3);
  return pad(d3.getFullYear() % 100, p3, 2);
}
function formatFullYear(d3, p3) {
  return pad(d3.getFullYear() % 1e4, p3, 4);
}
function formatFullYearISO(d3, p3) {
  var day = d3.getDay();
  d3 = day >= 4 || day === 0 ? timeThursday(d3) : timeThursday.ceil(d3);
  return pad(d3.getFullYear() % 1e4, p3, 4);
}
function formatZone(d3) {
  var z3 = d3.getTimezoneOffset();
  return (z3 > 0 ? "-" : (z3 *= -1, "+")) + pad(z3 / 60 | 0, "0", 2) + pad(z3 % 60, "0", 2);
}
function formatUTCDayOfMonth(d3, p3) {
  return pad(d3.getUTCDate(), p3, 2);
}
function formatUTCHour24(d3, p3) {
  return pad(d3.getUTCHours(), p3, 2);
}
function formatUTCHour12(d3, p3) {
  return pad(d3.getUTCHours() % 12 || 12, p3, 2);
}
function formatUTCDayOfYear(d3, p3) {
  return pad(1 + utcDay.count(utcYear(d3), d3), p3, 3);
}
function formatUTCMilliseconds(d3, p3) {
  return pad(d3.getUTCMilliseconds(), p3, 3);
}
function formatUTCMicroseconds(d3, p3) {
  return formatUTCMilliseconds(d3, p3) + "000";
}
function formatUTCMonthNumber(d3, p3) {
  return pad(d3.getUTCMonth() + 1, p3, 2);
}
function formatUTCMinutes(d3, p3) {
  return pad(d3.getUTCMinutes(), p3, 2);
}
function formatUTCSeconds(d3, p3) {
  return pad(d3.getUTCSeconds(), p3, 2);
}
function formatUTCWeekdayNumberMonday(d3) {
  var dow = d3.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d3, p3) {
  return pad(utcSunday.count(utcYear(d3) - 1, d3), p3, 2);
}
function UTCdISO(d3) {
  var day = d3.getUTCDay();
  return day >= 4 || day === 0 ? utcThursday(d3) : utcThursday.ceil(d3);
}
function formatUTCWeekNumberISO(d3, p3) {
  d3 = UTCdISO(d3);
  return pad(utcThursday.count(utcYear(d3), d3) + (utcYear(d3).getUTCDay() === 4), p3, 2);
}
function formatUTCWeekdayNumberSunday(d3) {
  return d3.getUTCDay();
}
function formatUTCWeekNumberMonday(d3, p3) {
  return pad(utcMonday.count(utcYear(d3) - 1, d3), p3, 2);
}
function formatUTCYear(d3, p3) {
  return pad(d3.getUTCFullYear() % 100, p3, 2);
}
function formatUTCYearISO(d3, p3) {
  d3 = UTCdISO(d3);
  return pad(d3.getUTCFullYear() % 100, p3, 2);
}
function formatUTCFullYear(d3, p3) {
  return pad(d3.getUTCFullYear() % 1e4, p3, 4);
}
function formatUTCFullYearISO(d3, p3) {
  var day = d3.getUTCDay();
  d3 = day >= 4 || day === 0 ? utcThursday(d3) : utcThursday.ceil(d3);
  return pad(d3.getUTCFullYear() % 1e4, p3, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d3) {
  return +d3;
}
function formatUnixTimestampSeconds(d3) {
  return Math.floor(+d3 / 1e3);
}

// node_modules/d3-time-format/src/defaultLocale.js
var locale2;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;
defaultLocale2({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale2(definition) {
  locale2 = formatLocale(definition);
  timeFormat = locale2.format;
  timeParse = locale2.parse;
  utcFormat = locale2.utcFormat;
  utcParse = locale2.utcParse;
  return locale2;
}

// node_modules/d3-scale/src/time.js
function date(t4) {
  return new Date(t4);
}
function number4(t4) {
  return t4 instanceof Date ? +t4 : +/* @__PURE__ */ new Date(+t4);
}
function calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second3, format3) {
  var scale = continuous(), invert = scale.invert, domain = scale.domain;
  var formatMillisecond = format3(".%L"), formatSecond = format3(":%S"), formatMinute = format3("%I:%M"), formatHour = format3("%I %p"), formatDay = format3("%a %d"), formatWeek = format3("%b %d"), formatMonth = format3("%B"), formatYear3 = format3("%Y");
  function tickFormat2(date2) {
    return (second3(date2) < date2 ? formatMillisecond : minute(date2) < date2 ? formatSecond : hour(date2) < date2 ? formatMinute : day(date2) < date2 ? formatHour : month(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year(date2) < date2 ? formatMonth : formatYear3)(date2);
  }
  scale.invert = function(y3) {
    return new Date(invert(y3));
  };
  scale.domain = function(_2) {
    return arguments.length ? domain(Array.from(_2, number4)) : domain().map(date);
  };
  scale.ticks = function(interval2) {
    var d3 = domain();
    return ticks2(d3[0], d3[d3.length - 1], interval2 == null ? 10 : interval2);
  };
  scale.tickFormat = function(count2, specifier) {
    return specifier == null ? tickFormat2 : format3(specifier);
  };
  scale.nice = function(interval2) {
    var d3 = domain();
    if (!interval2 || typeof interval2.range !== "function")
      interval2 = tickInterval(d3[0], d3[d3.length - 1], interval2 == null ? 10 : interval2);
    return interval2 ? domain(nice(d3, interval2)) : scale;
  };
  scale.copy = function() {
    return copy(scale, calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second3, format3));
  };
  return scale;
}
function time() {
  return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}

// node_modules/d3-scale/src/utcTime.js
function utcTime() {
  return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}

// node_modules/d3-scale/src/sequential.js
function copy2(source, target) {
  return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
}

// node_modules/d3-scale/src/diverging.js
function transformer3() {
  var x05 = 0, x12 = 0.5, x22 = 1, s4 = 1, t03, t13, t23, k10, k21, interpolator = identity3, transform2, clamp = false, unknown;
  function scale(x3) {
    return isNaN(x3 = +x3) ? unknown : (x3 = 0.5 + ((x3 = +transform2(x3)) - t13) * (s4 * x3 < s4 * t13 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x3)) : x3));
  }
  scale.domain = function(_2) {
    return arguments.length ? ([x05, x12, x22] = _2, t03 = transform2(x05 = +x05), t13 = transform2(x12 = +x12), t23 = transform2(x22 = +x22), k10 = t03 === t13 ? 0 : 0.5 / (t13 - t03), k21 = t13 === t23 ? 0 : 0.5 / (t23 - t13), s4 = t13 < t03 ? -1 : 1, scale) : [x05, x12, x22];
  };
  scale.clamp = function(_2) {
    return arguments.length ? (clamp = !!_2, scale) : clamp;
  };
  scale.interpolator = function(_2) {
    return arguments.length ? (interpolator = _2, scale) : interpolator;
  };
  function range3(interpolate) {
    return function(_2) {
      var r0, r1, r22;
      return arguments.length ? ([r0, r1, r22] = _2, interpolator = piecewise(interpolate, [r0, r1, r22]), scale) : [interpolator(0), interpolator(0.5), interpolator(1)];
    };
  }
  scale.range = range3(value_default);
  scale.rangeRound = range3(round_default);
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  return function(t4) {
    transform2 = t4, t03 = t4(x05), t13 = t4(x12), t23 = t4(x22), k10 = t03 === t13 ? 0 : 0.5 / (t13 - t03), k21 = t13 === t23 ? 0 : 0.5 / (t23 - t13), s4 = t13 < t03 ? -1 : 1;
    return scale;
  };
}
function diverging() {
  var scale = linearish(transformer3()(identity3));
  scale.copy = function() {
    return copy2(scale, diverging());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingLog() {
  var scale = loggish(transformer3()).domain([0.1, 1, 10]);
  scale.copy = function() {
    return copy2(scale, divergingLog()).base(scale.base());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingSymlog() {
  var scale = symlogish(transformer3());
  scale.copy = function() {
    return copy2(scale, divergingSymlog()).constant(scale.constant());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingPow() {
  var scale = powish(transformer3());
  scale.copy = function() {
    return copy2(scale, divergingPow()).exponent(scale.exponent());
  };
  return initInterpolator.apply(scale, arguments);
}

// node_modules/d3-scale-chromatic/src/colors.js
function colors_default(specifier) {
  var n2 = specifier.length / 6 | 0, colors = new Array(n2), i3 = 0;
  while (i3 < n2)
    colors[i3] = "#" + specifier.slice(i3 * 6, ++i3 * 6);
  return colors;
}

// node_modules/d3-scale-chromatic/src/categorical/category10.js
var category10_default = colors_default("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

// node_modules/d3-scale-chromatic/src/categorical/Accent.js
var Accent_default = colors_default("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

// node_modules/d3-scale-chromatic/src/categorical/Dark2.js
var Dark2_default = colors_default("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

// node_modules/d3-scale-chromatic/src/categorical/Paired.js
var Paired_default = colors_default("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

// node_modules/d3-scale-chromatic/src/categorical/Pastel1.js
var Pastel1_default = colors_default("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

// node_modules/d3-scale-chromatic/src/categorical/Pastel2.js
var Pastel2_default = colors_default("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

// node_modules/d3-scale-chromatic/src/categorical/Set1.js
var Set1_default = colors_default("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

// node_modules/d3-scale-chromatic/src/categorical/Set2.js
var Set2_default = colors_default("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

// node_modules/d3-scale-chromatic/src/categorical/Set3.js
var Set3_default = colors_default("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

// node_modules/d3-scale-chromatic/src/categorical/Tableau10.js
var Tableau10_default = colors_default("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

// node_modules/d3-scale-chromatic/src/ramp.js
var ramp_default = (scheme28) => rgbBasis(scheme28[scheme28.length - 1]);

// node_modules/d3-scale-chromatic/src/diverging/BrBG.js
var scheme = new Array(3).concat(
  "d8b365f5f5f55ab4ac",
  "a6611adfc27d80cdc1018571",
  "a6611adfc27df5f5f580cdc1018571",
  "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
  "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
  "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
  "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
  "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
  "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
).map(colors_default);
var BrBG_default = ramp_default(scheme);

// node_modules/d3-scale-chromatic/src/diverging/PRGn.js
var scheme2 = new Array(3).concat(
  "af8dc3f7f7f77fbf7b",
  "7b3294c2a5cfa6dba0008837",
  "7b3294c2a5cff7f7f7a6dba0008837",
  "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
  "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
  "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
  "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
  "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
  "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
).map(colors_default);
var PRGn_default = ramp_default(scheme2);

// node_modules/d3-scale-chromatic/src/diverging/PiYG.js
var scheme3 = new Array(3).concat(
  "e9a3c9f7f7f7a1d76a",
  "d01c8bf1b6dab8e1864dac26",
  "d01c8bf1b6daf7f7f7b8e1864dac26",
  "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
  "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
  "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
  "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
  "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
  "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
).map(colors_default);
var PiYG_default = ramp_default(scheme3);

// node_modules/d3-scale-chromatic/src/diverging/PuOr.js
var scheme4 = new Array(3).concat(
  "998ec3f7f7f7f1a340",
  "5e3c99b2abd2fdb863e66101",
  "5e3c99b2abd2f7f7f7fdb863e66101",
  "542788998ec3d8daebfee0b6f1a340b35806",
  "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
  "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
  "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
  "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
  "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
).map(colors_default);
var PuOr_default = ramp_default(scheme4);

// node_modules/d3-scale-chromatic/src/diverging/RdBu.js
var scheme5 = new Array(3).concat(
  "ef8a62f7f7f767a9cf",
  "ca0020f4a58292c5de0571b0",
  "ca0020f4a582f7f7f792c5de0571b0",
  "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
  "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
  "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
  "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
  "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
  "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
).map(colors_default);
var RdBu_default = ramp_default(scheme5);

// node_modules/d3-scale-chromatic/src/diverging/RdGy.js
var scheme6 = new Array(3).concat(
  "ef8a62ffffff999999",
  "ca0020f4a582bababa404040",
  "ca0020f4a582ffffffbababa404040",
  "b2182bef8a62fddbc7e0e0e09999994d4d4d",
  "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
  "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
  "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
  "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
  "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
).map(colors_default);
var RdGy_default = ramp_default(scheme6);

// node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js
var scheme7 = new Array(3).concat(
  "fc8d59ffffbf91bfdb",
  "d7191cfdae61abd9e92c7bb6",
  "d7191cfdae61ffffbfabd9e92c7bb6",
  "d73027fc8d59fee090e0f3f891bfdb4575b4",
  "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
  "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
  "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
  "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
  "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
).map(colors_default);
var RdYlBu_default = ramp_default(scheme7);

// node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js
var scheme8 = new Array(3).concat(
  "fc8d59ffffbf91cf60",
  "d7191cfdae61a6d96a1a9641",
  "d7191cfdae61ffffbfa6d96a1a9641",
  "d73027fc8d59fee08bd9ef8b91cf601a9850",
  "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
  "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
  "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
  "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
  "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
).map(colors_default);
var RdYlGn_default = ramp_default(scheme8);

// node_modules/d3-scale-chromatic/src/diverging/Spectral.js
var scheme9 = new Array(3).concat(
  "fc8d59ffffbf99d594",
  "d7191cfdae61abdda42b83ba",
  "d7191cfdae61ffffbfabdda42b83ba",
  "d53e4ffc8d59fee08be6f59899d5943288bd",
  "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
  "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
  "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
  "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
  "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
).map(colors_default);
var Spectral_default = ramp_default(scheme9);

// node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js
var scheme10 = new Array(3).concat(
  "e5f5f999d8c92ca25f",
  "edf8fbb2e2e266c2a4238b45",
  "edf8fbb2e2e266c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
).map(colors_default);
var BuGn_default = ramp_default(scheme10);

// node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js
var scheme11 = new Array(3).concat(
  "e0ecf49ebcda8856a7",
  "edf8fbb3cde38c96c688419d",
  "edf8fbb3cde38c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
).map(colors_default);
var BuPu_default = ramp_default(scheme11);

// node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js
var scheme12 = new Array(3).concat(
  "e0f3dba8ddb543a2ca",
  "f0f9e8bae4bc7bccc42b8cbe",
  "f0f9e8bae4bc7bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
).map(colors_default);
var GnBu_default = ramp_default(scheme12);

// node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js
var scheme13 = new Array(3).concat(
  "fee8c8fdbb84e34a33",
  "fef0d9fdcc8afc8d59d7301f",
  "fef0d9fdcc8afc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
).map(colors_default);
var OrRd_default = ramp_default(scheme13);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js
var scheme14 = new Array(3).concat(
  "ece2f0a6bddb1c9099",
  "f6eff7bdc9e167a9cf02818a",
  "f6eff7bdc9e167a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
).map(colors_default);
var PuBuGn_default = ramp_default(scheme14);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js
var scheme15 = new Array(3).concat(
  "ece7f2a6bddb2b8cbe",
  "f1eef6bdc9e174a9cf0570b0",
  "f1eef6bdc9e174a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
).map(colors_default);
var PuBu_default = ramp_default(scheme15);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js
var scheme16 = new Array(3).concat(
  "e7e1efc994c7dd1c77",
  "f1eef6d7b5d8df65b0ce1256",
  "f1eef6d7b5d8df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
).map(colors_default);
var PuRd_default = ramp_default(scheme16);

// node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js
var scheme17 = new Array(3).concat(
  "fde0ddfa9fb5c51b8a",
  "feebe2fbb4b9f768a1ae017e",
  "feebe2fbb4b9f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
).map(colors_default);
var RdPu_default = ramp_default(scheme17);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js
var scheme18 = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(colors_default);
var YlGnBu_default = ramp_default(scheme18);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js
var scheme19 = new Array(3).concat(
  "f7fcb9addd8e31a354",
  "ffffccc2e69978c679238443",
  "ffffccc2e69978c67931a354006837",
  "ffffccd9f0a3addd8e78c67931a354006837",
  "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
).map(colors_default);
var YlGn_default = ramp_default(scheme19);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js
var scheme20 = new Array(3).concat(
  "fff7bcfec44fd95f0e",
  "ffffd4fed98efe9929cc4c02",
  "ffffd4fed98efe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
).map(colors_default);
var YlOrBr_default = ramp_default(scheme20);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js
var scheme21 = new Array(3).concat(
  "ffeda0feb24cf03b20",
  "ffffb2fecc5cfd8d3ce31a1c",
  "ffffb2fecc5cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
).map(colors_default);
var YlOrRd_default = ramp_default(scheme21);

// node_modules/d3-scale-chromatic/src/sequential-single/Blues.js
var scheme22 = new Array(3).concat(
  "deebf79ecae13182bd",
  "eff3ffbdd7e76baed62171b5",
  "eff3ffbdd7e76baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
).map(colors_default);
var Blues_default = ramp_default(scheme22);

// node_modules/d3-scale-chromatic/src/sequential-single/Greens.js
var scheme23 = new Array(3).concat(
  "e5f5e0a1d99b31a354",
  "edf8e9bae4b374c476238b45",
  "edf8e9bae4b374c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
).map(colors_default);
var Greens_default = ramp_default(scheme23);

// node_modules/d3-scale-chromatic/src/sequential-single/Greys.js
var scheme24 = new Array(3).concat(
  "f0f0f0bdbdbd636363",
  "f7f7f7cccccc969696525252",
  "f7f7f7cccccc969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
).map(colors_default);
var Greys_default = ramp_default(scheme24);

// node_modules/d3-scale-chromatic/src/sequential-single/Purples.js
var scheme25 = new Array(3).concat(
  "efedf5bcbddc756bb1",
  "f2f0f7cbc9e29e9ac86a51a3",
  "f2f0f7cbc9e29e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
).map(colors_default);
var Purples_default = ramp_default(scheme25);

// node_modules/d3-scale-chromatic/src/sequential-single/Reds.js
var scheme26 = new Array(3).concat(
  "fee0d2fc9272de2d26",
  "fee5d9fcae91fb6a4acb181d",
  "fee5d9fcae91fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
).map(colors_default);
var Reds_default = ramp_default(scheme26);

// node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js
var scheme27 = new Array(3).concat(
  "fee6cefdae6be6550d",
  "feeddefdbe85fd8d3cd94701",
  "feeddefdbe85fd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
).map(colors_default);
var Oranges_default = ramp_default(scheme27);

// node_modules/d3-scale-chromatic/src/sequential-multi/cividis.js
function cividis_default(t4) {
  t4 = Math.max(0, Math.min(1, t4));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(-4.54 - t4 * (35.34 - t4 * (2381.73 - t4 * (6402.7 - t4 * (7024.72 - t4 * 2710.57))))))) + ", " + Math.max(0, Math.min(255, Math.round(32.49 + t4 * (170.73 + t4 * (52.82 - t4 * (131.46 - t4 * (176.58 - t4 * 67.37))))))) + ", " + Math.max(0, Math.min(255, Math.round(81.24 + t4 * (442.36 - t4 * (2482.43 - t4 * (6167.24 - t4 * (6614.94 - t4 * 2475.67))))))) + ")";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js
var cubehelix_default2 = cubehelixLong(cubehelix(300, 0.5, 0), cubehelix(-240, 0.5, 1));

// node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js
var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var c3 = cubehelix();
function rainbow_default(t4) {
  if (t4 < 0 || t4 > 1)
    t4 -= Math.floor(t4);
  var ts = Math.abs(t4 - 0.5);
  c3.h = 360 * t4 - 100;
  c3.s = 1.5 - 1.5 * ts;
  c3.l = 0.8 - 0.9 * ts;
  return c3 + "";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js
var c4 = rgb();
var pi_1_3 = Math.PI / 3;
var pi_2_3 = Math.PI * 2 / 3;
function sinebow_default(t4) {
  var x3;
  t4 = (0.5 - t4) * Math.PI;
  c4.r = 255 * (x3 = Math.sin(t4)) * x3;
  c4.g = 255 * (x3 = Math.sin(t4 + pi_1_3)) * x3;
  c4.b = 255 * (x3 = Math.sin(t4 + pi_2_3)) * x3;
  return c4 + "";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/turbo.js
function turbo_default(t4) {
  t4 = Math.max(0, Math.min(1, t4));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + t4 * (1172.33 - t4 * (10793.56 - t4 * (33300.12 - t4 * (38394.49 - t4 * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + t4 * (557.33 + t4 * (1225.33 - t4 * (3574.96 - t4 * (1073.77 + t4 * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + t4 * (3211.1 - t4 * (15327.97 - t4 * (27814 - t4 * (22569.18 - t4 * 6838.66))))))) + ")";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js
function ramp(range3) {
  var n2 = range3.length;
  return function(t4) {
    return range3[Math.max(0, Math.min(n2 - 1, Math.floor(t4 * n2)))];
  };
}
var viridis_default = ramp(colors_default("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
var magma = ramp(colors_default("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
var inferno = ramp(colors_default("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
var plasma = ramp(colors_default("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

// node_modules/d3-shape/src/constant.js
function constant_default4(x3) {
  return function constant2() {
    return x3;
  };
}

// node_modules/d3-shape/src/math.js
var cos2 = Math.cos;
var min3 = Math.min;
var sin2 = Math.sin;
var sqrt3 = Math.sqrt;
var pi3 = Math.PI;
var halfPi2 = pi3 / 2;
var tau3 = 2 * pi3;

// node_modules/d3-shape/src/path.js
function withPath(shape) {
  let digits = 3;
  shape.digits = function(_2) {
    if (!arguments.length)
      return digits;
    if (_2 == null) {
      digits = null;
    } else {
      const d3 = Math.floor(_2);
      if (!(d3 >= 0))
        throw new RangeError(`invalid digits: ${_2}`);
      digits = d3;
    }
    return shape;
  };
  return () => new Path(digits);
}

// node_modules/d3-shape/src/array.js
var slice = Array.prototype.slice;
function array_default(x3) {
  return typeof x3 === "object" && "length" in x3 ? x3 : Array.from(x3);
}

// node_modules/d3-shape/src/curve/linear.js
function Linear(context) {
  this._context = context;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(x3, y3);
        break;
    }
  }
};
function linear_default(context) {
  return new Linear(context);
}

// node_modules/d3-shape/src/point.js
function x2(p3) {
  return p3[0];
}
function y2(p3) {
  return p3[1];
}

// node_modules/d3-shape/src/line.js
function line_default2(x3, y3) {
  var defined2 = constant_default4(true), context = null, curve = linear_default, output = null, path2 = withPath(line);
  x3 = typeof x3 === "function" ? x3 : x3 === void 0 ? x2 : constant_default4(x3);
  y3 = typeof y3 === "function" ? y3 : y3 === void 0 ? y2 : constant_default4(y3);
  function line(data) {
    var i3, n2 = (data = array_default(data)).length, d3, defined0 = false, buffer;
    if (context == null)
      output = curve(buffer = path2());
    for (i3 = 0; i3 <= n2; ++i3) {
      if (!(i3 < n2 && defined2(d3 = data[i3], i3, data)) === defined0) {
        if (defined0 = !defined0)
          output.lineStart();
        else
          output.lineEnd();
      }
      if (defined0)
        output.point(+x3(d3, i3, data), +y3(d3, i3, data));
    }
    if (buffer)
      return output = null, buffer + "" || null;
  }
  line.x = function(_2) {
    return arguments.length ? (x3 = typeof _2 === "function" ? _2 : constant_default4(+_2), line) : x3;
  };
  line.y = function(_2) {
    return arguments.length ? (y3 = typeof _2 === "function" ? _2 : constant_default4(+_2), line) : y3;
  };
  line.defined = function(_2) {
    return arguments.length ? (defined2 = typeof _2 === "function" ? _2 : constant_default4(!!_2), line) : defined2;
  };
  line.curve = function(_2) {
    return arguments.length ? (curve = _2, context != null && (output = curve(context)), line) : curve;
  };
  line.context = function(_2) {
    return arguments.length ? (_2 == null ? context = output = null : output = curve(context = _2), line) : context;
  };
  return line;
}

// node_modules/d3-shape/src/area.js
function area_default2(x05, y05, y12) {
  var x12 = null, defined2 = constant_default4(true), context = null, curve = linear_default, output = null, path2 = withPath(area);
  x05 = typeof x05 === "function" ? x05 : x05 === void 0 ? x2 : constant_default4(+x05);
  y05 = typeof y05 === "function" ? y05 : y05 === void 0 ? constant_default4(0) : constant_default4(+y05);
  y12 = typeof y12 === "function" ? y12 : y12 === void 0 ? y2 : constant_default4(+y12);
  function area(data) {
    var i3, j3, k4, n2 = (data = array_default(data)).length, d3, defined0 = false, buffer, x0z = new Array(n2), y0z = new Array(n2);
    if (context == null)
      output = curve(buffer = path2());
    for (i3 = 0; i3 <= n2; ++i3) {
      if (!(i3 < n2 && defined2(d3 = data[i3], i3, data)) === defined0) {
        if (defined0 = !defined0) {
          j3 = i3;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k4 = i3 - 1; k4 >= j3; --k4) {
            output.point(x0z[k4], y0z[k4]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i3] = +x05(d3, i3, data), y0z[i3] = +y05(d3, i3, data);
        output.point(x12 ? +x12(d3, i3, data) : x0z[i3], y12 ? +y12(d3, i3, data) : y0z[i3]);
      }
    }
    if (buffer)
      return output = null, buffer + "" || null;
  }
  function arealine() {
    return line_default2().defined(defined2).curve(curve).context(context);
  }
  area.x = function(_2) {
    return arguments.length ? (x05 = typeof _2 === "function" ? _2 : constant_default4(+_2), x12 = null, area) : x05;
  };
  area.x0 = function(_2) {
    return arguments.length ? (x05 = typeof _2 === "function" ? _2 : constant_default4(+_2), area) : x05;
  };
  area.x1 = function(_2) {
    return arguments.length ? (x12 = _2 == null ? null : typeof _2 === "function" ? _2 : constant_default4(+_2), area) : x12;
  };
  area.y = function(_2) {
    return arguments.length ? (y05 = typeof _2 === "function" ? _2 : constant_default4(+_2), y12 = null, area) : y05;
  };
  area.y0 = function(_2) {
    return arguments.length ? (y05 = typeof _2 === "function" ? _2 : constant_default4(+_2), area) : y05;
  };
  area.y1 = function(_2) {
    return arguments.length ? (y12 = _2 == null ? null : typeof _2 === "function" ? _2 : constant_default4(+_2), area) : y12;
  };
  area.lineX0 = area.lineY0 = function() {
    return arealine().x(x05).y(y05);
  };
  area.lineY1 = function() {
    return arealine().x(x05).y(y12);
  };
  area.lineX1 = function() {
    return arealine().x(x12).y(y05);
  };
  area.defined = function(_2) {
    return arguments.length ? (defined2 = typeof _2 === "function" ? _2 : constant_default4(!!_2), area) : defined2;
  };
  area.curve = function(_2) {
    return arguments.length ? (curve = _2, context != null && (output = curve(context)), area) : curve;
  };
  area.context = function(_2) {
    return arguments.length ? (_2 == null ? context = output = null : output = curve(context = _2), area) : context;
  };
  return area;
}

// node_modules/d3-shape/src/symbol/asterisk.js
var sqrt32 = sqrt3(3);
var asterisk_default = {
  draw(context, size) {
    const r3 = sqrt3(size + min3(size / 28, 0.75)) * 0.59436;
    const t4 = r3 / 2;
    const u3 = t4 * sqrt32;
    context.moveTo(0, r3);
    context.lineTo(0, -r3);
    context.moveTo(-u3, -t4);
    context.lineTo(u3, t4);
    context.moveTo(-u3, t4);
    context.lineTo(u3, -t4);
  }
};

// node_modules/d3-shape/src/symbol/circle.js
var circle_default2 = {
  draw(context, size) {
    const r3 = sqrt3(size / pi3);
    context.moveTo(r3, 0);
    context.arc(0, 0, r3, 0, tau3);
  }
};

// node_modules/d3-shape/src/symbol/cross.js
var cross_default = {
  draw(context, size) {
    const r3 = sqrt3(size / 5) / 2;
    context.moveTo(-3 * r3, -r3);
    context.lineTo(-r3, -r3);
    context.lineTo(-r3, -3 * r3);
    context.lineTo(r3, -3 * r3);
    context.lineTo(r3, -r3);
    context.lineTo(3 * r3, -r3);
    context.lineTo(3 * r3, r3);
    context.lineTo(r3, r3);
    context.lineTo(r3, 3 * r3);
    context.lineTo(-r3, 3 * r3);
    context.lineTo(-r3, r3);
    context.lineTo(-3 * r3, r3);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/diamond.js
var tan30 = sqrt3(1 / 3);
var tan30_2 = tan30 * 2;
var diamond_default = {
  draw(context, size) {
    const y3 = sqrt3(size / tan30_2);
    const x3 = y3 * tan30;
    context.moveTo(0, -y3);
    context.lineTo(x3, 0);
    context.lineTo(0, y3);
    context.lineTo(-x3, 0);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/diamond2.js
var diamond2_default = {
  draw(context, size) {
    const r3 = sqrt3(size) * 0.62625;
    context.moveTo(0, -r3);
    context.lineTo(r3, 0);
    context.lineTo(0, r3);
    context.lineTo(-r3, 0);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/plus.js
var plus_default = {
  draw(context, size) {
    const r3 = sqrt3(size - min3(size / 7, 2)) * 0.87559;
    context.moveTo(-r3, 0);
    context.lineTo(r3, 0);
    context.moveTo(0, r3);
    context.lineTo(0, -r3);
  }
};

// node_modules/d3-shape/src/symbol/square.js
var square_default = {
  draw(context, size) {
    const w3 = sqrt3(size);
    const x3 = -w3 / 2;
    context.rect(x3, x3, w3, w3);
  }
};

// node_modules/d3-shape/src/symbol/square2.js
var square2_default = {
  draw(context, size) {
    const r3 = sqrt3(size) * 0.4431;
    context.moveTo(r3, r3);
    context.lineTo(r3, -r3);
    context.lineTo(-r3, -r3);
    context.lineTo(-r3, r3);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/star.js
var ka = 0.8908130915292852;
var kr = sin2(pi3 / 10) / sin2(7 * pi3 / 10);
var kx = sin2(tau3 / 10) * kr;
var ky = -cos2(tau3 / 10) * kr;
var star_default = {
  draw(context, size) {
    const r3 = sqrt3(size * ka);
    const x3 = kx * r3;
    const y3 = ky * r3;
    context.moveTo(0, -r3);
    context.lineTo(x3, y3);
    for (let i3 = 1; i3 < 5; ++i3) {
      const a4 = tau3 * i3 / 5;
      const c6 = cos2(a4);
      const s4 = sin2(a4);
      context.lineTo(s4 * r3, -c6 * r3);
      context.lineTo(c6 * x3 - s4 * y3, s4 * x3 + c6 * y3);
    }
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/triangle.js
var sqrt33 = sqrt3(3);
var triangle_default = {
  draw(context, size) {
    const y3 = -sqrt3(size / (sqrt33 * 3));
    context.moveTo(0, y3 * 2);
    context.lineTo(-sqrt33 * y3, -y3);
    context.lineTo(sqrt33 * y3, -y3);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/triangle2.js
var sqrt34 = sqrt3(3);
var triangle2_default = {
  draw(context, size) {
    const s4 = sqrt3(size) * 0.6824;
    const t4 = s4 / 2;
    const u3 = s4 * sqrt34 / 2;
    context.moveTo(0, -s4);
    context.lineTo(u3, t4);
    context.lineTo(-u3, t4);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/wye.js
var c5 = -0.5;
var s3 = sqrt3(3) / 2;
var k3 = 1 / sqrt3(12);
var a3 = (k3 / 2 + 1) * 3;
var wye_default = {
  draw(context, size) {
    const r3 = sqrt3(size / a3);
    const x05 = r3 / 2, y05 = r3 * k3;
    const x12 = x05, y12 = r3 * k3 + r3;
    const x22 = -x12, y22 = y12;
    context.moveTo(x05, y05);
    context.lineTo(x12, y12);
    context.lineTo(x22, y22);
    context.lineTo(c5 * x05 - s3 * y05, s3 * x05 + c5 * y05);
    context.lineTo(c5 * x12 - s3 * y12, s3 * x12 + c5 * y12);
    context.lineTo(c5 * x22 - s3 * y22, s3 * x22 + c5 * y22);
    context.lineTo(c5 * x05 + s3 * y05, c5 * y05 - s3 * x05);
    context.lineTo(c5 * x12 + s3 * y12, c5 * y12 - s3 * x12);
    context.lineTo(c5 * x22 + s3 * y22, c5 * y22 - s3 * x22);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/times.js
var times_default = {
  draw(context, size) {
    const r3 = sqrt3(size - min3(size / 6, 1.7)) * 0.6189;
    context.moveTo(-r3, -r3);
    context.lineTo(r3, r3);
    context.moveTo(-r3, r3);
    context.lineTo(r3, -r3);
  }
};

// node_modules/d3-shape/src/symbol.js
var symbolsFill = [
  circle_default2,
  cross_default,
  diamond_default,
  square_default,
  star_default,
  triangle_default,
  wye_default
];
var symbolsStroke = [
  circle_default2,
  plus_default,
  times_default,
  triangle2_default,
  asterisk_default,
  square2_default,
  diamond2_default
];

// node_modules/d3-zoom/src/transform.js
function Transform(k4, x3, y3) {
  this.k = k4;
  this.x = x3;
  this.y = y3;
}
Transform.prototype = {
  constructor: Transform,
  scale: function(k4) {
    return k4 === 1 ? this : new Transform(this.k * k4, this.x, this.y);
  },
  translate: function(x3, y3) {
    return x3 === 0 & y3 === 0 ? this : new Transform(this.k, this.x + this.k * x3, this.y + this.k * y3);
  },
  apply: function(point2) {
    return [point2[0] * this.k + this.x, point2[1] * this.k + this.y];
  },
  applyX: function(x3) {
    return x3 * this.k + this.x;
  },
  applyY: function(y3) {
    return y3 * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x3) {
    return (x3 - this.x) / this.k;
  },
  invertY: function(y3) {
    return (y3 - this.y) / this.k;
  },
  rescaleX: function(x3) {
    return x3.copy().domain(x3.range().map(this.invertX, this).map(x3.invert, x3));
  },
  rescaleY: function(y3) {
    return y3.copy().domain(y3.range().map(this.invertY, this).map(y3.invert, y3));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity5 = new Transform(1, 0, 0);
transform.prototype = Transform.prototype;
function transform(node) {
  while (!node.__zoom)
    if (!(node = node.parentNode))
      return identity5;
  return node.__zoom;
}

// node_modules/@observablehq/plot/src/defined.js
function defined(x3) {
  return x3 != null && !Number.isNaN(x3);
}
function ascendingDefined2(a4, b3) {
  return +defined(b3) - +defined(a4) || ascending(a4, b3);
}
function descendingDefined(a4, b3) {
  return +defined(b3) - +defined(a4) || descending(a4, b3);
}
function nonempty(x3) {
  return x3 != null && `${x3}` !== "";
}
function finite(x3) {
  return isFinite(x3) ? x3 : NaN;
}
function positive(x3) {
  return x3 > 0 && isFinite(x3) ? x3 : NaN;
}
function negative(x3) {
  return x3 < 0 && isFinite(x3) ? x3 : NaN;
}

// node_modules/isoformat/src/format.js
function format2(date2, fallback) {
  if (!(date2 instanceof Date))
    date2 = /* @__PURE__ */ new Date(+date2);
  if (isNaN(date2))
    return typeof fallback === "function" ? fallback(date2) : fallback;
  const hours = date2.getUTCHours();
  const minutes = date2.getUTCMinutes();
  const seconds2 = date2.getUTCSeconds();
  const milliseconds2 = date2.getUTCMilliseconds();
  return `${formatYear2(date2.getUTCFullYear(), 4)}-${pad2(date2.getUTCMonth() + 1, 2)}-${pad2(date2.getUTCDate(), 2)}${hours || minutes || seconds2 || milliseconds2 ? `T${pad2(hours, 2)}:${pad2(minutes, 2)}${seconds2 || milliseconds2 ? `:${pad2(seconds2, 2)}${milliseconds2 ? `.${pad2(milliseconds2, 3)}` : ``}` : ``}Z` : ``}`;
}
function formatYear2(year) {
  return year < 0 ? `-${pad2(-year, 6)}` : year > 9999 ? `+${pad2(year, 6)}` : pad2(year, 4);
}
function pad2(value, width) {
  return `${value}`.padStart(width, "0");
}

// node_modules/isoformat/src/parse.js
var re2 = /^(?:[-+]\d{2})?\d{4}(?:-\d{2}(?:-\d{2})?)?(?:T\d{2}:\d{2}(?::\d{2}(?:\.\d{3})?)?(?:Z|[-+]\d{2}:?\d{2})?)?$/;
function parse(string2, fallback) {
  if (!re2.test(string2 += ""))
    return typeof fallback === "function" ? fallback(string2) : fallback;
  return new Date(string2);
}

// node_modules/@observablehq/plot/src/time.js
var durationSecond2 = 1e3;
var durationMinute2 = durationSecond2 * 60;
var durationHour2 = durationMinute2 * 60;
var durationDay2 = durationHour2 * 24;
var durationWeek2 = durationDay2 * 7;
var durationMonth2 = durationDay2 * 30;
var durationYear2 = durationDay2 * 365;
var tickIntervals = [
  ["millisecond", 1],
  ["2 milliseconds", 2],
  ["5 milliseconds", 5],
  ["10 milliseconds", 10],
  ["20 milliseconds", 20],
  ["50 milliseconds", 50],
  ["100 milliseconds", 100],
  ["200 milliseconds", 200],
  ["500 milliseconds", 500],
  ["second", durationSecond2],
  ["5 seconds", 5 * durationSecond2],
  ["15 seconds", 15 * durationSecond2],
  ["30 seconds", 30 * durationSecond2],
  ["minute", durationMinute2],
  ["5 minutes", 5 * durationMinute2],
  ["15 minutes", 15 * durationMinute2],
  ["30 minutes", 30 * durationMinute2],
  ["hour", durationHour2],
  ["3 hours", 3 * durationHour2],
  ["6 hours", 6 * durationHour2],
  ["12 hours", 12 * durationHour2],
  ["day", durationDay2],
  ["2 days", 2 * durationDay2],
  ["week", durationWeek2],
  ["2 weeks", 2 * durationWeek2],
  // https://github.com/d3/d3-time/issues/46
  ["month", durationMonth2],
  ["3 months", 3 * durationMonth2],
  ["6 months", 6 * durationMonth2],
  // https://github.com/d3/d3-time/issues/46
  ["year", durationYear2],
  ["2 years", 2 * durationYear2],
  ["5 years", 5 * durationYear2],
  ["10 years", 10 * durationYear2],
  ["20 years", 20 * durationYear2],
  ["50 years", 50 * durationYear2],
  ["100 years", 100 * durationYear2]
  // TODO generalize to longer time scales
];
var durations = /* @__PURE__ */ new Map([
  ["second", durationSecond2],
  ["minute", durationMinute2],
  ["hour", durationHour2],
  ["day", durationDay2],
  ["monday", durationWeek2],
  ["tuesday", durationWeek2],
  ["wednesday", durationWeek2],
  ["thursday", durationWeek2],
  ["friday", durationWeek2],
  ["saturday", durationWeek2],
  ["sunday", durationWeek2],
  ["week", durationWeek2],
  ["month", durationMonth2],
  ["year", durationYear2]
]);
var timeIntervals = /* @__PURE__ */ new Map([
  ["second", second],
  ["minute", timeMinute],
  ["hour", timeHour],
  ["day", timeDay],
  // https://github.com/d3/d3-time/issues/62
  ["monday", timeMonday],
  ["tuesday", timeTuesday],
  ["wednesday", timeWednesday],
  ["thursday", timeThursday],
  ["friday", timeFriday],
  ["saturday", timeSaturday],
  ["sunday", timeSunday],
  ["week", timeSunday],
  ["month", timeMonth],
  ["year", timeYear]
]);
var utcIntervals = /* @__PURE__ */ new Map([
  ["second", second],
  ["minute", utcMinute],
  ["hour", utcHour],
  ["day", unixDay],
  ["monday", utcMonday],
  ["tuesday", utcTuesday],
  ["wednesday", utcWednesday],
  ["thursday", utcThursday],
  ["friday", utcFriday],
  ["saturday", utcSaturday],
  ["sunday", utcSunday],
  ["week", utcSunday],
  ["month", utcMonth],
  ["year", utcYear]
]);
var intervalDuration = Symbol("intervalDuration");
var intervalType = Symbol("intervalType");
for (const [name, interval2] of timeIntervals) {
  interval2[intervalDuration] = durations.get(name);
  interval2[intervalType] = "time";
}
for (const [name, interval2] of utcIntervals) {
  interval2[intervalDuration] = durations.get(name);
  interval2[intervalType] = "utc";
}
var formatIntervals = [
  ["year", utcYear, "utc"],
  ["year", timeYear, "time"],
  ["month", utcMonth, "utc"],
  ["month", timeMonth, "time"],
  ["day", unixDay, "utc", 6 * durationMonth2],
  ["day", timeDay, "time", 6 * durationMonth2],
  // Below day, local time typically has an hourly offset from UTC and hence the
  // two are aligned and indistinguishable; therefore, we only consider UTC, and
  // we dont consider these if the domain only has a single value.
  ["hour", utcHour, "utc", 3 * durationDay2],
  ["minute", utcMinute, "utc", 6 * durationHour2],
  ["second", second, "utc", 30 * durationMinute2]
];
function parseInterval(input, intervals, type2) {
  let name = `${input}`.toLowerCase();
  if (name.endsWith("s"))
    name = name.slice(0, -1);
  let period = 1;
  const match = /^(?:(\d+)\s+)/.exec(name);
  if (match) {
    name = name.slice(match[0].length);
    period = +match[1];
  }
  switch (name) {
    case "quarter":
      name = "month";
      period *= 3;
      break;
    case "half":
      name = "month";
      period *= 6;
      break;
  }
  let interval2 = intervals.get(name);
  if (!interval2)
    throw new Error(`unknown interval: ${input}`);
  if (period > 1) {
    if (!interval2.every)
      throw new Error(`non-periodic interval: ${name}`);
    interval2 = interval2.every(period);
    interval2[intervalDuration] = durations.get(name) * period;
    interval2[intervalType] = type2;
  }
  return interval2;
}
function maybeTimeInterval(interval2) {
  return parseInterval(interval2, timeIntervals, "time");
}
function maybeUtcInterval(interval2) {
  return parseInterval(interval2, utcIntervals, "utc");
}
function generalizeTimeInterval(interval2, n2) {
  if (!(n2 > 1))
    return;
  const duration = interval2[intervalDuration];
  if (!tickIntervals.some(([, d3]) => d3 === duration))
    return;
  if (duration % durationDay2 === 0 && durationDay2 < duration && duration < durationMonth2)
    return;
  const [i3] = tickIntervals[bisector(([, step]) => Math.log(step)).center(tickIntervals, Math.log(duration * n2))];
  return (interval2[intervalType] === "time" ? maybeTimeInterval : maybeUtcInterval)(i3);
}
function formatTimeInterval(name, type2, anchor) {
  const format3 = type2 === "time" ? timeFormat : utcFormat;
  if (anchor == null) {
    return format3(
      name === "year" ? "%Y" : name === "month" ? "%Y-%m" : name === "day" ? "%Y-%m-%d" : name === "hour" || name === "minute" ? "%Y-%m-%dT%H:%M" : name === "second" ? "%Y-%m-%dT%H:%M:%S" : "%Y-%m-%dT%H:%M:%S.%L"
    );
  }
  const template2 = getTimeTemplate(anchor);
  switch (name) {
    case "millisecond":
      return formatConditional(format3(".%L"), format3(":%M:%S"), template2);
    case "second":
      return formatConditional(format3(":%S"), format3("%-I:%M"), template2);
    case "minute":
      return formatConditional(format3("%-I:%M"), format3("%p"), template2);
    case "hour":
      return formatConditional(format3("%-I %p"), format3("%b %-d"), template2);
    case "day":
      return formatConditional(format3("%-d"), format3("%b"), template2);
    case "month":
      return formatConditional(format3("%b"), format3("%Y"), template2);
    case "year":
      return format3("%Y");
  }
  throw new Error("unable to format time ticks");
}
function getTimeTemplate(anchor) {
  return anchor === "left" || anchor === "right" ? (f1, f22) => `
${f1}
${f22}` : anchor === "top" ? (f1, f22) => `${f22}
${f1}` : (f1, f22) => `${f1}
${f22}`;
}
function inferTimeFormat(dates, anchor) {
  const step = max(pairs(dates, (a4, b3) => Math.abs(b3 - a4)));
  if (step < 1e3)
    return formatTimeInterval("millisecond", "utc", anchor);
  for (const [name, interval2, type2, maxStep] of formatIntervals) {
    if (step > maxStep)
      break;
    if (name === "hour" && !step)
      break;
    if (dates.every((d3) => interval2.floor(d3) >= d3))
      return formatTimeInterval(name, type2, anchor);
  }
}
function formatConditional(format1, format22, template2) {
  return (x3, i3, X3) => {
    const f1 = format1(x3, i3);
    const f22 = format22(x3, i3);
    const j3 = i3 - orderof(X3);
    return i3 !== j3 && X3[j3] !== void 0 && f22 === format22(X3[j3], j3) ? f1 : template2(f1, f22);
  };
}

// node_modules/@observablehq/plot/src/options.js
var TypedArray = Object.getPrototypeOf(Uint8Array);
var objectToString = Object.prototype.toString;
var reindex = Symbol("reindex");
function valueof(data, value, type2) {
  const valueType = typeof value;
  return valueType === "string" ? maybeTypedMap(data, field(value), type2) : valueType === "function" ? maybeTypedMap(data, value, type2) : valueType === "number" || value instanceof Date || valueType === "boolean" ? map2(data, constant(value), type2) : typeof value?.transform === "function" ? maybeTypedArrayify(value.transform(data), type2) : maybeTake(maybeTypedArrayify(value, type2), data?.[reindex]);
}
function maybeTake(values2, index2) {
  return index2 ? take(values2, index2) : values2;
}
function maybeTypedMap(data, f3, type2) {
  return map2(data, type2?.prototype instanceof TypedArray ? floater(f3) : f3, type2);
}
function maybeTypedArrayify(data, type2) {
  return type2 === void 0 ? arrayify2(data) : data instanceof type2 ? data : type2.prototype instanceof TypedArray && !(data instanceof TypedArray) ? type2.from(data, coerceNumber) : type2.from(data);
}
function floater(f3) {
  return (d3, i3) => coerceNumber(f3(d3, i3));
}
var singleton = [null];
var field = (name) => (d3) => d3[name];
var indexOf = { transform: range2 };
var identity6 = { transform: (d3) => d3 };
var yes = () => true;
var string = (x3) => x3 == null ? x3 : `${x3}`;
var number5 = (x3) => x3 == null ? x3 : +x3;
var first = (x3) => x3 ? x3[0] : void 0;
var second2 = (x3) => x3 ? x3[1] : void 0;
var constant = (x3) => () => x3;
function percentile(reduce) {
  const p3 = +`${reduce}`.slice(1) / 100;
  return (I2, f3) => quantile(I2, p3, f3);
}
function coerceNumbers(values2) {
  return values2 instanceof TypedArray ? values2 : map2(values2, coerceNumber, Float64Array);
}
function coerceNumber(x3) {
  return x3 == null ? NaN : Number(x3);
}
function coerceDates(values2) {
  return map2(values2, coerceDate);
}
function coerceDate(x3) {
  return x3 instanceof Date && !isNaN(x3) ? x3 : typeof x3 === "string" ? parse(x3) : x3 == null || isNaN(x3 = +x3) ? void 0 : new Date(x3);
}
function maybeColorChannel(value, defaultValue) {
  if (value === void 0)
    value = defaultValue;
  return value === null ? [void 0, "none"] : isColor(value) ? [void 0, value] : [value, void 0];
}
function maybeNumberChannel(value, defaultValue) {
  if (value === void 0)
    value = defaultValue;
  return value === null || typeof value === "number" ? [void 0, value] : [value, void 0];
}
function maybeKeyword(input, name, allowed) {
  if (input != null)
    return keyword(input, name, allowed);
}
function keyword(input, name, allowed) {
  const i3 = `${input}`.toLowerCase();
  if (!allowed.includes(i3))
    throw new Error(`invalid ${name}: ${input}`);
  return i3;
}
function arrayify2(data) {
  return data == null || data instanceof Array || data instanceof TypedArray ? data : Array.from(data);
}
function map2(values2, f3, type2 = Array) {
  return values2 == null ? values2 : values2 instanceof type2 ? values2.map(f3) : type2.from(values2, f3);
}
function slice2(values2, type2 = Array) {
  return values2 instanceof type2 ? values2.slice() : type2.from(values2);
}
function isObject(option) {
  return option?.toString === objectToString;
}
function isScaleOptions(option) {
  return isObject(option) && (option.type !== void 0 || option.domain !== void 0);
}
function isOptions(option) {
  return isObject(option) && typeof option.transform !== "function";
}
function isDomainSort(sort3) {
  return isOptions(sort3) && sort3.value === void 0 && sort3.channel === void 0;
}
function maybeTuple(x3, y3) {
  return x3 === void 0 && y3 === void 0 ? [first, second2] : [x3, y3];
}
function maybeZ({ z: z3, fill, stroke } = {}) {
  if (z3 === void 0)
    [z3] = maybeColorChannel(fill);
  if (z3 === void 0)
    [z3] = maybeColorChannel(stroke);
  return z3;
}
function range2(data) {
  const n2 = data.length;
  const r3 = new Uint32Array(n2);
  for (let i3 = 0; i3 < n2; ++i3)
    r3[i3] = i3;
  return r3;
}
function take(values2, index2) {
  return map2(index2, (i3) => values2[i3], values2.constructor);
}
function subarray(I2, i3, j3) {
  return I2.subarray ? I2.subarray(i3, j3) : I2.slice(i3, j3);
}
function keyof2(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}
function maybeInput(key, options) {
  if (options[key] !== void 0)
    return options[key];
  switch (key) {
    case "x1":
    case "x2":
      key = "x";
      break;
    case "y1":
    case "y2":
      key = "y";
      break;
  }
  return options[key];
}
function column(source) {
  let value;
  return [
    {
      transform: () => value,
      label: labelof(source)
    },
    (v3) => value = v3
  ];
}
function maybeColumn(source) {
  return source == null ? [source] : column(source);
}
function labelof(value, defaultValue) {
  return typeof value === "string" ? value : value && value.label !== void 0 ? value.label : defaultValue;
}
function mid(x12, x22) {
  return {
    transform(data) {
      const X12 = x12.transform(data);
      const X22 = x22.transform(data);
      return isTemporal(X12) || isTemporal(X22) ? map2(X12, (_2, i3) => new Date((+X12[i3] + +X22[i3]) / 2)) : map2(X12, (_2, i3) => (+X12[i3] + +X22[i3]) / 2, Float64Array);
    },
    label: x12.label
  };
}
function maybeApplyInterval(V, scale) {
  const t4 = maybeIntervalTransform(scale?.interval, scale?.type);
  return t4 ? map2(V, t4) : V;
}
function maybeIntervalTransform(interval2, type2) {
  const i3 = maybeInterval(interval2, type2);
  return i3 && ((v3) => defined(v3) ? i3.floor(v3) : v3);
}
function maybeInterval(interval2, type2) {
  if (interval2 == null)
    return;
  if (typeof interval2 === "number") {
    if (0 < interval2 && interval2 < 1 && Number.isInteger(1 / interval2))
      interval2 = -1 / interval2;
    const n2 = Math.abs(interval2);
    return interval2 < 0 ? {
      floor: (d3) => Math.floor(d3 * n2) / n2,
      offset: (d3) => (d3 * n2 + 1) / n2,
      // note: no optional step for simplicity
      range: (lo, hi) => range(Math.ceil(lo * n2), hi * n2).map((x3) => x3 / n2)
    } : {
      floor: (d3) => Math.floor(d3 / n2) * n2,
      offset: (d3) => d3 + n2,
      // note: no optional step for simplicity
      range: (lo, hi) => range(Math.ceil(lo / n2), hi / n2).map((x3) => x3 * n2)
    };
  }
  if (typeof interval2 === "string")
    return (type2 === "time" ? maybeTimeInterval : maybeUtcInterval)(interval2);
  if (typeof interval2.floor !== "function")
    throw new Error("invalid interval; missing floor method");
  if (typeof interval2.offset !== "function")
    throw new Error("invalid interval; missing offset method");
  return interval2;
}
function maybeRangeInterval(interval2, type2) {
  interval2 = maybeInterval(interval2, type2);
  if (interval2 && typeof interval2.range !== "function")
    throw new Error("invalid interval: missing range method");
  return interval2;
}
function maybeNiceInterval(interval2, type2) {
  interval2 = maybeRangeInterval(interval2, type2);
  if (interval2 && typeof interval2.ceil !== "function")
    throw new Error("invalid interval: missing ceil method");
  return interval2;
}
function isTimeInterval(t4) {
  return isInterval(t4) && typeof t4?.floor === "function" && t4.floor() instanceof Date;
}
function isInterval(t4) {
  return typeof t4?.range === "function";
}
function maybeValue(value) {
  return value === void 0 || isOptions(value) ? value : { value };
}
function numberChannel(source) {
  return source == null ? null : {
    transform: (data) => valueof(data, source, Float64Array),
    label: labelof(source)
  };
}
function isIterable(value) {
  return value && typeof value[Symbol.iterator] === "function";
}
function isTextual(values2) {
  for (const value of values2) {
    if (value == null)
      continue;
    return typeof value !== "object" || value instanceof Date;
  }
}
function isOrdinal(values2) {
  for (const value of values2) {
    if (value == null)
      continue;
    const type2 = typeof value;
    return type2 === "string" || type2 === "boolean";
  }
}
function isTemporal(values2) {
  for (const value of values2) {
    if (value == null)
      continue;
    return value instanceof Date;
  }
}
function isTemporalString(values2) {
  for (const value of values2) {
    if (value == null)
      continue;
    return typeof value === "string" && isNaN(value) && parse(value);
  }
}
function isNumericString(values2) {
  for (const value of values2) {
    if (value == null)
      continue;
    if (typeof value !== "string")
      return false;
    if (!value.trim())
      continue;
    return !isNaN(value);
  }
}
function isNumeric(values2) {
  for (const value of values2) {
    if (value == null)
      continue;
    return typeof value === "number";
  }
}
function isEvery(values2, is) {
  let every;
  for (const value of values2) {
    if (value == null)
      continue;
    if (!is(value))
      return false;
    every = true;
  }
  return every;
}
var namedColors = new Set("none,currentcolor,transparent,aliceblue,antiquewhite,aqua,aquamarine,azure,beige,bisque,black,blanchedalmond,blue,blueviolet,brown,burlywood,cadetblue,chartreuse,chocolate,coral,cornflowerblue,cornsilk,crimson,cyan,darkblue,darkcyan,darkgoldenrod,darkgray,darkgreen,darkgrey,darkkhaki,darkmagenta,darkolivegreen,darkorange,darkorchid,darkred,darksalmon,darkseagreen,darkslateblue,darkslategray,darkslategrey,darkturquoise,darkviolet,deeppink,deepskyblue,dimgray,dimgrey,dodgerblue,firebrick,floralwhite,forestgreen,fuchsia,gainsboro,ghostwhite,gold,goldenrod,gray,green,greenyellow,grey,honeydew,hotpink,indianred,indigo,ivory,khaki,lavender,lavenderblush,lawngreen,lemonchiffon,lightblue,lightcoral,lightcyan,lightgoldenrodyellow,lightgray,lightgreen,lightgrey,lightpink,lightsalmon,lightseagreen,lightskyblue,lightslategray,lightslategrey,lightsteelblue,lightyellow,lime,limegreen,linen,magenta,maroon,mediumaquamarine,mediumblue,mediumorchid,mediumpurple,mediumseagreen,mediumslateblue,mediumspringgreen,mediumturquoise,mediumvioletred,midnightblue,mintcream,mistyrose,moccasin,navajowhite,navy,oldlace,olive,olivedrab,orange,orangered,orchid,palegoldenrod,palegreen,paleturquoise,palevioletred,papayawhip,peachpuff,peru,pink,plum,powderblue,purple,rebeccapurple,red,rosybrown,royalblue,saddlebrown,salmon,sandybrown,seagreen,seashell,sienna,silver,skyblue,slateblue,slategray,slategrey,snow,springgreen,steelblue,tan,teal,thistle,tomato,turquoise,violet,wheat,white,whitesmoke,yellow".split(","));
function isColor(value) {
  if (typeof value !== "string")
    return false;
  value = value.toLowerCase().trim();
  return /^#[0-9a-f]{3,8}$/.test(value) || // hex rgb, rgba, rrggbb, rrggbbaa
  /^(?:url|var|rgb|rgba|hsl|hsla|hwb|lab|lch|oklab|oklch|color|color-mix)\(.*\)$/.test(value) || // <funciri>, CSS variable, color, etc.
  namedColors.has(value);
}
function isOpacity(value) {
  return typeof value === "number" && (0 <= value && value <= 1 || isNaN(value));
}
function isNoneish(value) {
  return value == null || isNone(value);
}
function isNone(value) {
  return /^\s*none\s*$/i.test(value);
}
function isRound(value) {
  return /^\s*round\s*$/i.test(value);
}
function maybeAnchor(value, name) {
  return maybeKeyword(value, name, [
    "middle",
    "top-left",
    "top",
    "top-right",
    "right",
    "bottom-right",
    "bottom",
    "bottom-left",
    "left"
  ]);
}
function maybeFrameAnchor(value = "middle") {
  return maybeAnchor(value, "frameAnchor");
}
function orderof(values2) {
  if (values2 == null)
    return;
  const first2 = values2[0];
  const last = values2[values2.length - 1];
  return descending(first2, last);
}
function inherit2(options = {}, ...rest) {
  let o3 = options;
  for (const defaults8 of rest) {
    for (const key in defaults8) {
      if (o3[key] === void 0) {
        const value = defaults8[key];
        if (o3 === options)
          o3 = { ...o3, [key]: value };
        else
          o3[key] = value;
      }
    }
  }
  return o3;
}
function named2(things) {
  console.warn("named iterables are deprecated; please use an object instead");
  const names = /* @__PURE__ */ new Set();
  return Object.fromEntries(
    Array.from(things, (thing) => {
      const { name } = thing;
      if (name == null)
        throw new Error("missing name");
      const key = `${name}`;
      if (key === "__proto__")
        throw new Error(`illegal name: ${key}`);
      if (names.has(key))
        throw new Error(`duplicate name: ${key}`);
      names.add(key);
      return [name, thing];
    })
  );
}
function maybeNamed(things) {
  return isIterable(things) ? named2(things) : things;
}

// node_modules/@observablehq/plot/src/scales/index.js
var position = Symbol("position");
var color2 = Symbol("color");
var radius = Symbol("radius");
var length2 = Symbol("length");
var opacity = Symbol("opacity");
var symbol = Symbol("symbol");
var projection2 = Symbol("projection");
var registry = /* @__PURE__ */ new Map([
  ["x", position],
  ["y", position],
  ["fx", position],
  ["fy", position],
  ["r", radius],
  ["color", color2],
  ["opacity", opacity],
  ["symbol", symbol],
  ["length", length2],
  ["projection", projection2]
]);
function isPosition(kind) {
  return kind === position || kind === projection2;
}
function hasNumericRange(kind) {
  return kind === position || kind === radius || kind === length2 || kind === opacity;
}

// node_modules/@observablehq/plot/src/symbol.js
var sqrt35 = Math.sqrt(3);
var sqrt4_3 = 2 / sqrt35;
var symbolHexagon = {
  draw(context, size) {
    const rx = Math.sqrt(size / Math.PI), ry = rx * sqrt4_3, hy = ry / 2;
    context.moveTo(0, ry);
    context.lineTo(rx, hy);
    context.lineTo(rx, -hy);
    context.lineTo(0, -ry);
    context.lineTo(-rx, -hy);
    context.lineTo(-rx, hy);
    context.closePath();
  }
};
var symbols = /* @__PURE__ */ new Map([
  ["asterisk", asterisk_default],
  ["circle", circle_default2],
  ["cross", cross_default],
  ["diamond", diamond_default],
  ["diamond2", diamond2_default],
  ["hexagon", symbolHexagon],
  ["plus", plus_default],
  ["square", square_default],
  ["square2", square2_default],
  ["star", star_default],
  ["times", times_default],
  ["triangle", triangle_default],
  ["triangle2", triangle2_default],
  ["wye", wye_default]
]);
function isSymbolObject(value) {
  return value && typeof value.draw === "function";
}
function isSymbol(value) {
  if (isSymbolObject(value))
    return true;
  if (typeof value !== "string")
    return false;
  return symbols.has(value.toLowerCase());
}
function maybeSymbol(symbol2) {
  if (symbol2 == null || isSymbolObject(symbol2))
    return symbol2;
  const value = symbols.get(`${symbol2}`.toLowerCase());
  if (value)
    return value;
  throw new Error(`invalid symbol: ${symbol2}`);
}
function maybeSymbolChannel(symbol2) {
  if (symbol2 == null || isSymbolObject(symbol2))
    return [void 0, symbol2];
  if (typeof symbol2 === "string") {
    const value = symbols.get(`${symbol2}`.toLowerCase());
    if (value)
      return [void 0, value];
  }
  return [symbol2, void 0];
}

// node_modules/@observablehq/plot/src/transforms/basic.js
function basic({ filter: f1, sort: s1, reverse: r1, transform: t13, initializer: i1, ...options } = {}, transform2) {
  if (t13 === void 0) {
    if (f1 != null)
      t13 = filterTransform(f1);
    if (s1 != null && !isDomainSort(s1))
      t13 = composeTransform(t13, sortTransform(s1));
    if (r1)
      t13 = composeTransform(t13, reverseTransform);
  }
  if (transform2 != null && i1 != null)
    throw new Error("transforms cannot be applied after initializers");
  return {
    ...options,
    ...(s1 === null || isDomainSort(s1)) && { sort: s1 },
    transform: composeTransform(t13, transform2)
  };
}
function initializer({ filter: f1, sort: s1, reverse: r1, initializer: i1, ...options } = {}, initializer2) {
  if (i1 === void 0) {
    if (f1 != null)
      i1 = filterTransform(f1);
    if (s1 != null && !isDomainSort(s1))
      i1 = composeInitializer(i1, sortTransform(s1));
    if (r1)
      i1 = composeInitializer(i1, reverseTransform);
  }
  return {
    ...options,
    ...(s1 === null || isDomainSort(s1)) && { sort: s1 },
    initializer: composeInitializer(i1, initializer2)
  };
}
function composeTransform(t13, t23) {
  if (t13 == null)
    return t23 === null ? void 0 : t23;
  if (t23 == null)
    return t13 === null ? void 0 : t13;
  return function(data, facets, plotOptions) {
    ({ data, facets } = t13.call(this, data, facets, plotOptions));
    return t23.call(this, arrayify2(data), facets, plotOptions);
  };
}
function composeInitializer(i1, i22) {
  if (i1 == null)
    return i22 === null ? void 0 : i22;
  if (i22 == null)
    return i1 === null ? void 0 : i1;
  return function(data, facets, channels, ...args) {
    let c1, d1, f1, c22, d22, f22;
    ({ data: d1 = data, facets: f1 = facets, channels: c1 } = i1.call(this, data, facets, channels, ...args));
    ({ data: d22 = d1, facets: f22 = f1, channels: c22 } = i22.call(this, d1, f1, { ...channels, ...c1 }, ...args));
    return { data: d22, facets: f22, channels: { ...c1, ...c22 } };
  };
}
function apply(options, t4) {
  return (options.initializer != null ? initializer : basic)(options, t4);
}
function filterTransform(value) {
  return (data, facets) => {
    const V = valueof(data, value);
    return { data, facets: facets.map((I2) => I2.filter((i3) => V[i3])) };
  };
}
function reverseTransform(data, facets) {
  return { data, facets: facets.map((I2) => I2.slice().reverse()) };
}
function sort2(order, { sort: sort3, ...options } = {}) {
  return {
    ...(isOptions(order) && order.channel !== void 0 ? initializer : apply)(options, sortTransform(order)),
    sort: isDomainSort(sort3) ? sort3 : null
  };
}
function sortTransform(value) {
  return (typeof value === "function" && value.length !== 1 ? sortData : sortValue)(value);
}
function sortData(compare) {
  return (data, facets) => {
    const compareData = (i3, j3) => compare(data[i3], data[j3]);
    return { data, facets: facets.map((I2) => I2.slice().sort(compareData)) };
  };
}
function sortValue(value) {
  let channel, order;
  ({ channel, value, order } = { ...maybeValue(value) });
  const negate = channel?.startsWith("-");
  if (negate)
    channel = channel.slice(1);
  if (order === void 0)
    order = negate ? descendingDefined : ascendingDefined2;
  if (typeof order !== "function") {
    switch (`${order}`.toLowerCase()) {
      case "ascending":
        order = ascendingDefined2;
        break;
      case "descending":
        order = descendingDefined;
        break;
      default:
        throw new Error(`invalid order: ${order}`);
    }
  }
  return (data, facets, channels) => {
    let V;
    if (channel === void 0) {
      V = valueof(data, value);
    } else {
      if (channels === void 0)
        throw new Error("channel sort requires an initializer");
      V = channels[channel];
      if (!V)
        return {};
      V = V.value;
    }
    const compareValue = (i3, j3) => order(V[i3], V[j3]);
    return { data, facets: facets.map((I2) => I2.slice().sort(compareValue)) };
  };
}

// node_modules/@observablehq/plot/src/transforms/group.js
function hasOutput(outputs, ...names) {
  for (const { name } of outputs) {
    if (names.includes(name)) {
      return true;
    }
  }
  return false;
}
function maybeOutputs(outputs, inputs, asOutput = maybeOutput) {
  const entries = Object.entries(outputs);
  if (inputs.title != null && outputs.title === void 0)
    entries.push(["title", reduceTitle]);
  if (inputs.href != null && outputs.href === void 0)
    entries.push(["href", reduceFirst]);
  return entries.filter(([, reduce]) => reduce !== void 0).map(([name, reduce]) => reduce === null ? nullOutput(name) : asOutput(name, reduce, inputs));
}
function maybeOutput(name, reduce, inputs, asEvaluator = maybeEvaluator) {
  let scale;
  if (isObject(reduce) && "reduce" in reduce)
    scale = reduce.scale, reduce = reduce.reduce;
  const evaluator = asEvaluator(name, reduce, inputs);
  const [output, setOutput] = column(evaluator.label);
  let O2;
  return {
    name,
    output: scale === void 0 ? output : { value: output, scale },
    initialize(data) {
      evaluator.initialize(data);
      O2 = setOutput([]);
    },
    scope(scope, I2) {
      evaluator.scope(scope, I2);
    },
    reduce(I2, extent2) {
      O2.push(evaluator.reduce(I2, extent2));
    }
  };
}
function nullOutput(name) {
  return { name, initialize() {
  }, scope() {
  }, reduce() {
  } };
}
function maybeEvaluator(name, reduce, inputs, asReduce = maybeReduce) {
  const input = maybeInput(name, inputs);
  const reducer2 = asReduce(reduce, input);
  let V, context;
  return {
    label: labelof(reducer2 === reduceCount ? null : input, reducer2.label),
    initialize(data) {
      V = input === void 0 ? data : valueof(data, input);
      if (reducer2.scope === "data") {
        context = reducer2.reduceIndex(range2(data), V);
      }
    },
    scope(scope, I2) {
      if (reducer2.scope === scope) {
        context = reducer2.reduceIndex(I2, V);
      }
    },
    reduce(I2, extent2) {
      return reducer2.scope == null ? reducer2.reduceIndex(I2, V, extent2) : reducer2.reduceIndex(I2, V, context, extent2);
    }
  };
}
function maybeGroup(I2, X3) {
  return X3 ? sort(
    group(I2, (i3) => X3[i3]),
    first
  ) : [[, I2]];
}
function maybeReduce(reduce, value, fallback = invalidReduce) {
  if (reduce == null)
    return fallback(reduce);
  if (typeof reduce.reduceIndex === "function")
    return reduce;
  if (typeof reduce.reduce === "function" && isObject(reduce))
    return reduceReduce(reduce);
  if (typeof reduce === "function")
    return reduceFunction(reduce);
  if (/^p\d{2}$/i.test(reduce))
    return reduceAccessor(percentile(reduce));
  switch (`${reduce}`.toLowerCase()) {
    case "first":
      return reduceFirst;
    case "last":
      return reduceLast;
    case "identity":
      return reduceIdentity;
    case "count":
      return reduceCount;
    case "distinct":
      return reduceDistinct;
    case "sum":
      return value == null ? reduceCount : reduceSum;
    case "proportion":
      return reduceProportion(value, "data");
    case "proportion-facet":
      return reduceProportion(value, "facet");
    case "deviation":
      return reduceAccessor(deviation);
    case "min":
      return reduceAccessor(min);
    case "min-index":
      return reduceAccessor(minIndex);
    case "max":
      return reduceAccessor(max);
    case "max-index":
      return reduceAccessor(maxIndex);
    case "mean":
      return reduceMaybeTemporalAccessor(mean);
    case "median":
      return reduceMaybeTemporalAccessor(median);
    case "variance":
      return reduceAccessor(variance);
    case "mode":
      return reduceAccessor(mode);
  }
  return fallback(reduce);
}
function invalidReduce(reduce) {
  throw new Error(`invalid reduce: ${reduce}`);
}
function maybeSubgroup(outputs, inputs) {
  for (const name in inputs) {
    const value = inputs[name];
    if (value !== void 0 && !outputs.some((o3) => o3.name === name)) {
      return value;
    }
  }
}
function maybeSort(facets, sort3, reverse2) {
  if (sort3) {
    const S2 = sort3.output.transform();
    const compare = (i3, j3) => ascendingDefined2(S2[i3], S2[j3]);
    facets.forEach((f3) => f3.sort(compare));
  }
  if (reverse2) {
    facets.forEach((f3) => f3.reverse());
  }
}
function reduceReduce(reduce) {
  console.warn("deprecated reduce interface; implement reduceIndex instead.");
  return { ...reduce, reduceIndex: reduce.reduce.bind(reduce) };
}
function reduceFunction(f3) {
  return {
    reduceIndex(I2, X3, extent2) {
      return f3(take(X3, I2), extent2);
    }
  };
}
function reduceAccessor(f3) {
  return {
    reduceIndex(I2, X3) {
      return f3(I2, (i3) => X3[i3]);
    }
  };
}
function reduceMaybeTemporalAccessor(f3) {
  return {
    reduceIndex(I2, X3) {
      const x3 = f3(I2, (i3) => X3[i3]);
      return isTemporal(X3) ? new Date(x3) : x3;
    }
  };
}
var reduceIdentity = {
  reduceIndex(I2, X3) {
    return take(X3, I2);
  }
};
var reduceFirst = {
  reduceIndex(I2, X3) {
    return X3[I2[0]];
  }
};
var reduceTitle = {
  reduceIndex(I2, X3) {
    const n2 = 5;
    const groups2 = sort(
      rollup(
        I2,
        (V) => V.length,
        (i3) => X3[i3]
      ),
      second2
    );
    const top2 = groups2.slice(-n2).reverse();
    if (top2.length < groups2.length) {
      const bottom2 = groups2.slice(0, 1 - n2);
      top2[n2 - 1] = [`\u2026 ${bottom2.length.toLocaleString("en-US")} more`, sum(bottom2, second2)];
    }
    return top2.map(([key, value]) => `${key} (${value.toLocaleString("en-US")})`).join("\n");
  }
};
var reduceLast = {
  reduceIndex(I2, X3) {
    return X3[I2[I2.length - 1]];
  }
};
var reduceCount = {
  label: "Frequency",
  reduceIndex(I2) {
    return I2.length;
  }
};
var reduceDistinct = {
  label: "Distinct",
  reduceIndex(I2, X3) {
    const s4 = new InternSet();
    for (const i3 of I2)
      s4.add(X3[i3]);
    return s4.size;
  }
};
var reduceSum = reduceAccessor(sum);
function reduceProportion(value, scope) {
  return value == null ? { scope, label: "Frequency", reduceIndex: (I2, V, basis2 = 1) => I2.length / basis2 } : { scope, reduceIndex: (I2, V, basis2 = 1) => sum(I2, (i3) => V[i3]) / basis2 };
}

// node_modules/@observablehq/plot/src/channel.js
function createChannel(data, { scale, type: type2, value, filter: filter2, hint, label = labelof(value) }, name) {
  if (hint === void 0 && typeof value?.transform === "function")
    hint = value.hint;
  return inferChannelScale(name, {
    scale,
    type: type2,
    value: valueof(data, value),
    label,
    filter: filter2,
    hint
  });
}
function createChannels(channels, data) {
  return Object.fromEntries(
    Object.entries(channels).map(([name, channel]) => [name, createChannel(data, channel, name)])
  );
}
function valueObject(channels, scales) {
  const values2 = Object.fromEntries(
    Object.entries(channels).map(([name, { scale: scaleName, value }]) => {
      const scale = scaleName == null ? null : scales[scaleName];
      return [name, scale == null ? value : map2(value, scale)];
    })
  );
  values2.channels = channels;
  return values2;
}
function inferChannelScale(name, channel) {
  const { scale, value } = channel;
  if (scale === true || scale === "auto") {
    switch (name) {
      case "fill":
      case "stroke":
      case "color":
        channel.scale = scale !== true && isEvery(value, isColor) ? null : "color";
        break;
      case "fillOpacity":
      case "strokeOpacity":
      case "opacity":
        channel.scale = scale !== true && isEvery(value, isOpacity) ? null : "opacity";
        break;
      case "symbol":
        if (scale !== true && isEvery(value, isSymbol)) {
          channel.scale = null;
          channel.value = map2(value, maybeSymbol);
        } else {
          channel.scale = "symbol";
        }
        break;
      default:
        channel.scale = registry.has(name) ? name : null;
        break;
    }
  } else if (scale === false) {
    channel.scale = null;
  } else if (scale != null && !registry.has(scale)) {
    throw new Error(`unknown scale: ${scale}`);
  }
  return channel;
}
function channelDomain(data, facets, channels, facetChannels, options) {
  const { order: defaultOrder, reverse: defaultReverse, reduce: defaultReduce = true, limit: defaultLimit } = options;
  for (const x3 in options) {
    if (!registry.has(x3))
      continue;
    let { value: y3, order = defaultOrder, reverse: reverse2 = defaultReverse, reduce = defaultReduce, limit = defaultLimit } = maybeValue(options[x3]);
    const negate = y3?.startsWith("-");
    if (negate)
      y3 = y3.slice(1);
    order = order === void 0 ? negate !== (y3 === "width" || y3 === "height") ? descendingGroup : ascendingGroup : maybeOrder(order);
    if (reduce == null || reduce === false)
      continue;
    const X3 = x3 === "fx" || x3 === "fy" ? reindexFacetChannel(facets, facetChannels[x3]) : findScaleChannel(channels, x3);
    if (!X3)
      throw new Error(`missing channel for scale: ${x3}`);
    const XV = X3.value;
    const [lo = 0, hi = Infinity] = isIterable(limit) ? limit : limit < 0 ? [limit] : [0, limit];
    if (y3 == null) {
      X3.domain = () => {
        let domain = Array.from(new InternSet(XV));
        if (reverse2)
          domain = domain.reverse();
        if (lo !== 0 || hi !== Infinity)
          domain = domain.slice(lo, hi);
        return domain;
      };
    } else {
      const YV = y3 === "data" ? data : y3 === "height" ? difference(channels, "y1", "y2") : y3 === "width" ? difference(channels, "x1", "x2") : values(channels, y3, y3 === "y" ? "y2" : y3 === "x" ? "x2" : void 0);
      const reducer2 = maybeReduce(reduce === true ? "max" : reduce, YV);
      X3.domain = () => {
        let domain = rollups(
          range2(XV),
          (I2) => reducer2.reduceIndex(I2, YV),
          (i3) => XV[i3]
        );
        if (order)
          domain.sort(order);
        if (reverse2)
          domain.reverse();
        if (lo !== 0 || hi !== Infinity)
          domain = domain.slice(lo, hi);
        return domain.map(first);
      };
    }
  }
}
function findScaleChannel(channels, scale) {
  for (const name in channels) {
    const channel = channels[name];
    if (channel.scale === scale)
      return channel;
  }
}
function reindexFacetChannel(facets, channel) {
  const originalFacets = facets.original;
  if (originalFacets === facets)
    return channel;
  const V1 = channel.value;
  const V2 = channel.value = [];
  for (let i3 = 0; i3 < originalFacets.length; ++i3) {
    const vi = V1[originalFacets[i3][0]];
    for (const j3 of facets[i3])
      V2[j3] = vi;
  }
  return channel;
}
function difference(channels, k1, k22) {
  const X12 = values(channels, k1);
  const X22 = values(channels, k22);
  return map2(X22, (x22, i3) => Math.abs(x22 - X12[i3]), Float64Array);
}
function values(channels, name, alias) {
  let channel = channels[name];
  if (!channel && alias !== void 0)
    channel = channels[alias];
  if (channel)
    return channel.value;
  throw new Error(`missing channel: ${name}`);
}
function maybeOrder(order) {
  if (order == null || typeof order === "function")
    return order;
  switch (`${order}`.toLowerCase()) {
    case "ascending":
      return ascendingGroup;
    case "descending":
      return descendingGroup;
  }
  throw new Error(`invalid order: ${order}`);
}
function ascendingGroup([ak, av], [bk, bv]) {
  return ascendingDefined2(av, bv) || ascendingDefined2(ak, bk);
}
function descendingGroup([ak, av], [bk, bv]) {
  return descendingDefined(av, bv) || ascendingDefined2(ak, bk);
}
function getSource(channels, key) {
  let channel = channels[key];
  if (!channel)
    return;
  while (channel.source)
    channel = channel.source;
  return channel.source === null ? null : channel;
}

// node_modules/@observablehq/plot/src/memoize.js
function memoize1(compute) {
  let cacheValue, cacheKeys;
  return (...keys) => {
    if (cacheKeys?.length !== keys.length || cacheKeys.some((k4, i3) => k4 !== keys[i3])) {
      cacheKeys = keys;
      cacheValue = compute(...keys);
    }
    return cacheValue;
  };
}

// node_modules/@observablehq/plot/src/format.js
var numberFormat = memoize1((locale3) => {
  return new Intl.NumberFormat(locale3);
});
var monthFormat = memoize1((locale3, month) => {
  return new Intl.DateTimeFormat(locale3, { timeZone: "UTC", ...month && { month } });
});
var weekdayFormat = memoize1((locale3, weekday) => {
  return new Intl.DateTimeFormat(locale3, { timeZone: "UTC", ...weekday && { weekday } });
});
function formatNumber(locale3 = "en-US") {
  const format3 = numberFormat(locale3);
  return (i3) => i3 != null && !isNaN(i3) ? format3.format(i3) : void 0;
}
function formatIsoDate(date2) {
  return format2(date2, "Invalid Date");
}
function formatAuto(locale3 = "en-US") {
  const number6 = formatNumber(locale3);
  return (v3) => (v3 instanceof Date ? formatIsoDate : typeof v3 === "number" ? number6 : string)(v3);
}
var formatDefault = formatAuto();

// node_modules/@observablehq/plot/src/warnings.js
var warnings = 0;
var lastMessage;
function consumeWarnings() {
  const w3 = warnings;
  warnings = 0;
  lastMessage = void 0;
  return w3;
}
function warn(message) {
  if (message === lastMessage)
    return;
  lastMessage = message;
  console.warn(message);
  ++warnings;
}

// node_modules/@observablehq/plot/src/style.js
var offset = (typeof window !== "undefined" ? window.devicePixelRatio > 1 : typeof it === "undefined") ? 0 : 0.5;
var nextClipId = 0;
function getClipId() {
  return `plot-clip-${++nextClipId}`;
}
function styles(mark, {
  title,
  href,
  ariaLabel: variaLabel,
  ariaDescription,
  ariaHidden,
  target,
  fill,
  fillOpacity,
  stroke,
  strokeWidth,
  strokeOpacity,
  strokeLinejoin,
  strokeLinecap,
  strokeMiterlimit,
  strokeDasharray,
  strokeDashoffset,
  opacity: opacity2,
  mixBlendMode,
  imageFilter,
  paintOrder,
  pointerEvents,
  shapeRendering,
  channels
}, {
  ariaLabel: cariaLabel,
  fill: defaultFill = "currentColor",
  fillOpacity: defaultFillOpacity,
  stroke: defaultStroke = "none",
  strokeOpacity: defaultStrokeOpacity,
  strokeWidth: defaultStrokeWidth,
  strokeLinecap: defaultStrokeLinecap,
  strokeLinejoin: defaultStrokeLinejoin,
  strokeMiterlimit: defaultStrokeMiterlimit,
  paintOrder: defaultPaintOrder
}) {
  if (defaultFill === null) {
    fill = null;
    fillOpacity = null;
  }
  if (defaultStroke === null) {
    stroke = null;
    strokeOpacity = null;
  }
  if (isNoneish(defaultFill)) {
    if (!isNoneish(defaultStroke) && (!isNoneish(fill) || channels?.fill))
      defaultStroke = "none";
  } else {
    if (isNoneish(defaultStroke) && (!isNoneish(stroke) || channels?.stroke))
      defaultFill = "none";
  }
  const [vfill, cfill] = maybeColorChannel(fill, defaultFill);
  const [vfillOpacity, cfillOpacity] = maybeNumberChannel(fillOpacity, defaultFillOpacity);
  const [vstroke, cstroke] = maybeColorChannel(stroke, defaultStroke);
  const [vstrokeOpacity, cstrokeOpacity] = maybeNumberChannel(strokeOpacity, defaultStrokeOpacity);
  const [vopacity, copacity] = maybeNumberChannel(opacity2);
  if (!isNone(cstroke)) {
    if (strokeWidth === void 0)
      strokeWidth = defaultStrokeWidth;
    if (strokeLinecap === void 0)
      strokeLinecap = defaultStrokeLinecap;
    if (strokeLinejoin === void 0)
      strokeLinejoin = defaultStrokeLinejoin;
    if (strokeMiterlimit === void 0 && !isRound(strokeLinejoin))
      strokeMiterlimit = defaultStrokeMiterlimit;
    if (!isNone(cfill) && paintOrder === void 0)
      paintOrder = defaultPaintOrder;
  }
  const [vstrokeWidth, cstrokeWidth] = maybeNumberChannel(strokeWidth);
  if (defaultFill !== null) {
    mark.fill = impliedString(cfill, "currentColor");
    mark.fillOpacity = impliedNumber(cfillOpacity, 1);
  }
  if (defaultStroke !== null) {
    mark.stroke = impliedString(cstroke, "none");
    mark.strokeWidth = impliedNumber(cstrokeWidth, 1);
    mark.strokeOpacity = impliedNumber(cstrokeOpacity, 1);
    mark.strokeLinejoin = impliedString(strokeLinejoin, "miter");
    mark.strokeLinecap = impliedString(strokeLinecap, "butt");
    mark.strokeMiterlimit = impliedNumber(strokeMiterlimit, 4);
    mark.strokeDasharray = impliedString(strokeDasharray, "none");
    mark.strokeDashoffset = impliedString(strokeDashoffset, "0");
  }
  mark.target = string(target);
  mark.ariaLabel = string(cariaLabel);
  mark.ariaDescription = string(ariaDescription);
  mark.ariaHidden = string(ariaHidden);
  mark.opacity = impliedNumber(copacity, 1);
  mark.mixBlendMode = impliedString(mixBlendMode, "normal");
  mark.imageFilter = impliedString(imageFilter, "none");
  mark.paintOrder = impliedString(paintOrder, "normal");
  mark.pointerEvents = impliedString(pointerEvents, "auto");
  mark.shapeRendering = impliedString(shapeRendering, "auto");
  return {
    title: { value: title, optional: true, filter: null },
    href: { value: href, optional: true, filter: null },
    ariaLabel: { value: variaLabel, optional: true, filter: null },
    fill: { value: vfill, scale: "auto", optional: true },
    fillOpacity: { value: vfillOpacity, scale: "auto", optional: true },
    stroke: { value: vstroke, scale: "auto", optional: true },
    strokeOpacity: { value: vstrokeOpacity, scale: "auto", optional: true },
    strokeWidth: { value: vstrokeWidth, optional: true },
    opacity: { value: vopacity, scale: "auto", optional: true }
  };
}
function applyTitle(selection2, L2) {
  if (L2)
    selection2.filter((i3) => nonempty(L2[i3])).append("title").call(applyText, L2);
}
function applyTitleGroup(selection2, L2) {
  if (L2)
    selection2.filter(([i3]) => nonempty(L2[i3])).append("title").call(applyTextGroup, L2);
}
function applyText(selection2, T2) {
  if (T2)
    selection2.text((i3) => formatDefault(T2[i3]));
}
function applyTextGroup(selection2, T2) {
  if (T2)
    selection2.text(([i3]) => formatDefault(T2[i3]));
}
function applyChannelStyles(selection2, { target, tip: tip2 }, {
  ariaLabel: AL,
  title: T2,
  fill: F2,
  fillOpacity: FO,
  stroke: S2,
  strokeOpacity: SO,
  strokeWidth: SW,
  opacity: O2,
  href: H2
}) {
  if (AL)
    applyAttr(selection2, "aria-label", (i3) => AL[i3]);
  if (F2)
    applyAttr(selection2, "fill", (i3) => F2[i3]);
  if (FO)
    applyAttr(selection2, "fill-opacity", (i3) => FO[i3]);
  if (S2)
    applyAttr(selection2, "stroke", (i3) => S2[i3]);
  if (SO)
    applyAttr(selection2, "stroke-opacity", (i3) => SO[i3]);
  if (SW)
    applyAttr(selection2, "stroke-width", (i3) => SW[i3]);
  if (O2)
    applyAttr(selection2, "opacity", (i3) => O2[i3]);
  if (H2)
    applyHref(selection2, (i3) => H2[i3], target);
  if (!tip2)
    applyTitle(selection2, T2);
}
function applyGroupedChannelStyles(selection2, { target, tip: tip2 }, {
  ariaLabel: AL,
  title: T2,
  fill: F2,
  fillOpacity: FO,
  stroke: S2,
  strokeOpacity: SO,
  strokeWidth: SW,
  opacity: O2,
  href: H2
}) {
  if (AL)
    applyAttr(selection2, "aria-label", ([i3]) => AL[i3]);
  if (F2)
    applyAttr(selection2, "fill", ([i3]) => F2[i3]);
  if (FO)
    applyAttr(selection2, "fill-opacity", ([i3]) => FO[i3]);
  if (S2)
    applyAttr(selection2, "stroke", ([i3]) => S2[i3]);
  if (SO)
    applyAttr(selection2, "stroke-opacity", ([i3]) => SO[i3]);
  if (SW)
    applyAttr(selection2, "stroke-width", ([i3]) => SW[i3]);
  if (O2)
    applyAttr(selection2, "opacity", ([i3]) => O2[i3]);
  if (H2)
    applyHref(selection2, ([i3]) => H2[i3], target);
  if (!tip2)
    applyTitleGroup(selection2, T2);
}
function groupZ(I2, Z, z3) {
  const G = group(I2, (i3) => Z[i3]);
  if (z3 === void 0 && G.size > 1 + I2.length >> 1) {
    warn(
      `Warning: the implicit z channel has high cardinality. This may occur when the fill or stroke channel is associated with quantitative data rather than ordinal or categorical data. You can suppress this warning by setting the z option explicitly; if this data represents a single series, set z to null.`
    );
  }
  return G.values();
}
function maybeClip(clip) {
  if (clip === true)
    clip = "frame";
  else if (clip === false)
    clip = null;
  else if (clip != null)
    clip = keyword(clip, "clip", ["frame", "sphere"]);
  return clip;
}
function applyClip(selection2, mark, dimensions, context) {
  let clipUrl;
  const { clip = context.clip } = mark;
  switch (clip) {
    case "frame": {
      const { width, height, marginLeft, marginRight, marginTop, marginBottom } = dimensions;
      const id2 = getClipId();
      clipUrl = `url(#${id2})`;
      selection2 = create2("svg:g", context).call(
        (g3) => g3.append("svg:clipPath").attr("id", id2).append("rect").attr("x", marginLeft).attr("y", marginTop).attr("width", width - marginRight - marginLeft).attr("height", height - marginTop - marginBottom)
      ).each(function() {
        this.appendChild(selection2.node());
        selection2.node = () => this;
      });
      break;
    }
    case "sphere": {
      const { projection: projection3 } = context;
      if (!projection3)
        throw new Error(`the "sphere" clip option requires a projection`);
      const id2 = getClipId();
      clipUrl = `url(#${id2})`;
      selection2.append("clipPath").attr("id", id2).append("path").attr("d", path_default(projection3)({ type: "Sphere" }));
      break;
    }
  }
  applyAttr(selection2, "aria-label", mark.ariaLabel);
  applyAttr(selection2, "aria-description", mark.ariaDescription);
  applyAttr(selection2, "aria-hidden", mark.ariaHidden);
  applyAttr(selection2, "clip-path", clipUrl);
}
function applyIndirectStyles(selection2, mark, dimensions, context) {
  applyClip(selection2, mark, dimensions, context);
  applyAttr(selection2, "fill", mark.fill);
  applyAttr(selection2, "fill-opacity", mark.fillOpacity);
  applyAttr(selection2, "stroke", mark.stroke);
  applyAttr(selection2, "stroke-width", mark.strokeWidth);
  applyAttr(selection2, "stroke-opacity", mark.strokeOpacity);
  applyAttr(selection2, "stroke-linejoin", mark.strokeLinejoin);
  applyAttr(selection2, "stroke-linecap", mark.strokeLinecap);
  applyAttr(selection2, "stroke-miterlimit", mark.strokeMiterlimit);
  applyAttr(selection2, "stroke-dasharray", mark.strokeDasharray);
  applyAttr(selection2, "stroke-dashoffset", mark.strokeDashoffset);
  applyAttr(selection2, "shape-rendering", mark.shapeRendering);
  applyAttr(selection2, "filter", mark.imageFilter);
  applyAttr(selection2, "paint-order", mark.paintOrder);
  const { pointerEvents = context.pointerSticky === false ? "none" : void 0 } = mark;
  applyAttr(selection2, "pointer-events", pointerEvents);
}
function applyDirectStyles(selection2, mark) {
  applyStyle(selection2, "mix-blend-mode", mark.mixBlendMode);
  applyAttr(selection2, "opacity", mark.opacity);
}
function applyHref(selection2, href, target) {
  selection2.each(function(i3) {
    const h3 = href(i3);
    if (h3 != null) {
      const a4 = this.ownerDocument.createElementNS(namespaces_default.svg, "a");
      a4.setAttribute("fill", "inherit");
      a4.setAttributeNS(namespaces_default.xlink, "href", h3);
      if (target != null)
        a4.setAttribute("target", target);
      this.parentNode.insertBefore(a4, this).appendChild(this);
    }
  });
}
function applyAttr(selection2, name, value) {
  if (value != null)
    selection2.attr(name, value);
}
function applyStyle(selection2, name, value) {
  if (value != null)
    selection2.style(name, value);
}
function applyTransform(selection2, mark, { x: x3, y: y3 }, tx = offset, ty = offset) {
  tx += mark.dx;
  ty += mark.dy;
  if (x3?.bandwidth)
    tx += x3.bandwidth() / 2;
  if (y3?.bandwidth)
    ty += y3.bandwidth() / 2;
  if (tx || ty)
    selection2.attr("transform", `translate(${tx},${ty})`);
}
function impliedString(value, impliedValue) {
  if ((value = string(value)) !== impliedValue)
    return value;
}
function impliedNumber(value, impliedValue) {
  if ((value = number5(value)) !== impliedValue)
    return value;
}
var validClassName = /^-?([_a-z]|[\240-\377]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])([_a-z0-9-]|[\240-\377]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])*$/i;
function maybeClassName(name) {
  if (name === void 0)
    return "plot-d6a7b5";
  name = `${name}`;
  if (!validClassName.test(name))
    throw new Error(`invalid class name: ${name}`);
  return name;
}
function applyInlineStyles(selection2, style) {
  if (typeof style === "string") {
    selection2.property("style", style);
  } else if (style != null) {
    for (const element of selection2) {
      Object.assign(element.style, style);
    }
  }
}
function applyFrameAnchor({ frameAnchor }, { width, height, marginTop, marginRight, marginBottom, marginLeft }) {
  return [
    /left$/.test(frameAnchor) ? marginLeft : /right$/.test(frameAnchor) ? width - marginRight : (marginLeft + width - marginRight) / 2,
    /^top/.test(frameAnchor) ? marginTop : /^bottom/.test(frameAnchor) ? height - marginBottom : (marginTop + height - marginBottom) / 2
  ];
}

// node_modules/@observablehq/plot/src/context.js
function createContext(options = {}) {
  const { document: document2 = typeof window !== "undefined" ? window.document : void 0, clip } = options;
  return { document: document2, clip: maybeClip(clip) };
}
function create2(name, { document: document2 }) {
  return select_default2(creator_default(name).call(document2.documentElement));
}

// node_modules/@observablehq/plot/src/projection.js
var pi4 = Math.PI;
var tau4 = 2 * pi4;
var defaultAspectRatio = 0.618;
function createProjection({
  projection: projection3,
  inset: globalInset = 0,
  insetTop = globalInset,
  insetRight = globalInset,
  insetBottom = globalInset,
  insetLeft = globalInset
} = {}, dimensions) {
  if (projection3 == null)
    return;
  if (typeof projection3.stream === "function")
    return projection3;
  let options;
  let domain;
  let clip = "frame";
  if (isObject(projection3)) {
    let inset;
    ({
      type: projection3,
      domain,
      inset,
      insetTop = inset !== void 0 ? inset : insetTop,
      insetRight = inset !== void 0 ? inset : insetRight,
      insetBottom = inset !== void 0 ? inset : insetBottom,
      insetLeft = inset !== void 0 ? inset : insetLeft,
      clip = clip,
      ...options
    } = projection3);
    if (projection3 == null)
      return;
  }
  if (typeof projection3 !== "function")
    ({ type: projection3 } = namedProjection(projection3));
  const { width, height, marginLeft, marginRight, marginTop, marginBottom } = dimensions;
  const dx = width - marginLeft - marginRight - insetLeft - insetRight;
  const dy = height - marginTop - marginBottom - insetTop - insetBottom;
  projection3 = projection3?.({ width: dx, height: dy, clip, ...options });
  if (projection3 == null)
    return;
  clip = maybePostClip(clip, marginLeft, marginTop, width - marginRight, height - marginBottom);
  let tx = marginLeft + insetLeft;
  let ty = marginTop + insetTop;
  let transform2;
  if (domain != null) {
    const [[x05, y05], [x12, y12]] = path_default(projection3).bounds(domain);
    const k4 = Math.min(dx / (x12 - x05), dy / (y12 - y05));
    if (k4 > 0) {
      tx -= (k4 * (x05 + x12) - dx) / 2;
      ty -= (k4 * (y05 + y12) - dy) / 2;
      transform2 = transform_default({
        point(x3, y3) {
          this.stream.point(x3 * k4 + tx, y3 * k4 + ty);
        }
      });
    } else {
      warn(`Warning: the projection could not be fit to the specified domain; using the default scale.`);
    }
  }
  transform2 ??= tx === 0 && ty === 0 ? identity7() : transform_default({
    point(x3, y3) {
      this.stream.point(x3 + tx, y3 + ty);
    }
  });
  return { stream: (s4) => projection3.stream(transform2.stream(clip(s4))) };
}
function namedProjection(projection3) {
  switch (`${projection3}`.toLowerCase()) {
    case "albers-usa":
      return scaleProjection(albersUsa_default, 0.7463, 0.4673);
    case "albers":
      return conicProjection2(albers_default, 0.7463, 0.4673);
    case "azimuthal-equal-area":
      return scaleProjection(azimuthalEqualArea_default, 4, 4);
    case "azimuthal-equidistant":
      return scaleProjection(azimuthalEquidistant_default, tau4, tau4);
    case "conic-conformal":
      return conicProjection2(conicConformal_default, tau4, tau4);
    case "conic-equal-area":
      return conicProjection2(conicEqualArea_default, 6.1702, 2.9781);
    case "conic-equidistant":
      return conicProjection2(conicEquidistant_default, 7.312, 3.6282);
    case "equal-earth":
      return scaleProjection(equalEarth_default, 5.4133, 2.6347);
    case "equirectangular":
      return scaleProjection(equirectangular_default, tau4, pi4);
    case "gnomonic":
      return scaleProjection(gnomonic_default, 3.4641, 3.4641);
    case "identity":
      return { type: identity7 };
    case "reflect-y":
      return { type: reflectY };
    case "mercator":
      return scaleProjection(mercator_default, tau4, tau4);
    case "orthographic":
      return scaleProjection(orthographic_default, 2, 2);
    case "stereographic":
      return scaleProjection(stereographic_default, 2, 2);
    case "transverse-mercator":
      return scaleProjection(transverseMercator_default, tau4, tau4);
    default:
      throw new Error(`unknown projection type: ${projection3}`);
  }
}
function maybePostClip(clip, x12, y12, x22, y22) {
  if (clip === false || clip == null || typeof clip === "number")
    return (s4) => s4;
  if (clip === true)
    clip = "frame";
  switch (`${clip}`.toLowerCase()) {
    case "frame":
      return clipRectangle(x12, y12, x22, y22);
    default:
      throw new Error(`unknown projection clip type: ${clip}`);
  }
}
function scaleProjection(createProjection2, kx2, ky2) {
  return {
    type: ({ width, height, rotate, precision = 0.15, clip }) => {
      const projection3 = createProjection2();
      if (precision != null)
        projection3.precision?.(precision);
      if (rotate != null)
        projection3.rotate?.(rotate);
      if (typeof clip === "number")
        projection3.clipAngle?.(clip);
      projection3.scale(Math.min(width / kx2, height / ky2));
      projection3.translate([width / 2, height / 2]);
      return projection3;
    },
    aspectRatio: ky2 / kx2
  };
}
function conicProjection2(createProjection2, kx2, ky2) {
  const { type: type2, aspectRatio } = scaleProjection(createProjection2, kx2, ky2);
  return {
    type: (options) => {
      const { parallels, domain, width, height } = options;
      const projection3 = type2(options);
      if (parallels != null) {
        projection3.parallels(parallels);
        if (domain === void 0) {
          projection3.fitSize([width, height], { type: "Sphere" });
        }
      }
      return projection3;
    },
    aspectRatio
  };
}
var identity7 = constant({ stream: (stream) => stream });
var reflectY = constant(
  transform_default({
    point(x3, y3) {
      this.stream.point(x3, -y3);
    }
  })
);
function project(cx, cy, values2, projection3) {
  const x3 = values2[cx];
  const y3 = values2[cy];
  const n2 = x3.length;
  const X3 = values2[cx] = new Float64Array(n2).fill(NaN);
  const Y3 = values2[cy] = new Float64Array(n2).fill(NaN);
  let i3;
  const stream = projection3.stream({
    point(x4, y4) {
      X3[i3] = x4;
      Y3[i3] = y4;
    }
  });
  for (i3 = 0; i3 < n2; ++i3) {
    stream.point(x3[i3], y3[i3]);
  }
}
function hasProjection({ projection: projection3 } = {}) {
  if (projection3 == null)
    return false;
  if (typeof projection3.stream === "function")
    return true;
  if (isObject(projection3))
    projection3 = projection3.type;
  return projection3 != null;
}
function projectionAspectRatio(projection3) {
  if (typeof projection3?.stream === "function")
    return defaultAspectRatio;
  if (isObject(projection3))
    projection3 = projection3.type;
  if (projection3 == null)
    return;
  if (typeof projection3 !== "function") {
    const { aspectRatio } = namedProjection(projection3);
    if (aspectRatio)
      return aspectRatio;
  }
  return defaultAspectRatio;
}
function getGeometryChannels(channel) {
  const X3 = [];
  const Y3 = [];
  const x3 = { scale: "x", value: X3 };
  const y3 = { scale: "y", value: Y3 };
  const sink = {
    point(x4, y4) {
      X3.push(x4);
      Y3.push(y4);
    },
    lineStart() {
    },
    lineEnd() {
    },
    polygonStart() {
    },
    polygonEnd() {
    },
    sphere() {
    }
  };
  for (const object of channel.value)
    stream_default(object, sink);
  return [x3, y3];
}

// node_modules/@observablehq/plot/src/scales/schemes.js
var categoricalSchemes = /* @__PURE__ */ new Map([
  ["accent", Accent_default],
  ["category10", category10_default],
  ["dark2", Dark2_default],
  ["paired", Paired_default],
  ["pastel1", Pastel1_default],
  ["pastel2", Pastel2_default],
  ["set1", Set1_default],
  ["set2", Set2_default],
  ["set3", Set3_default],
  ["tableau10", Tableau10_default]
]);
function isCategoricalScheme(scheme28) {
  return scheme28 != null && categoricalSchemes.has(`${scheme28}`.toLowerCase());
}
var ordinalSchemes = new Map([
  ...categoricalSchemes,
  // diverging
  ["brbg", scheme112(scheme, BrBG_default)],
  ["prgn", scheme112(scheme2, PRGn_default)],
  ["piyg", scheme112(scheme3, PiYG_default)],
  ["puor", scheme112(scheme4, PuOr_default)],
  ["rdbu", scheme112(scheme5, RdBu_default)],
  ["rdgy", scheme112(scheme6, RdGy_default)],
  ["rdylbu", scheme112(scheme7, RdYlBu_default)],
  ["rdylgn", scheme112(scheme8, RdYlGn_default)],
  ["spectral", scheme112(scheme9, Spectral_default)],
  // reversed diverging (for temperature data)
  ["burd", scheme11r(scheme5, RdBu_default)],
  ["buylrd", scheme11r(scheme7, RdYlBu_default)],
  // sequential (single-hue)
  ["blues", scheme92(scheme22, Blues_default)],
  ["greens", scheme92(scheme23, Greens_default)],
  ["greys", scheme92(scheme24, Greys_default)],
  ["oranges", scheme92(scheme27, Oranges_default)],
  ["purples", scheme92(scheme25, Purples_default)],
  ["reds", scheme92(scheme26, Reds_default)],
  // sequential (multi-hue)
  ["turbo", schemei(turbo_default)],
  ["viridis", schemei(viridis_default)],
  ["magma", schemei(magma)],
  ["inferno", schemei(inferno)],
  ["plasma", schemei(plasma)],
  ["cividis", schemei(cividis_default)],
  ["cubehelix", schemei(cubehelix_default2)],
  ["warm", schemei(warm)],
  ["cool", schemei(cool)],
  ["bugn", scheme92(scheme10, BuGn_default)],
  ["bupu", scheme92(scheme11, BuPu_default)],
  ["gnbu", scheme92(scheme12, GnBu_default)],
  ["orrd", scheme92(scheme13, OrRd_default)],
  ["pubu", scheme92(scheme15, PuBu_default)],
  ["pubugn", scheme92(scheme14, PuBuGn_default)],
  ["purd", scheme92(scheme16, PuRd_default)],
  ["rdpu", scheme92(scheme17, RdPu_default)],
  ["ylgn", scheme92(scheme19, YlGn_default)],
  ["ylgnbu", scheme92(scheme18, YlGnBu_default)],
  ["ylorbr", scheme92(scheme20, YlOrBr_default)],
  ["ylorrd", scheme92(scheme21, YlOrRd_default)],
  // cyclical
  ["rainbow", schemeicyclical(rainbow_default)],
  ["sinebow", schemeicyclical(sinebow_default)]
]);
function scheme92(scheme28, interpolate) {
  return ({ length: n2 }) => {
    if (n2 === 1)
      return [scheme28[3][1]];
    if (n2 === 2)
      return [scheme28[3][1], scheme28[3][2]];
    n2 = Math.max(3, Math.floor(n2));
    return n2 > 9 ? quantize_default(interpolate, n2) : scheme28[n2];
  };
}
function scheme112(scheme28, interpolate) {
  return ({ length: n2 }) => {
    if (n2 === 2)
      return [scheme28[3][0], scheme28[3][2]];
    n2 = Math.max(3, Math.floor(n2));
    return n2 > 11 ? quantize_default(interpolate, n2) : scheme28[n2];
  };
}
function scheme11r(scheme28, interpolate) {
  return ({ length: n2 }) => {
    if (n2 === 2)
      return [scheme28[3][2], scheme28[3][0]];
    n2 = Math.max(3, Math.floor(n2));
    return n2 > 11 ? quantize_default((t4) => interpolate(1 - t4), n2) : scheme28[n2].slice().reverse();
  };
}
function schemei(interpolate) {
  return ({ length: n2 }) => quantize_default(interpolate, Math.max(2, Math.floor(n2)));
}
function schemeicyclical(interpolate) {
  return ({ length: n2 }) => quantize_default(interpolate, Math.floor(n2) + 1).slice(0, -1);
}
function ordinalScheme(scheme28) {
  const s4 = `${scheme28}`.toLowerCase();
  if (!ordinalSchemes.has(s4))
    throw new Error(`unknown ordinal scheme: ${s4}`);
  return ordinalSchemes.get(s4);
}
function ordinalRange(scheme28, length3) {
  const s4 = ordinalScheme(scheme28);
  const r3 = typeof s4 === "function" ? s4({ length: length3 }) : s4;
  return r3.length !== length3 ? r3.slice(0, length3) : r3;
}
function maybeBooleanRange(domain, scheme28 = "greys") {
  const range3 = /* @__PURE__ */ new Set();
  const [f3, t4] = ordinalRange(scheme28, 2);
  for (const value of domain) {
    if (value == null)
      continue;
    if (value === true)
      range3.add(t4);
    else if (value === false)
      range3.add(f3);
    else
      return;
  }
  return [...range3];
}
var quantitativeSchemes = /* @__PURE__ */ new Map([
  // diverging
  ["brbg", BrBG_default],
  ["prgn", PRGn_default],
  ["piyg", PiYG_default],
  ["puor", PuOr_default],
  ["rdbu", RdBu_default],
  ["rdgy", RdGy_default],
  ["rdylbu", RdYlBu_default],
  ["rdylgn", RdYlGn_default],
  ["spectral", Spectral_default],
  // reversed diverging (for temperature data)
  ["burd", (t4) => RdBu_default(1 - t4)],
  ["buylrd", (t4) => RdYlBu_default(1 - t4)],
  // sequential (single-hue)
  ["blues", Blues_default],
  ["greens", Greens_default],
  ["greys", Greys_default],
  ["purples", Purples_default],
  ["reds", Reds_default],
  ["oranges", Oranges_default],
  // sequential (multi-hue)
  ["turbo", turbo_default],
  ["viridis", viridis_default],
  ["magma", magma],
  ["inferno", inferno],
  ["plasma", plasma],
  ["cividis", cividis_default],
  ["cubehelix", cubehelix_default2],
  ["warm", warm],
  ["cool", cool],
  ["bugn", BuGn_default],
  ["bupu", BuPu_default],
  ["gnbu", GnBu_default],
  ["orrd", OrRd_default],
  ["pubugn", PuBuGn_default],
  ["pubu", PuBu_default],
  ["purd", PuRd_default],
  ["rdpu", RdPu_default],
  ["ylgnbu", YlGnBu_default],
  ["ylgn", YlGn_default],
  ["ylorbr", YlOrBr_default],
  ["ylorrd", YlOrRd_default],
  // cyclical
  ["rainbow", rainbow_default],
  ["sinebow", sinebow_default]
]);
function quantitativeScheme(scheme28) {
  const s4 = `${scheme28}`.toLowerCase();
  if (!quantitativeSchemes.has(s4))
    throw new Error(`unknown quantitative scheme: ${s4}`);
  return quantitativeSchemes.get(s4);
}
var divergingSchemes = /* @__PURE__ */ new Set([
  "brbg",
  "prgn",
  "piyg",
  "puor",
  "rdbu",
  "rdgy",
  "rdylbu",
  "rdylgn",
  "spectral",
  "burd",
  "buylrd"
]);
function isDivergingScheme(scheme28) {
  return scheme28 != null && divergingSchemes.has(`${scheme28}`.toLowerCase());
}

// node_modules/@observablehq/plot/src/scales/quantitative.js
var flip = (i3) => (t4) => i3(1 - t4);
var unit2 = [0, 1];
var interpolators = /* @__PURE__ */ new Map([
  // numbers
  ["number", number_default],
  // color spaces
  ["rgb", rgb_default],
  ["hsl", hsl_default],
  ["hcl", hcl_default],
  ["lab", lab2]
]);
function maybeInterpolator(interpolate) {
  const i3 = `${interpolate}`.toLowerCase();
  if (!interpolators.has(i3))
    throw new Error(`unknown interpolator: ${i3}`);
  return interpolators.get(i3);
}
function createScaleQ(key, scale, channels, {
  type: type2,
  nice: nice2,
  clamp,
  zero: zero3,
  domain = inferAutoDomain(key, channels),
  unknown,
  round,
  scheme: scheme28,
  interval: interval2,
  range: range3 = registry.get(key) === radius ? inferRadialRange(channels, domain) : registry.get(key) === length2 ? inferLengthRange(channels, domain) : registry.get(key) === opacity ? unit2 : void 0,
  interpolate = registry.get(key) === color2 ? scheme28 == null && range3 !== void 0 ? rgb_default : quantitativeScheme(scheme28 !== void 0 ? scheme28 : type2 === "cyclical" ? "rainbow" : "turbo") : round ? round_default : number_default,
  reverse: reverse2
}) {
  interval2 = maybeRangeInterval(interval2, type2);
  if (type2 === "cyclical" || type2 === "sequential")
    type2 = "linear";
  if (typeof interpolate !== "function")
    interpolate = maybeInterpolator(interpolate);
  reverse2 = !!reverse2;
  if (range3 !== void 0) {
    const n2 = (domain = arrayify2(domain)).length;
    const m3 = (range3 = arrayify2(range3)).length;
    if (n2 !== m3) {
      if (interpolate.length === 1)
        throw new Error("invalid piecewise interpolator");
      interpolate = piecewise(interpolate, range3);
      range3 = void 0;
    }
  }
  if (interpolate.length === 1) {
    if (reverse2) {
      interpolate = flip(interpolate);
      reverse2 = false;
    }
    if (range3 === void 0) {
      range3 = Float64Array.from(domain, (_2, i3) => i3 / (domain.length - 1));
      if (range3.length === 2)
        range3 = unit2;
    }
    scale.interpolate((range3 === unit2 ? constant : interpolatePiecewise)(interpolate));
  } else {
    scale.interpolate(interpolate);
  }
  if (zero3) {
    const [min4, max3] = extent(domain);
    if (min4 > 0 || max3 < 0) {
      domain = slice2(domain);
      if (orderof(domain) !== Math.sign(min4))
        domain[domain.length - 1] = 0;
      else
        domain[0] = 0;
    }
  }
  if (reverse2)
    domain = reverse(domain);
  scale.domain(domain).unknown(unknown);
  if (nice2)
    scale.nice(maybeNice(nice2, type2)), domain = scale.domain();
  if (range3 !== void 0)
    scale.range(range3);
  if (clamp)
    scale.clamp(clamp);
  return { type: type2, domain, range: range3, scale, interpolate, interval: interval2 };
}
function maybeNice(nice2, type2) {
  return nice2 === true ? void 0 : typeof nice2 === "number" ? nice2 : maybeNiceInterval(nice2, type2);
}
function createScaleLinear(key, channels, options) {
  return createScaleQ(key, linear2(), channels, options);
}
function createScaleSqrt(key, channels, options) {
  return createScalePow(key, channels, { ...options, exponent: 0.5 });
}
function createScalePow(key, channels, { exponent = 1, ...options }) {
  return createScaleQ(key, pow2().exponent(exponent), channels, { ...options, type: "pow" });
}
function createScaleLog(key, channels, { base = 10, domain = inferLogDomain(channels), ...options }) {
  return createScaleQ(key, log2().base(base), channels, { ...options, domain });
}
function createScaleSymlog(key, channels, { constant: constant2 = 1, ...options }) {
  return createScaleQ(key, symlog().constant(constant2), channels, options);
}
function createScaleQuantile(key, channels, {
  range: range3,
  quantiles = range3 === void 0 ? 5 : (range3 = [...range3]).length,
  // deprecated; use n instead
  n: n2 = quantiles,
  scheme: scheme28 = "rdylbu",
  domain = inferQuantileDomain(channels),
  unknown,
  interpolate,
  reverse: reverse2
}) {
  if (range3 === void 0) {
    range3 = interpolate !== void 0 ? quantize_default(interpolate, n2) : registry.get(key) === color2 ? ordinalRange(scheme28, n2) : void 0;
  }
  if (domain.length > 0) {
    domain = quantile2(domain, range3 === void 0 ? { length: n2 } : range3).quantiles();
  }
  return createScaleThreshold(key, channels, { domain, range: range3, reverse: reverse2, unknown });
}
function createScaleQuantize(key, channels, {
  range: range3,
  n: n2 = range3 === void 0 ? 5 : (range3 = [...range3]).length,
  scheme: scheme28 = "rdylbu",
  domain = inferAutoDomain(key, channels),
  unknown,
  interpolate,
  reverse: reverse2
}) {
  const [min4, max3] = extent(domain);
  let thresholds;
  if (range3 === void 0) {
    thresholds = ticks(min4, max3, n2);
    if (thresholds[0] <= min4)
      thresholds.splice(0, 1);
    if (thresholds[thresholds.length - 1] >= max3)
      thresholds.pop();
    n2 = thresholds.length + 1;
    range3 = interpolate !== void 0 ? quantize_default(interpolate, n2) : registry.get(key) === color2 ? ordinalRange(scheme28, n2) : void 0;
  } else {
    thresholds = quantize_default(number_default(min4, max3), n2 + 1).slice(1, -1);
    if (min4 instanceof Date)
      thresholds = thresholds.map((x3) => new Date(x3));
  }
  if (orderof(arrayify2(domain)) < 0)
    thresholds.reverse();
  return createScaleThreshold(key, channels, { domain: thresholds, range: range3, reverse: reverse2, unknown });
}
function createScaleThreshold(key, channels, {
  domain = [0],
  // explicit thresholds in ascending order
  unknown,
  scheme: scheme28 = "rdylbu",
  interpolate,
  range: range3 = interpolate !== void 0 ? quantize_default(interpolate, domain.length + 1) : registry.get(key) === color2 ? ordinalRange(scheme28, domain.length + 1) : void 0,
  reverse: reverse2
}) {
  domain = arrayify2(domain);
  const sign2 = orderof(domain);
  if (!isNaN(sign2) && !isOrdered(domain, sign2))
    throw new Error(`the ${key} scale has a non-monotonic domain`);
  if (reverse2)
    range3 = reverse(range3);
  return {
    type: "threshold",
    scale: threshold(sign2 < 0 ? reverse(domain) : domain, range3 === void 0 ? [] : range3).unknown(unknown),
    domain,
    range: range3
  };
}
function isOrdered(domain, sign2) {
  for (let i3 = 1, n2 = domain.length, d3 = domain[0]; i3 < n2; ++i3) {
    const s4 = descending(d3, d3 = domain[i3]);
    if (s4 !== 0 && s4 !== sign2)
      return false;
  }
  return true;
}
function createScaleIdentity(key) {
  return { type: "identity", scale: hasNumericRange(registry.get(key)) ? identity4() : (d3) => d3 };
}
function inferDomain(channels, f3 = finite) {
  return channels.length ? [
    min(channels, ({ value }) => value === void 0 ? value : min(value, f3)),
    max(channels, ({ value }) => value === void 0 ? value : max(value, f3))
  ] : [0, 1];
}
function inferAutoDomain(key, channels) {
  const type2 = registry.get(key);
  return (type2 === radius || type2 === opacity || type2 === length2 ? inferZeroDomain : inferDomain)(channels);
}
function inferZeroDomain(channels) {
  return [0, channels.length ? max(channels, ({ value }) => value === void 0 ? value : max(value, finite)) : 1];
}
function inferRadialRange(channels, domain) {
  const hint = channels.find(({ radius: radius2 }) => radius2 !== void 0);
  if (hint !== void 0)
    return [0, hint.radius];
  const h25 = quantile(channels, 0.5, ({ value }) => value === void 0 ? NaN : quantile(value, 0.25, positive));
  const range3 = domain.map((d3) => 3 * Math.sqrt(d3 / h25));
  const k4 = 30 / max(range3);
  return k4 < 1 ? range3.map((r3) => r3 * k4) : range3;
}
function inferLengthRange(channels, domain) {
  const h50 = median(channels, ({ value }) => value === void 0 ? NaN : median(value, Math.abs));
  const range3 = domain.map((d3) => 12 * d3 / h50);
  const k4 = 60 / max(range3);
  return k4 < 1 ? range3.map((r3) => r3 * k4) : range3;
}
function inferLogDomain(channels) {
  for (const { value } of channels) {
    if (value !== void 0) {
      for (let v3 of value) {
        if (v3 > 0)
          return inferDomain(channels, positive);
        if (v3 < 0)
          return inferDomain(channels, negative);
      }
    }
  }
  return [1, 10];
}
function inferQuantileDomain(channels) {
  const domain = [];
  for (const { value } of channels) {
    if (value === void 0)
      continue;
    for (const v3 of value)
      domain.push(v3);
  }
  return domain;
}
function interpolatePiecewise(interpolate) {
  return (i3, j3) => (t4) => interpolate(i3 + t4 * (j3 - i3));
}

// node_modules/@observablehq/plot/src/scales/diverging.js
function createScaleD(key, scale, transform2, channels, {
  type: type2,
  nice: nice2,
  clamp,
  domain = inferDomain(channels),
  unknown,
  pivot = 0,
  scheme: scheme28,
  range: range3,
  symmetric = true,
  interpolate = registry.get(key) === color2 ? scheme28 == null && range3 !== void 0 ? rgb_default : quantitativeScheme(scheme28 !== void 0 ? scheme28 : "rdbu") : number_default,
  reverse: reverse2
}) {
  pivot = +pivot;
  domain = arrayify2(domain);
  let [min4, max3] = domain;
  if (domain.length > 2)
    warn(`Warning: the diverging ${key} scale domain contains extra elements.`);
  if (descending(min4, max3) < 0)
    [min4, max3] = [max3, min4], reverse2 = !reverse2;
  min4 = Math.min(min4, pivot);
  max3 = Math.max(max3, pivot);
  if (typeof interpolate !== "function") {
    interpolate = maybeInterpolator(interpolate);
  }
  if (range3 !== void 0) {
    interpolate = interpolate.length === 1 ? interpolatePiecewise(interpolate)(...range3) : piecewise(interpolate, range3);
  }
  if (reverse2)
    interpolate = flip(interpolate);
  if (symmetric) {
    const mid2 = transform2.apply(pivot);
    const mindelta = mid2 - transform2.apply(min4);
    const maxdelta = transform2.apply(max3) - mid2;
    if (mindelta < maxdelta)
      min4 = transform2.invert(mid2 - maxdelta);
    else if (mindelta > maxdelta)
      max3 = transform2.invert(mid2 + mindelta);
  }
  scale.domain([min4, pivot, max3]).unknown(unknown).interpolator(interpolate);
  if (clamp)
    scale.clamp(clamp);
  if (nice2)
    scale.nice(nice2);
  return { type: type2, domain: [min4, max3], pivot, interpolate, scale };
}
function createScaleDiverging(key, channels, options) {
  return createScaleD(key, diverging(), transformIdentity, channels, options);
}
function createScaleDivergingSqrt(key, channels, options) {
  return createScaleDivergingPow(key, channels, { ...options, exponent: 0.5 });
}
function createScaleDivergingPow(key, channels, { exponent = 1, ...options }) {
  return createScaleD(key, divergingPow().exponent(exponent = +exponent), transformPow2(exponent), channels, {
    ...options,
    type: "diverging-pow"
  });
}
function createScaleDivergingLog(key, channels, { base = 10, pivot = 1, domain = inferDomain(channels, pivot < 0 ? negative : positive), ...options }) {
  return createScaleD(key, divergingLog().base(base = +base), transformLog2, channels, {
    domain,
    pivot,
    ...options
  });
}
function createScaleDivergingSymlog(key, channels, { constant: constant2 = 1, ...options }) {
  return createScaleD(
    key,
    divergingSymlog().constant(constant2 = +constant2),
    transformSymlog2(constant2),
    channels,
    options
  );
}
var transformIdentity = {
  apply(x3) {
    return x3;
  },
  invert(x3) {
    return x3;
  }
};
var transformLog2 = {
  apply: Math.log,
  invert: Math.exp
};
var transformSqrt2 = {
  apply(x3) {
    return Math.sign(x3) * Math.sqrt(Math.abs(x3));
  },
  invert(x3) {
    return Math.sign(x3) * (x3 * x3);
  }
};
function transformPow2(exponent) {
  return exponent === 0.5 ? transformSqrt2 : {
    apply(x3) {
      return Math.sign(x3) * Math.pow(Math.abs(x3), exponent);
    },
    invert(x3) {
      return Math.sign(x3) * Math.pow(Math.abs(x3), 1 / exponent);
    }
  };
}
function transformSymlog2(constant2) {
  return {
    apply(x3) {
      return Math.sign(x3) * Math.log1p(Math.abs(x3 / constant2));
    },
    invert(x3) {
      return Math.sign(x3) * Math.expm1(Math.abs(x3)) * constant2;
    }
  };
}

// node_modules/@observablehq/plot/src/scales/temporal.js
function createScaleT(key, scale, channels, options) {
  return createScaleQ(key, scale, channels, options);
}
function createScaleTime(key, channels, options) {
  return createScaleT(key, time(), channels, options);
}
function createScaleUtc(key, channels, options) {
  return createScaleT(key, utcTime(), channels, options);
}

// node_modules/@observablehq/plot/src/scales/ordinal.js
var ordinalImplicit = Symbol("ordinal");
function createScaleO(key, scale, channels, { type: type2, interval: interval2, domain, range: range3, reverse: reverse2, hint }) {
  interval2 = maybeRangeInterval(interval2, type2);
  if (domain === void 0)
    domain = inferDomain2(channels, interval2, key);
  if (type2 === "categorical" || type2 === ordinalImplicit)
    type2 = "ordinal";
  if (reverse2)
    domain = reverse(domain);
  domain = scale.domain(domain).domain();
  if (range3 !== void 0) {
    if (typeof range3 === "function")
      range3 = range3(domain);
    scale.range(range3);
  }
  return { type: type2, domain, range: range3, scale, hint, interval: interval2 };
}
function createScaleOrdinal(key, channels, { type: type2, interval: interval2, domain, range: range3, scheme: scheme28, unknown, ...options }) {
  interval2 = maybeRangeInterval(interval2, type2);
  if (domain === void 0)
    domain = inferDomain2(channels, interval2, key);
  let hint;
  if (registry.get(key) === symbol) {
    hint = inferSymbolHint(channels);
    range3 = range3 === void 0 ? inferSymbolRange(hint) : map2(range3, maybeSymbol);
  } else if (registry.get(key) === color2) {
    if (range3 === void 0 && (type2 === "ordinal" || type2 === ordinalImplicit)) {
      range3 = maybeBooleanRange(domain, scheme28);
      if (range3 !== void 0)
        scheme28 = void 0;
    }
    if (scheme28 === void 0 && range3 === void 0) {
      scheme28 = type2 === "ordinal" ? "turbo" : "tableau10";
    }
    if (scheme28 !== void 0) {
      if (range3 !== void 0) {
        const interpolate = quantitativeScheme(scheme28);
        const t03 = range3[0], d3 = range3[1] - range3[0];
        range3 = ({ length: n2 }) => quantize_default((t4) => interpolate(t03 + d3 * t4), n2);
      } else {
        range3 = ordinalScheme(scheme28);
      }
    }
  }
  if (unknown === implicit) {
    throw new Error(`implicit unknown on ${key} scale is not supported`);
  }
  return createScaleO(key, ordinal().unknown(unknown), channels, { ...options, type: type2, domain, range: range3, hint });
}
function createScalePoint(key, channels, { align = 0.5, padding = 0.5, ...options }) {
  return maybeRound(point().align(align).padding(padding), channels, options, key);
}
function createScaleBand(key, channels, {
  align = 0.5,
  padding = 0.1,
  paddingInner = padding,
  paddingOuter = key === "fx" || key === "fy" ? 0 : padding,
  ...options
}) {
  return maybeRound(
    band().align(align).paddingInner(paddingInner).paddingOuter(paddingOuter),
    channels,
    options,
    key
  );
}
function maybeRound(scale, channels, options, key) {
  let { round } = options;
  if (round !== void 0)
    scale.round(round = !!round);
  scale = createScaleO(key, scale, channels, options);
  scale.round = round;
  return scale;
}
function inferDomain2(channels, interval2, key) {
  const values2 = new InternSet();
  for (const { value, domain } of channels) {
    if (domain !== void 0)
      return domain();
    if (value === void 0)
      continue;
    for (const v3 of value)
      values2.add(v3);
  }
  if (interval2 !== void 0) {
    const [min4, max3] = extent(values2).map(interval2.floor, interval2);
    return interval2.range(min4, interval2.offset(max3));
  }
  if (values2.size > 1e4 && registry.get(key) === position) {
    throw new Error(`implicit ordinal domain of ${key} scale has more than 10,000 values`);
  }
  return sort(values2, ascendingDefined2);
}
function inferHint(channels, key) {
  let value;
  for (const { hint } of channels) {
    const candidate = hint?.[key];
    if (candidate === void 0)
      continue;
    if (value === void 0)
      value = candidate;
    else if (value !== candidate)
      return;
  }
  return value;
}
function inferSymbolHint(channels) {
  return {
    fill: inferHint(channels, "fill"),
    stroke: inferHint(channels, "stroke")
  };
}
function inferSymbolRange(hint) {
  return isNoneish(hint.fill) ? symbolsStroke : symbolsFill;
}

// node_modules/@observablehq/plot/src/scales.js
function createScales(channelsByScale, {
  label: globalLabel,
  inset: globalInset = 0,
  insetTop: globalInsetTop = globalInset,
  insetRight: globalInsetRight = globalInset,
  insetBottom: globalInsetBottom = globalInset,
  insetLeft: globalInsetLeft = globalInset,
  round,
  nice: nice2,
  clamp,
  zero: zero3,
  align,
  padding,
  projection: projection3,
  facet: { label: facetLabel = globalLabel } = {},
  ...options
} = {}) {
  const scales = {};
  for (const [key, channels] of channelsByScale) {
    const scaleOptions = options[key];
    const scale = createScale(key, channels, {
      round: registry.get(key) === position ? round : void 0,
      // only for position
      nice: nice2,
      clamp,
      zero: zero3,
      align,
      padding,
      projection: projection3,
      ...scaleOptions
    });
    if (scale) {
      let {
        label = key === "fx" || key === "fy" ? facetLabel : globalLabel,
        percent,
        transform: transform2,
        inset,
        insetTop = inset !== void 0 ? inset : key === "y" ? globalInsetTop : 0,
        // not fy
        insetRight = inset !== void 0 ? inset : key === "x" ? globalInsetRight : 0,
        // not fx
        insetBottom = inset !== void 0 ? inset : key === "y" ? globalInsetBottom : 0,
        // not fy
        insetLeft = inset !== void 0 ? inset : key === "x" ? globalInsetLeft : 0
        // not fx
      } = scaleOptions || {};
      if (transform2 == null)
        transform2 = void 0;
      else if (typeof transform2 !== "function")
        throw new Error("invalid scale transform; not a function");
      scale.percent = !!percent;
      scale.label = label === void 0 ? inferScaleLabel(channels, scale) : label;
      scale.transform = transform2;
      if (key === "x" || key === "fx") {
        scale.insetLeft = +insetLeft;
        scale.insetRight = +insetRight;
      } else if (key === "y" || key === "fy") {
        scale.insetTop = +insetTop;
        scale.insetBottom = +insetBottom;
      }
      scales[key] = scale;
    }
  }
  return scales;
}
function createScaleFunctions(descriptors) {
  const scales = {};
  const scaleFunctions = { scales };
  for (const [key, descriptor] of Object.entries(descriptors)) {
    const { scale, type: type2, interval: interval2, label } = descriptor;
    scales[key] = exposeScale(descriptor);
    scaleFunctions[key] = scale;
    scale.type = type2;
    if (interval2 != null)
      scale.interval = interval2;
    if (label != null)
      scale.label = label;
  }
  return scaleFunctions;
}
function autoScaleRange(scales, dimensions) {
  const { x: x3, y: y3, fx, fy } = scales;
  const superdimensions = fx || fy ? outerDimensions(dimensions) : dimensions;
  if (fx)
    autoScaleRangeX(fx, superdimensions);
  if (fy)
    autoScaleRangeY(fy, superdimensions);
  const subdimensions = fx || fy ? innerDimensions(scales, dimensions) : dimensions;
  if (x3)
    autoScaleRangeX(x3, subdimensions);
  if (y3)
    autoScaleRangeY(y3, subdimensions);
}
function inferScaleLabel(channels = [], scale) {
  let label;
  for (const { label: l3 } of channels) {
    if (l3 === void 0)
      continue;
    if (label === void 0)
      label = l3;
    else if (label !== l3)
      return;
  }
  if (label === void 0)
    return;
  if (!isOrdinalScale(scale) && scale.percent)
    label = `${label} (%)`;
  return { inferred: true, toString: () => label };
}
function outerDimensions(dimensions) {
  const {
    marginTop,
    marginRight,
    marginBottom,
    marginLeft,
    width,
    height,
    facet: {
      marginTop: facetMarginTop,
      marginRight: facetMarginRight,
      marginBottom: facetMarginBottom,
      marginLeft: facetMarginLeft
    }
  } = dimensions;
  return {
    marginTop: Math.max(marginTop, facetMarginTop),
    marginRight: Math.max(marginRight, facetMarginRight),
    marginBottom: Math.max(marginBottom, facetMarginBottom),
    marginLeft: Math.max(marginLeft, facetMarginLeft),
    width,
    height
  };
}
function innerDimensions({ fx, fy }, dimensions) {
  const { marginTop, marginRight, marginBottom, marginLeft, width, height } = outerDimensions(dimensions);
  return {
    marginTop,
    marginRight,
    marginBottom,
    marginLeft,
    width: fx ? fx.scale.bandwidth() + marginLeft + marginRight : width,
    height: fy ? fy.scale.bandwidth() + marginTop + marginBottom : height,
    facet: { width, height }
  };
}
function autoScaleRangeX(scale, dimensions) {
  if (scale.range === void 0) {
    const { insetLeft, insetRight } = scale;
    const { width, marginLeft = 0, marginRight = 0 } = dimensions;
    const left2 = marginLeft + insetLeft;
    const right2 = width - marginRight - insetRight;
    scale.range = [left2, Math.max(left2, right2)];
    if (!isOrdinalScale(scale))
      scale.range = piecewiseRange(scale);
    scale.scale.range(scale.range);
  }
  autoScaleRound(scale);
}
function autoScaleRangeY(scale, dimensions) {
  if (scale.range === void 0) {
    const { insetTop, insetBottom } = scale;
    const { height, marginTop = 0, marginBottom = 0 } = dimensions;
    const top2 = marginTop + insetTop;
    const bottom2 = height - marginBottom - insetBottom;
    scale.range = [Math.max(top2, bottom2), top2];
    if (!isOrdinalScale(scale))
      scale.range = piecewiseRange(scale);
    else
      scale.range.reverse();
    scale.scale.range(scale.range);
  }
  autoScaleRound(scale);
}
function autoScaleRound(scale) {
  if (scale.round === void 0 && isBandScale(scale) && roundError(scale) <= 30) {
    scale.scale.round(true);
  }
}
function roundError({ scale }) {
  const n2 = scale.domain().length;
  const [start2, stop] = scale.range();
  const paddingInner = scale.paddingInner ? scale.paddingInner() : 1;
  const paddingOuter = scale.paddingOuter ? scale.paddingOuter() : scale.padding();
  const m3 = n2 - paddingInner;
  const step = Math.abs(stop - start2) / Math.max(1, m3 + paddingOuter * 2);
  return (step - Math.floor(step)) * m3;
}
function piecewiseRange(scale) {
  const length3 = scale.scale.domain().length + isThresholdScale(scale);
  if (!(length3 > 2))
    return scale.range;
  const [start2, end] = scale.range;
  return Array.from({ length: length3 }, (_2, i3) => start2 + i3 / (length3 - 1) * (end - start2));
}
function createScale(key, channels = [], options = {}) {
  const type2 = inferScaleType(key, channels, options);
  if (options.type === void 0 && options.domain === void 0 && options.range === void 0 && options.interval == null && key !== "fx" && key !== "fy" && isOrdinalScale({ type: type2 })) {
    const values2 = channels.map(({ value }) => value).filter((value) => value !== void 0);
    if (values2.some(isTemporal))
      warn(
        `Warning: some data associated with the ${key} scale are dates. Dates are typically associated with a "utc" or "time" scale rather than a "${formatScaleType(
          type2
        )}" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., d3.utcDay), or you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType(
          type2
        )}".`
      );
    else if (values2.some(isTemporalString))
      warn(
        `Warning: some data associated with the ${key} scale are strings that appear to be dates (e.g., YYYY-MM-DD). If these strings represent dates, you should parse them to Date objects. Dates are typically associated with a "utc" or "time" scale rather than a "${formatScaleType(
          type2
        )}" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType(
          type2
        )}".`
      );
    else if (values2.some(isNumericString))
      warn(
        `Warning: some data associated with the ${key} scale are strings that appear to be numbers. If these strings represent numbers, you should parse or coerce them to numbers. Numbers are typically associated with a "linear" scale rather than a "${formatScaleType(
          type2
        )}" scale. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., 1 for integers), or you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType(
          type2
        )}".`
      );
  }
  options.type = type2;
  switch (type2) {
    case "diverging":
    case "diverging-sqrt":
    case "diverging-pow":
    case "diverging-log":
    case "diverging-symlog":
    case "cyclical":
    case "sequential":
    case "linear":
    case "sqrt":
    case "threshold":
    case "quantile":
    case "pow":
    case "log":
    case "symlog":
      options = coerceType(channels, options, coerceNumbers);
      break;
    case "identity":
      switch (registry.get(key)) {
        case position:
          options = coerceType(channels, options, coerceNumbers);
          break;
        case symbol:
          options = coerceType(channels, options, coerceSymbols);
          break;
      }
      break;
    case "utc":
    case "time":
      options = coerceType(channels, options, coerceDates);
      break;
  }
  switch (type2) {
    case "diverging":
      return createScaleDiverging(key, channels, options);
    case "diverging-sqrt":
      return createScaleDivergingSqrt(key, channels, options);
    case "diverging-pow":
      return createScaleDivergingPow(key, channels, options);
    case "diverging-log":
      return createScaleDivergingLog(key, channels, options);
    case "diverging-symlog":
      return createScaleDivergingSymlog(key, channels, options);
    case "categorical":
    case "ordinal":
    case ordinalImplicit:
      return createScaleOrdinal(key, channels, options);
    case "cyclical":
    case "sequential":
    case "linear":
      return createScaleLinear(key, channels, options);
    case "sqrt":
      return createScaleSqrt(key, channels, options);
    case "threshold":
      return createScaleThreshold(key, channels, options);
    case "quantile":
      return createScaleQuantile(key, channels, options);
    case "quantize":
      return createScaleQuantize(key, channels, options);
    case "pow":
      return createScalePow(key, channels, options);
    case "log":
      return createScaleLog(key, channels, options);
    case "symlog":
      return createScaleSymlog(key, channels, options);
    case "utc":
      return createScaleUtc(key, channels, options);
    case "time":
      return createScaleTime(key, channels, options);
    case "point":
      return createScalePoint(key, channels, options);
    case "band":
      return createScaleBand(key, channels, options);
    case "identity":
      return createScaleIdentity(key);
    case void 0:
      return;
    default:
      throw new Error(`unknown scale type: ${type2}`);
  }
}
function formatScaleType(type2) {
  return typeof type2 === "symbol" ? type2.description : type2;
}
var typeProjection = { toString: () => "projection" };
function inferScaleType(key, channels, { type: type2, domain, range: range3, scheme: scheme28, pivot, projection: projection3 }) {
  if (key === "fx" || key === "fy")
    return "band";
  if ((key === "x" || key === "y") && projection3 != null)
    type2 = typeProjection;
  for (const { type: t4 } of channels) {
    if (t4 === void 0)
      continue;
    else if (type2 === void 0)
      type2 = t4;
    else if (type2 !== t4)
      throw new Error(`scale incompatible with channel: ${type2} !== ${t4}`);
  }
  if (type2 === typeProjection)
    return;
  if (type2 !== void 0)
    return type2;
  if (domain === void 0 && !channels.some(({ value }) => value !== void 0))
    return;
  const kind = registry.get(key);
  if (kind === radius)
    return "sqrt";
  if (kind === opacity || kind === length2)
    return "linear";
  if (kind === symbol)
    return "ordinal";
  if ((domain || range3 || []).length > 2)
    return asOrdinalType(kind);
  if (domain !== void 0) {
    if (isOrdinal(domain))
      return asOrdinalType(kind);
    if (isTemporal(domain))
      return "utc";
  } else {
    const values2 = channels.map(({ value }) => value).filter((value) => value !== void 0);
    if (values2.some(isOrdinal))
      return asOrdinalType(kind);
    if (values2.some(isTemporal))
      return "utc";
  }
  if (kind === color2) {
    if (pivot != null || isDivergingScheme(scheme28))
      return "diverging";
    if (isCategoricalScheme(scheme28))
      return "categorical";
  }
  return "linear";
}
function asOrdinalType(kind) {
  switch (kind) {
    case position:
      return "point";
    case color2:
      return ordinalImplicit;
    default:
      return "ordinal";
  }
}
function isOrdinalScale({ type: type2 }) {
  return type2 === "ordinal" || type2 === "point" || type2 === "band" || type2 === ordinalImplicit;
}
function isThresholdScale({ type: type2 }) {
  return type2 === "threshold";
}
function isBandScale({ type: type2 }) {
  return type2 === "point" || type2 === "band";
}
function isCollapsed(scale) {
  if (scale === void 0)
    return true;
  const domain = scale.domain();
  const value = scale(domain[0]);
  for (let i3 = 1, n2 = domain.length; i3 < n2; ++i3) {
    if (scale(domain[i3]) - value) {
      return false;
    }
  }
  return true;
}
function coerceType(channels, { domain, ...options }, coerceValues) {
  for (const c6 of channels) {
    if (c6.value !== void 0) {
      c6.value = coerceValues(c6.value);
    }
  }
  return {
    domain: domain === void 0 ? domain : coerceValues(domain),
    ...options
  };
}
function coerceSymbols(values2) {
  return map2(values2, maybeSymbol);
}
function exposeScales(scales) {
  return (key) => {
    if (!registry.has(key = `${key}`))
      throw new Error(`unknown scale: ${key}`);
    return scales[key];
  };
}
function exposeScale({ scale, type: type2, domain, range: range3, interpolate, interval: interval2, transform: transform2, percent, pivot }) {
  if (type2 === "identity")
    return { type: "identity", apply: (d3) => d3, invert: (d3) => d3 };
  const unknown = scale.unknown ? scale.unknown() : void 0;
  return {
    type: type2,
    domain: slice2(domain),
    // defensive copy
    ...range3 !== void 0 && { range: slice2(range3) },
    // defensive copy
    ...transform2 !== void 0 && { transform: transform2 },
    ...percent && { percent },
    // only exposed if truthy
    ...unknown !== void 0 && { unknown },
    ...interval2 !== void 0 && { interval: interval2 },
    // quantitative
    ...interpolate !== void 0 && { interpolate },
    ...scale.clamp && { clamp: scale.clamp() },
    // diverging (always asymmetric; we never want to apply the symmetric transform twice)
    ...pivot !== void 0 && { pivot, symmetric: false },
    // log, diverging-log
    ...scale.base && { base: scale.base() },
    // pow, diverging-pow
    ...scale.exponent && { exponent: scale.exponent() },
    // symlog, diverging-symlog
    ...scale.constant && { constant: scale.constant() },
    // band, point
    ...scale.align && { align: scale.align(), round: scale.round() },
    ...scale.padding && (scale.paddingInner ? { paddingInner: scale.paddingInner(), paddingOuter: scale.paddingOuter() } : { padding: scale.padding() }),
    ...scale.bandwidth && { bandwidth: scale.bandwidth(), step: scale.step() },
    // utilities
    apply: (t4) => scale(t4),
    ...scale.invert && { invert: (t4) => scale.invert(t4) }
  };
}

// node_modules/@observablehq/plot/src/dimensions.js
function createDimensions(scales, marks2, options = {}) {
  let marginTopDefault = 0.5 - offset, marginRightDefault = 0.5 + offset, marginBottomDefault = 0.5 + offset, marginLeftDefault = 0.5 - offset;
  for (const { marginTop: marginTop2, marginRight: marginRight2, marginBottom: marginBottom2, marginLeft: marginLeft2 } of marks2) {
    if (marginTop2 > marginTopDefault)
      marginTopDefault = marginTop2;
    if (marginRight2 > marginRightDefault)
      marginRightDefault = marginRight2;
    if (marginBottom2 > marginBottomDefault)
      marginBottomDefault = marginBottom2;
    if (marginLeft2 > marginLeftDefault)
      marginLeftDefault = marginLeft2;
  }
  let {
    margin,
    marginTop = margin !== void 0 ? margin : marginTopDefault,
    marginRight = margin !== void 0 ? margin : marginRightDefault,
    marginBottom = margin !== void 0 ? margin : marginBottomDefault,
    marginLeft = margin !== void 0 ? margin : marginLeftDefault
  } = options;
  marginTop = +marginTop;
  marginRight = +marginRight;
  marginBottom = +marginBottom;
  marginLeft = +marginLeft;
  let {
    width = 640,
    height = autoHeight(scales, options, {
      width,
      marginTopDefault,
      marginRightDefault,
      marginBottomDefault,
      marginLeftDefault
    }) + Math.max(0, marginTop - marginTopDefault + marginBottom - marginBottomDefault)
  } = options;
  width = +width;
  height = +height;
  const dimensions = {
    width,
    height,
    marginTop,
    marginRight,
    marginBottom,
    marginLeft
  };
  if (scales.fx || scales.fy) {
    let {
      margin: facetMargin,
      marginTop: facetMarginTop = facetMargin !== void 0 ? facetMargin : marginTop,
      marginRight: facetMarginRight = facetMargin !== void 0 ? facetMargin : marginRight,
      marginBottom: facetMarginBottom = facetMargin !== void 0 ? facetMargin : marginBottom,
      marginLeft: facetMarginLeft = facetMargin !== void 0 ? facetMargin : marginLeft
    } = options.facet ?? {};
    facetMarginTop = +facetMarginTop;
    facetMarginRight = +facetMarginRight;
    facetMarginBottom = +facetMarginBottom;
    facetMarginLeft = +facetMarginLeft;
    dimensions.facet = {
      marginTop: facetMarginTop,
      marginRight: facetMarginRight,
      marginBottom: facetMarginBottom,
      marginLeft: facetMarginLeft
    };
  }
  return dimensions;
}
function autoHeight({ x: x3, y: y3, fy, fx }, { projection: projection3, aspectRatio }, { width, marginTopDefault, marginRightDefault, marginBottomDefault, marginLeftDefault }) {
  const nfy = fy ? fy.scale.domain().length : 1;
  const ar = projectionAspectRatio(projection3);
  if (ar) {
    const nfx = fx ? fx.scale.domain().length : 1;
    const far = (1.1 * nfy - 0.1) / (1.1 * nfx - 0.1) * ar;
    const lar = Math.max(0.1, Math.min(10, far));
    return Math.round((width - marginLeftDefault - marginRightDefault) * lar + marginTopDefault + marginBottomDefault);
  }
  const ny = y3 ? isOrdinalScale(y3) ? y3.scale.domain().length : Math.max(7, 17 / nfy) : 1;
  if (aspectRatio != null) {
    aspectRatio = +aspectRatio;
    if (!(isFinite(aspectRatio) && aspectRatio > 0))
      throw new Error(`invalid aspectRatio: ${aspectRatio}`);
    const ratio = aspectRatioLength("y", y3) / (aspectRatioLength("x", x3) * aspectRatio);
    const fxb = fx ? fx.scale.bandwidth() : 1;
    const fyb = fy ? fy.scale.bandwidth() : 1;
    const w3 = fxb * (width - marginLeftDefault - marginRightDefault) - x3.insetLeft - x3.insetRight;
    return (ratio * w3 + y3.insetTop + y3.insetBottom) / fyb + marginTopDefault + marginBottomDefault;
  }
  return !!(y3 || fy) * Math.max(1, Math.min(60, ny * nfy)) * 20 + !!fx * 30 + 60;
}
function aspectRatioLength(k4, scale) {
  if (!scale)
    throw new Error(`aspectRatio requires ${k4} scale`);
  const { type: type2, domain } = scale;
  let transform2;
  switch (type2) {
    case "linear":
    case "utc":
    case "time":
      transform2 = Number;
      break;
    case "pow": {
      const exponent = scale.scale.exponent();
      transform2 = (x3) => Math.pow(x3, exponent);
      break;
    }
    case "log":
      transform2 = Math.log;
      break;
    case "point":
    case "band":
      return domain.length;
    default:
      throw new Error(`unsupported ${k4} scale for aspectRatio: ${type2}`);
  }
  const [min4, max3] = extent(domain);
  return Math.abs(transform2(max3) - transform2(min4));
}

// node_modules/@observablehq/plot/src/facet.js
function createFacets(channelsByScale, options) {
  const { fx, fy } = createScales(channelsByScale, options);
  const fxDomain = fx?.scale.domain();
  const fyDomain = fy?.scale.domain();
  return fxDomain && fyDomain ? cross(fxDomain, fyDomain).map(([x3, y3], i3) => ({ x: x3, y: y3, i: i3 })) : fxDomain ? fxDomain.map((x3, i3) => ({ x: x3, i: i3 })) : fyDomain ? fyDomain.map((y3, i3) => ({ y: y3, i: i3 })) : void 0;
}
function recreateFacets(facets, { x: X3, y: Y3 }) {
  X3 &&= facetIndex(X3);
  Y3 &&= facetIndex(Y3);
  return facets.filter(
    X3 && Y3 ? (f3) => X3.has(f3.x) && Y3.has(f3.y) : X3 ? (f3) => X3.has(f3.x) : (f3) => Y3.has(f3.y)
  ).sort(
    X3 && Y3 ? (a4, b3) => X3.get(a4.x) - X3.get(b3.x) || Y3.get(a4.y) - Y3.get(b3.y) : X3 ? (a4, b3) => X3.get(a4.x) - X3.get(b3.x) : (a4, b3) => Y3.get(a4.y) - Y3.get(b3.y)
  );
}
function facetGroups(data, { fx, fy }) {
  const I2 = range2(data);
  const FX = fx?.value;
  const FY = fy?.value;
  return fx && fy ? rollup(
    I2,
    (G) => (G.fx = FX[G[0]], G.fy = FY[G[0]], G),
    (i3) => FX[i3],
    (i3) => FY[i3]
  ) : fx ? rollup(
    I2,
    (G) => (G.fx = FX[G[0]], G),
    (i3) => FX[i3]
  ) : rollup(
    I2,
    (G) => (G.fy = FY[G[0]], G),
    (i3) => FY[i3]
  );
}
function facetTranslator(fx, fy, { marginTop, marginLeft }) {
  return fx && fy ? ({ x: x3, y: y3 }) => `translate(${fx(x3) - marginLeft},${fy(y3) - marginTop})` : fx ? ({ x: x3 }) => `translate(${fx(x3) - marginLeft},0)` : ({ y: y3 }) => `translate(0,${fy(y3) - marginTop})`;
}
function facetExclude(index2) {
  const ex = [];
  const e3 = new Uint32Array(sum(index2, (d3) => d3.length));
  for (const i3 of index2) {
    let n2 = 0;
    for (const j3 of index2) {
      if (i3 === j3)
        continue;
      e3.set(j3, n2);
      n2 += j3.length;
    }
    ex.push(e3.slice(0, n2));
  }
  return ex;
}
var facetAnchors = /* @__PURE__ */ new Map([
  ["top", facetAnchorTop],
  ["right", facetAnchorRight],
  ["bottom", facetAnchorBottom],
  ["left", facetAnchorLeft],
  ["top-left", and(facetAnchorTop, facetAnchorLeft)],
  ["top-right", and(facetAnchorTop, facetAnchorRight)],
  ["bottom-left", and(facetAnchorBottom, facetAnchorLeft)],
  ["bottom-right", and(facetAnchorBottom, facetAnchorRight)],
  ["top-empty", facetAnchorTopEmpty],
  ["right-empty", facetAnchorRightEmpty],
  ["bottom-empty", facetAnchorBottomEmpty],
  ["left-empty", facetAnchorLeftEmpty],
  ["empty", facetAnchorEmpty]
]);
function maybeFacetAnchor(facetAnchor) {
  if (facetAnchor == null)
    return null;
  const anchor = facetAnchors.get(`${facetAnchor}`.toLowerCase());
  if (anchor)
    return anchor;
  throw new Error(`invalid facet anchor: ${facetAnchor}`);
}
var indexCache = /* @__PURE__ */ new WeakMap();
function facetIndex(V) {
  let I2 = indexCache.get(V);
  if (!I2)
    indexCache.set(V, I2 = new InternMap(map2(V, (v3, i3) => [v3, i3])));
  return I2;
}
function facetIndexOf(V, v3) {
  return facetIndex(V).get(v3);
}
function facetFind(facets, x3, y3) {
  x3 = keyof2(x3);
  y3 = keyof2(y3);
  return facets.find((f3) => Object.is(keyof2(f3.x), x3) && Object.is(keyof2(f3.y), y3));
}
function facetEmpty(facets, x3, y3) {
  return facetFind(facets, x3, y3)?.empty;
}
function facetAnchorTop(facets, { y: Y3 }, { y: y3 }) {
  return Y3 ? facetIndexOf(Y3, y3) === 0 : true;
}
function facetAnchorBottom(facets, { y: Y3 }, { y: y3 }) {
  return Y3 ? facetIndexOf(Y3, y3) === Y3.length - 1 : true;
}
function facetAnchorLeft(facets, { x: X3 }, { x: x3 }) {
  return X3 ? facetIndexOf(X3, x3) === 0 : true;
}
function facetAnchorRight(facets, { x: X3 }, { x: x3 }) {
  return X3 ? facetIndexOf(X3, x3) === X3.length - 1 : true;
}
function facetAnchorTopEmpty(facets, { y: Y3 }, { x: x3, y: y3, empty: empty3 }) {
  if (empty3)
    return false;
  if (!Y3)
    return;
  const i3 = facetIndexOf(Y3, y3);
  if (i3 > 0)
    return facetEmpty(facets, x3, Y3[i3 - 1]);
}
function facetAnchorBottomEmpty(facets, { y: Y3 }, { x: x3, y: y3, empty: empty3 }) {
  if (empty3)
    return false;
  if (!Y3)
    return;
  const i3 = facetIndexOf(Y3, y3);
  if (i3 < Y3.length - 1)
    return facetEmpty(facets, x3, Y3[i3 + 1]);
}
function facetAnchorLeftEmpty(facets, { x: X3 }, { x: x3, y: y3, empty: empty3 }) {
  if (empty3)
    return false;
  if (!X3)
    return;
  const i3 = facetIndexOf(X3, x3);
  if (i3 > 0)
    return facetEmpty(facets, X3[i3 - 1], y3);
}
function facetAnchorRightEmpty(facets, { x: X3 }, { x: x3, y: y3, empty: empty3 }) {
  if (empty3)
    return false;
  if (!X3)
    return;
  const i3 = facetIndexOf(X3, x3);
  if (i3 < X3.length - 1)
    return facetEmpty(facets, X3[i3 + 1], y3);
}
function facetAnchorEmpty(facets, channels, { empty: empty3 }) {
  return empty3;
}
function and(a4, b3) {
  return function() {
    return a4.apply(null, arguments) && b3.apply(null, arguments);
  };
}
function facetFilter(facets, { channels: { fx, fy }, groups: groups2 }) {
  return fx && fy ? facets.map(({ x: x3, y: y3 }) => groups2.get(x3)?.get(y3) ?? []) : fx ? facets.map(({ x: x3 }) => groups2.get(x3) ?? []) : facets.map(({ y: y3 }) => groups2.get(y3) ?? []);
}

// node_modules/@observablehq/plot/src/mark.js
var Mark = class {
  constructor(data, channels = {}, options = {}, defaults8) {
    const {
      facet = "auto",
      facetAnchor,
      fx,
      fy,
      sort: sort3,
      dx = 0,
      dy = 0,
      margin = 0,
      marginTop = margin,
      marginRight = margin,
      marginBottom = margin,
      marginLeft = margin,
      clip = defaults8?.clip,
      channels: extraChannels,
      tip: tip2,
      render
    } = options;
    this.data = data;
    this.sort = isDomainSort(sort3) ? sort3 : null;
    this.initializer = initializer(options).initializer;
    this.transform = this.initializer ? options.transform : basic(options).transform;
    if (facet === null || facet === false) {
      this.facet = null;
    } else {
      this.facet = keyword(facet === true ? "include" : facet, "facet", ["auto", "include", "exclude", "super"]);
      this.fx = data === singleton && typeof fx === "string" ? [fx] : fx;
      this.fy = data === singleton && typeof fy === "string" ? [fy] : fy;
    }
    this.facetAnchor = maybeFacetAnchor(facetAnchor);
    channels = maybeNamed(channels);
    if (extraChannels !== void 0)
      channels = { ...maybeChannels(extraChannels), ...channels };
    if (defaults8 !== void 0)
      channels = { ...styles(this, options, defaults8), ...channels };
    this.channels = Object.fromEntries(
      Object.entries(channels).map(([name, channel]) => {
        if (isOptions(channel.value)) {
          const { value, label = channel.label, scale = channel.scale } = channel.value;
          channel = { ...channel, label, scale, value };
        }
        if (data === singleton && typeof channel.value === "string") {
          const { value } = channel;
          channel = { ...channel, value: [value] };
        }
        return [name, channel];
      }).filter(([name, { value, optional }]) => {
        if (value != null)
          return true;
        if (optional)
          return false;
        throw new Error(`missing channel value: ${name}`);
      })
    );
    this.dx = +dx;
    this.dy = +dy;
    this.marginTop = +marginTop;
    this.marginRight = +marginRight;
    this.marginBottom = +marginBottom;
    this.marginLeft = +marginLeft;
    this.clip = maybeClip(clip);
    this.tip = maybeTip(tip2);
    if (this.facet === "super") {
      if (fx || fy)
        throw new Error(`super-faceting cannot use fx or fy`);
      for (const name in this.channels) {
        const { scale } = channels[name];
        if (scale !== "x" && scale !== "y")
          continue;
        throw new Error(`super-faceting cannot use x or y`);
      }
    }
    if (render != null) {
      this.render = composeRender(render, this.render);
    }
  }
  initialize(facets, facetChannels, plotOptions) {
    let data = arrayify2(this.data);
    if (facets === void 0 && data != null)
      facets = [range2(data)];
    const originalFacets = facets;
    if (this.transform != null)
      ({ facets, data } = this.transform(data, facets, plotOptions)), data = arrayify2(data);
    if (facets !== void 0)
      facets.original = originalFacets;
    const channels = createChannels(this.channels, data);
    if (this.sort != null)
      channelDomain(data, facets, channels, facetChannels, this.sort);
    return { data, facets, channels };
  }
  filter(index2, channels, values2) {
    for (const name in channels) {
      const { filter: filter2 = defined } = channels[name];
      if (filter2 !== null) {
        const value = values2[name];
        index2 = index2.filter((i3) => filter2(value[i3]));
      }
    }
    return index2;
  }
  // If there is a projection, and there are paired x and y channels associated
  // with the x and y scale respectively (and not already in screen coordinates
  // as with an initializer), then apply the projection, replacing the x and y
  // values. Note that the x and y scales themselves dont exist if there is a
  // projection, but whether the channels are associated with scales still
  // determines whether the projection should apply; think of the projection as
  // a combination xy-scale.
  project(channels, values2, context) {
    for (const cx in channels) {
      if (channels[cx].scale === "x" && /^x|x$/.test(cx)) {
        const cy = cx.replace(/^x|x$/, "y");
        if (cy in channels && channels[cy].scale === "y") {
          project(cx, cy, values2, context.projection);
        }
      }
    }
  }
  scale(channels, scales, context) {
    const values2 = valueObject(channels, scales);
    if (context.projection)
      this.project(channels, values2, context);
    return values2;
  }
};
function marks(...marks2) {
  marks2.plot = Mark.prototype.plot;
  return marks2;
}
function composeRender(r1, r22) {
  if (r1 == null)
    return r22 === null ? void 0 : r22;
  if (r22 == null)
    return r1 === null ? void 0 : r1;
  if (typeof r1 !== "function")
    throw new TypeError(`invalid render transform: ${r1}`);
  if (typeof r22 !== "function")
    throw new TypeError(`invalid render transform: ${r22}`);
  return function(i3, s4, v3, d3, c6, next) {
    return r1.call(this, i3, s4, v3, d3, c6, (i4, s5, v4, d4, c7) => {
      return r22.call(this, i4, s5, v4, d4, c7, next);
    });
  };
}
function maybeChannels(channels) {
  return Object.fromEntries(
    Object.entries(maybeNamed(channels)).map(([name, channel]) => {
      channel = typeof channel === "string" ? { value: channel, label: name } : maybeValue(channel);
      if (channel.filter === void 0 && channel.scale == null)
        channel = { ...channel, filter: null };
      return [name, channel];
    })
  );
}
function maybeTip(tip2) {
  return tip2 === true ? "xy" : tip2 === false || tip2 == null ? null : typeof tip2 === "string" ? keyword(tip2, "tip", ["x", "y", "xy"]) : tip2;
}
function withTip(options, pointer2) {
  return options?.tip === true ? { ...options, tip: pointer2 } : isObject(options?.tip) && options.tip.pointer === void 0 ? { ...options, tip: { ...options.tip, pointer: pointer2 } } : options;
}

// node_modules/@observablehq/plot/src/interactions/pointer.js
var states = /* @__PURE__ */ new WeakMap();
function pointerK(kx2, ky2, { x: x3, y: y3, px, py, maxRadius = 40, channels, render, ...options } = {}) {
  maxRadius = +maxRadius;
  if (px != null)
    x3 ??= null, channels = { ...channels, px: { value: px, scale: "x" } };
  if (py != null)
    y3 ??= null, channels = { ...channels, py: { value: py, scale: "y" } };
  return {
    x: x3,
    y: y3,
    channels,
    ...options,
    // Unlike other composed transforms, the render transform must be the
    // outermost render function because it will re-render dynamically in
    // response to pointer events.
    render: composeRender(function(index2, scales, values2, dimensions, context, next) {
      context = { ...context, pointerSticky: false };
      const svg = context.ownerSVGElement;
      const { data } = context.getMarkState(this);
      let state = states.get(svg);
      if (!state)
        states.set(svg, state = { sticky: false, roots: [], renders: [] });
      let renderIndex = state.renders.push(render2) - 1;
      const { x: x4, y: y4, fx, fy } = scales;
      let tx = fx ? fx(index2.fx) - dimensions.marginLeft : 0;
      let ty = fy ? fy(index2.fy) - dimensions.marginTop : 0;
      if (x4?.bandwidth)
        tx += x4.bandwidth() / 2;
      if (y4?.bandwidth)
        ty += y4.bandwidth() / 2;
      const faceted = index2.fi != null;
      let facetState;
      if (faceted) {
        let facetStates = state.facetStates;
        if (!facetStates)
          state.facetStates = facetStates = /* @__PURE__ */ new Map();
        facetState = facetStates.get(this);
        if (!facetState)
          facetStates.set(this, facetState = /* @__PURE__ */ new Map());
      }
      const [cx, cy] = applyFrameAnchor(this, dimensions);
      const { px: PX, py: PY } = values2;
      const px2 = PX ? (i4) => PX[i4] : anchorX(values2, cx);
      const py2 = PY ? (i4) => PY[i4] : anchorY(values2, cy);
      let i3;
      let g3;
      let s4;
      let f3;
      function update(ii, ri) {
        if (faceted) {
          if (f3)
            f3 = cancelAnimationFrame(f3);
          if (ii == null)
            facetState.delete(index2.fi);
          else {
            facetState.set(index2.fi, ri);
            f3 = requestAnimationFrame(() => {
              f3 = null;
              for (const [fi, r3] of facetState) {
                if (r3 < ri || r3 === ri && fi < index2.fi) {
                  ii = null;
                  break;
                }
              }
              render2(ii);
            });
            return;
          }
        }
        render2(ii);
      }
      function render2(ii) {
        if (i3 === ii && s4 === state.sticky)
          return;
        i3 = ii;
        s4 = context.pointerSticky = state.sticky;
        const I2 = i3 == null ? [] : [i3];
        if (faceted)
          I2.fx = index2.fx, I2.fy = index2.fy, I2.fi = index2.fi;
        const r3 = next(I2, scales, values2, dimensions, context);
        if (g3) {
          if (faceted) {
            const p3 = g3.parentNode;
            const ft = g3.getAttribute("transform");
            const mt = r3.getAttribute("transform");
            ft ? r3.setAttribute("transform", ft) : r3.removeAttribute("transform");
            mt ? p3.setAttribute("transform", mt) : p3.removeAttribute("transform");
            r3.removeAttribute("aria-label");
            r3.removeAttribute("aria-description");
            r3.removeAttribute("aria-hidden");
          }
          g3.replaceWith(r3);
        }
        state.roots[renderIndex] = g3 = r3;
        if (!(i3 == null && facetState?.size > 1))
          context.dispatchValue(i3 == null ? null : data[i3]);
        return r3;
      }
      function pointermove(event) {
        if (state.sticky || event.pointerType === "mouse" && event.buttons === 1)
          return;
        let [xp, yp] = pointer_default(event);
        xp -= tx, yp -= ty;
        const kpx = xp < dimensions.marginLeft || xp > dimensions.width - dimensions.marginRight ? 1 : kx2;
        const kpy = yp < dimensions.marginTop || yp > dimensions.height - dimensions.marginBottom ? 1 : ky2;
        let ii = null;
        let ri = maxRadius * maxRadius;
        for (const j3 of index2) {
          const dx = kpx * (px2(j3) - xp);
          const dy = kpy * (py2(j3) - yp);
          const rj = dx * dx + dy * dy;
          if (rj <= ri)
            ii = j3, ri = rj;
        }
        if (ii != null && (kx2 !== 1 || ky2 !== 1)) {
          const dx = px2(ii) - xp;
          const dy = py2(ii) - yp;
          ri = dx * dx + dy * dy;
        }
        update(ii, ri);
      }
      function pointerdown(event) {
        if (event.pointerType !== "mouse")
          return;
        if (i3 == null)
          return;
        if (state.sticky && state.roots.some((r3) => r3?.contains(event.target)))
          return;
        if (state.sticky)
          state.sticky = false, state.renders.forEach((r3) => r3(null));
        else
          state.sticky = true, render2(i3);
        event.stopImmediatePropagation();
      }
      function pointerleave(event) {
        if (event.pointerType !== "mouse")
          return;
        if (!state.sticky)
          update(null);
      }
      svg.addEventListener("pointerenter", pointermove);
      svg.addEventListener("pointermove", pointermove);
      svg.addEventListener("pointerdown", pointerdown);
      svg.addEventListener("pointerleave", pointerleave);
      return render2(null);
    }, render)
  };
}
function pointer(options) {
  return pointerK(1, 1, options);
}
function pointerX(options) {
  return pointerK(1, 0.01, options);
}
function pointerY(options) {
  return pointerK(0.01, 1, options);
}
function anchorX({ x1: X12, x2: X22, x: X3 = X12 }, cx) {
  return X12 && X22 ? (i3) => (X12[i3] + X22[i3]) / 2 : X3 ? (i3) => X3[i3] : () => cx;
}
function anchorY({ y1: Y12, y2: Y22, y: Y3 = Y12 }, cy) {
  return Y12 && Y22 ? (i3) => (Y12[i3] + Y22[i3]) / 2 : Y3 ? (i3) => Y3[i3] : () => cy;
}

// node_modules/@observablehq/plot/src/axes.js
function inferFontVariant(scale) {
  return isOrdinalScale(scale) && scale.interval === void 0 ? void 0 : "tabular-nums";
}

// node_modules/@observablehq/plot/src/legends/ramp.js
function legendRamp(color3, options) {
  let {
    label = color3.label,
    tickSize = 6,
    width = 240,
    height = 44 + tickSize,
    marginTop = 18,
    marginRight = 0,
    marginBottom = 16 + tickSize,
    marginLeft = 0,
    style,
    ticks: ticks2 = (width - marginLeft - marginRight) / 64,
    tickFormat: tickFormat2,
    fontVariant = inferFontVariant(color3),
    round = true,
    opacity: opacity2,
    className
  } = options;
  const context = createContext(options);
  className = maybeClassName(className);
  opacity2 = maybeNumberChannel(opacity2)[1];
  if (tickFormat2 === null)
    tickFormat2 = () => null;
  const svg = create2("svg", context).attr("class", `${className}-ramp`).attr("font-family", "system-ui, sans-serif").attr("font-size", 10).attr("width", width).attr("height", height).attr("viewBox", `0 0 ${width} ${height}`).call(
    (svg2) => (
      // Warning: if you edit this, change defaultClassName.
      svg2.append("style").text(
        `.${className}-ramp {
  display: block;
  background: white;
  height: auto;
  height: intrinsic;
  max-width: 100%;
  overflow: visible;
}
.${className}-ramp text {
  white-space: pre;
}`
      )
    )
  ).call(applyInlineStyles, style);
  let tickAdjust = (g3) => g3.selectAll(".tick line").attr("y1", marginTop + marginBottom - height);
  let x3;
  const applyRange = round ? (x4, range4) => x4.rangeRound(range4) : (x4, range4) => x4.range(range4);
  const { type: type2, domain, range: range3, interpolate, scale, pivot } = color3;
  if (interpolate) {
    const interpolator = range3 === void 0 ? interpolate : piecewise(interpolate.length === 1 ? interpolatePiecewise(interpolate) : interpolate, range3);
    x3 = applyRange(
      scale.copy(),
      quantize_default(
        number_default(marginLeft, width - marginRight),
        Math.min(domain.length + (pivot !== void 0), range3 === void 0 ? Infinity : range3.length)
      )
    );
    const n2 = 256;
    const canvas = context.document.createElement("canvas");
    canvas.width = n2;
    canvas.height = 1;
    const context2 = canvas.getContext("2d");
    for (let i3 = 0, j3 = n2 - 1; i3 < n2; ++i3) {
      context2.fillStyle = interpolator(i3 / j3);
      context2.fillRect(i3, 0, 1, 1);
    }
    svg.append("image").attr("opacity", opacity2).attr("x", marginLeft).attr("y", marginTop).attr("width", width - marginLeft - marginRight).attr("height", height - marginTop - marginBottom).attr("preserveAspectRatio", "none").attr("xlink:href", canvas.toDataURL());
  } else if (type2 === "threshold") {
    const thresholds = domain;
    const thresholdFormat = tickFormat2 === void 0 ? (d3) => d3 : typeof tickFormat2 === "string" ? format(tickFormat2) : tickFormat2;
    x3 = applyRange(linear2().domain([-1, range3.length - 1]), [marginLeft, width - marginRight]);
    svg.append("g").attr("fill-opacity", opacity2).selectAll().data(range3).enter().append("rect").attr("x", (d3, i3) => x3(i3 - 1)).attr("y", marginTop).attr("width", (d3, i3) => x3(i3) - x3(i3 - 1)).attr("height", height - marginTop - marginBottom).attr("fill", (d3) => d3);
    ticks2 = map2(thresholds, (_2, i3) => i3);
    tickFormat2 = (i3) => thresholdFormat(thresholds[i3], i3);
  } else {
    x3 = applyRange(band().domain(domain), [marginLeft, width - marginRight]);
    svg.append("g").attr("fill-opacity", opacity2).selectAll().data(domain).enter().append("rect").attr("x", x3).attr("y", marginTop).attr("width", Math.max(0, x3.bandwidth() - 1)).attr("height", height - marginTop - marginBottom).attr("fill", scale);
    tickAdjust = () => {
    };
  }
  svg.append("g").attr("transform", `translate(0,${height - marginBottom})`).call(
    axisBottom(x3).ticks(Array.isArray(ticks2) ? null : ticks2, typeof tickFormat2 === "string" ? tickFormat2 : void 0).tickFormat(typeof tickFormat2 === "function" ? tickFormat2 : void 0).tickSize(tickSize).tickValues(Array.isArray(ticks2) ? ticks2 : null)
  ).attr("font-size", null).attr("font-family", null).attr("font-variant", impliedString(fontVariant, "normal")).call(tickAdjust).call((g3) => g3.select(".domain").remove());
  if (label !== void 0) {
    svg.append("text").attr("x", marginLeft).attr("y", marginTop - 6).attr("fill", "currentColor").attr("font-weight", "bold").text(label);
  }
  return svg.node();
}

// node_modules/@observablehq/plot/src/math.js
var radians3 = Math.PI / 180;

// node_modules/@observablehq/plot/src/marker.js
function markers(mark, { marker, markerStart = marker, markerMid = marker, markerEnd = marker } = {}) {
  mark.markerStart = maybeMarker(markerStart);
  mark.markerMid = maybeMarker(markerMid);
  mark.markerEnd = maybeMarker(markerEnd);
}
function maybeMarker(marker) {
  if (marker == null || marker === false)
    return null;
  if (marker === true)
    return markerCircleFill;
  if (typeof marker === "function")
    return marker;
  switch (`${marker}`.toLowerCase()) {
    case "none":
      return null;
    case "arrow":
      return markerArrow("auto");
    case "arrow-reverse":
      return markerArrow("auto-start-reverse");
    case "dot":
      return markerDot;
    case "circle":
    case "circle-fill":
      return markerCircleFill;
    case "circle-stroke":
      return markerCircleStroke;
  }
  throw new Error(`invalid marker: ${marker}`);
}
function markerArrow(orient) {
  return (color3, context) => create2("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("orient", orient).attr("fill", "none").attr("stroke", color3).attr("stroke-width", 1.5).attr("stroke-linecap", "round").attr("stroke-linejoin", "round").call((marker) => marker.append("path").attr("d", "M-1.5,-3l3,3l-3,3")).node();
}
function markerDot(color3, context) {
  return create2("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", color3).attr("stroke", "none").call((marker) => marker.append("circle").attr("r", 2.5)).node();
}
function markerCircleFill(color3, context) {
  return create2("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", color3).attr("stroke", "white").attr("stroke-width", 1.5).call((marker) => marker.append("circle").attr("r", 3)).node();
}
function markerCircleStroke(color3, context) {
  return create2("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", "white").attr("stroke", color3).attr("stroke-width", 1.5).call((marker) => marker.append("circle").attr("r", 3)).node();
}
var nextMarkerId = 0;
function applyMarkers(path2, mark, { stroke: S2 }, context) {
  return applyMarkersColor(path2, mark, S2 && ((i3) => S2[i3]), context);
}
function applyMarkersColor(path2, { markerStart, markerMid, markerEnd, stroke }, strokeof = () => stroke, context) {
  const iriByMarkerColor = /* @__PURE__ */ new Map();
  function applyMarker(marker) {
    return function(i3) {
      const color3 = strokeof(i3);
      let iriByColor = iriByMarkerColor.get(marker);
      if (!iriByColor)
        iriByMarkerColor.set(marker, iriByColor = /* @__PURE__ */ new Map());
      let iri = iriByColor.get(color3);
      if (!iri) {
        const node = this.parentNode.insertBefore(marker(color3, context), this);
        const id2 = `plot-marker-${++nextMarkerId}`;
        node.setAttribute("id", id2);
        iriByColor.set(color3, iri = `url(#${id2})`);
      }
      return iri;
    };
  }
  if (markerStart)
    path2.attr("marker-start", applyMarker(markerStart));
  if (markerMid)
    path2.attr("marker-mid", applyMarker(markerMid));
  if (markerEnd)
    path2.attr("marker-end", applyMarker(markerEnd));
}

// node_modules/@observablehq/plot/src/transforms/inset.js
function maybeInsetX({ inset, insetLeft, insetRight, ...options } = {}) {
  [insetLeft, insetRight] = maybeInset(inset, insetLeft, insetRight);
  return { inset, insetLeft, insetRight, ...options };
}
function maybeInsetY({ inset, insetTop, insetBottom, ...options } = {}) {
  [insetTop, insetBottom] = maybeInset(inset, insetTop, insetBottom);
  return { inset, insetTop, insetBottom, ...options };
}
function maybeInset(inset, inset1, inset2) {
  return inset === void 0 && inset1 === void 0 && inset2 === void 0 ? offset ? [1, 0] : [0.5, 0.5] : [inset1, inset2];
}

// node_modules/@observablehq/plot/src/transforms/interval.js
function maybeIntervalValue(value, { interval: interval2 }) {
  value = { ...maybeValue(value) };
  value.interval = maybeInterval(value.interval === void 0 ? interval2 : value.interval);
  return value;
}
function maybeIntervalK(k4, maybeInsetK, options, trivial) {
  const { [k4]: v3, [`${k4}1`]: v1, [`${k4}2`]: v22 } = options;
  const { value, interval: interval2 } = maybeIntervalValue(v3, options);
  if (value == null || interval2 == null && !trivial)
    return options;
  const label = labelof(v3);
  if (interval2 == null) {
    let V;
    const kv = { transform: (data) => V || (V = valueof(data, value)), label };
    return {
      ...options,
      [k4]: void 0,
      [`${k4}1`]: v1 === void 0 ? kv : v1,
      [`${k4}2`]: v22 === void 0 ? kv : v22
    };
  }
  let D1, V1;
  function transform2(data) {
    if (V1 !== void 0 && data === D1)
      return V1;
    return V1 = map2(valueof(D1 = data, value), (v4) => interval2.floor(v4));
  }
  return maybeInsetK({
    ...options,
    [k4]: void 0,
    [`${k4}1`]: v1 === void 0 ? { transform: transform2, label } : v1,
    [`${k4}2`]: v22 === void 0 ? { transform: (data) => transform2(data).map((v4) => interval2.offset(v4)), label } : v22
  });
}
function maybeIntervalMidK(k4, maybeInsetK, options) {
  const { [k4]: v3 } = options;
  const { value, interval: interval2 } = maybeIntervalValue(v3, options);
  if (value == null || interval2 == null)
    return options;
  return maybeInsetK({
    ...options,
    [k4]: {
      label: labelof(v3),
      transform: (data) => {
        const V1 = map2(valueof(data, value), (v4) => interval2.floor(v4));
        const V2 = V1.map((v4) => interval2.offset(v4));
        return V1.map(
          isTemporal(V1) ? (v1, v22) => v1 == null || isNaN(v1 = +v1) || (v22 = V2[v22], v22 == null) || isNaN(v22 = +v22) ? void 0 : new Date((v1 + v22) / 2) : (v1, v22) => v1 == null || (v22 = V2[v22], v22 == null) ? NaN : (+v1 + +v22) / 2
        );
      }
    }
  });
}
function maybeIntervalX(options = {}) {
  return maybeIntervalK("x", maybeInsetX, options);
}
function maybeIntervalY(options = {}) {
  return maybeIntervalK("y", maybeInsetY, options);
}
function maybeIntervalMidX(options = {}) {
  return maybeIntervalMidK("x", maybeInsetX, options);
}
function maybeIntervalMidY(options = {}) {
  return maybeIntervalMidK("y", maybeInsetY, options);
}

// node_modules/@observablehq/plot/src/marks/rule.js
var defaults = {
  ariaLabel: "rule",
  fill: null,
  stroke: "currentColor"
};
var RuleX = class extends Mark {
  constructor(data, options = {}) {
    const { x: x3, y1: y12, y2: y22, inset = 0, insetTop = inset, insetBottom = inset } = options;
    super(
      data,
      {
        x: { value: x3, scale: "x", optional: true },
        y1: { value: y12, scale: "y", optional: true },
        y2: { value: y22, scale: "y", optional: true }
      },
      withTip(options, "x"),
      defaults
    );
    this.insetTop = number5(insetTop);
    this.insetBottom = number5(insetBottom);
    markers(this, options);
  }
  render(index2, scales, channels, dimensions, context) {
    const { x: x3, y: y3 } = scales;
    const { x: X3, y1: Y12, y2: Y22 } = channels;
    const { width, height, marginTop, marginRight, marginLeft, marginBottom } = dimensions;
    const { insetTop, insetBottom } = this;
    return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x3 }, offset, 0).call(
      (g3) => g3.selectAll().data(index2).enter().append("line").call(applyDirectStyles, this).attr("x1", X3 ? (i3) => X3[i3] : (marginLeft + width - marginRight) / 2).attr("x2", X3 ? (i3) => X3[i3] : (marginLeft + width - marginRight) / 2).attr("y1", Y12 && !isCollapsed(y3) ? (i3) => Y12[i3] + insetTop : marginTop + insetTop).attr(
        "y2",
        Y22 && !isCollapsed(y3) ? y3.bandwidth ? (i3) => Y22[i3] + y3.bandwidth() - insetBottom : (i3) => Y22[i3] - insetBottom : height - marginBottom - insetBottom
      ).call(applyChannelStyles, this, channels).call(applyMarkers, this, channels, context)
    ).node();
  }
};
var RuleY = class extends Mark {
  constructor(data, options = {}) {
    const { x1: x12, x2: x22, y: y3, inset = 0, insetRight = inset, insetLeft = inset } = options;
    super(
      data,
      {
        y: { value: y3, scale: "y", optional: true },
        x1: { value: x12, scale: "x", optional: true },
        x2: { value: x22, scale: "x", optional: true }
      },
      withTip(options, "y"),
      defaults
    );
    this.insetRight = number5(insetRight);
    this.insetLeft = number5(insetLeft);
    markers(this, options);
  }
  render(index2, scales, channels, dimensions, context) {
    const { x: x3, y: y3 } = scales;
    const { y: Y3, x1: X12, x2: X22 } = channels;
    const { width, height, marginTop, marginRight, marginLeft, marginBottom } = dimensions;
    const { insetLeft, insetRight } = this;
    return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { y: Y3 && y3 }, 0, offset).call(
      (g3) => g3.selectAll().data(index2).enter().append("line").call(applyDirectStyles, this).attr("x1", X12 && !isCollapsed(x3) ? (i3) => X12[i3] + insetLeft : marginLeft + insetLeft).attr(
        "x2",
        X22 && !isCollapsed(x3) ? x3.bandwidth ? (i3) => X22[i3] + x3.bandwidth() - insetRight : (i3) => X22[i3] - insetRight : width - marginRight - insetRight
      ).attr("y1", Y3 ? (i3) => Y3[i3] : (marginTop + height - marginBottom) / 2).attr("y2", Y3 ? (i3) => Y3[i3] : (marginTop + height - marginBottom) / 2).call(applyChannelStyles, this, channels).call(applyMarkers, this, channels, context)
    ).node();
  }
};
function ruleX(data, options) {
  let { x: x3 = identity6, y: y3, y1: y12, y2: y22, ...rest } = maybeIntervalY(options);
  [y12, y22] = maybeOptionalZero(y3, y12, y22);
  return new RuleX(data, { ...rest, x: x3, y1: y12, y2: y22 });
}
function ruleY(data, options) {
  let { y: y3 = identity6, x: x3, x1: x12, x2: x22, ...rest } = maybeIntervalX(options);
  [x12, x22] = maybeOptionalZero(x3, x12, x22);
  return new RuleY(data, { ...rest, y: y3, x1: x12, x2: x22 });
}
function maybeOptionalZero(x3, x12, x22) {
  if (x3 == null) {
    if (x12 === void 0) {
      if (x22 !== void 0)
        return [0, x22];
    } else {
      if (x22 === void 0)
        return [0, x12];
    }
  } else if (x12 === void 0) {
    return x22 === void 0 ? [0, x3] : [x3, x22];
  } else if (x22 === void 0) {
    return [x3, x12];
  }
  return [x12, x22];
}

// node_modules/@observablehq/plot/src/template.js
function template(strings, ...parts) {
  let n2 = parts.length;
  for (let j3 = 0, copy3 = true; j3 < n2; ++j3) {
    if (typeof parts[j3] !== "function") {
      if (copy3) {
        strings = strings.slice();
        copy3 = false;
      }
      strings.splice(j3, 2, strings[j3] + parts[j3] + strings[j3 + 1]);
      parts.splice(j3, 1);
      --j3, --n2;
    }
  }
  return (i3) => {
    let s4 = strings[0];
    for (let j3 = 0; j3 < n2; ++j3) {
      s4 += parts[j3](i3) + strings[j3 + 1];
    }
    return s4;
  };
}

// node_modules/@observablehq/plot/src/marks/text.js
var defaults2 = {
  ariaLabel: "text",
  strokeLinejoin: "round",
  strokeWidth: 3,
  paintOrder: "stroke"
};
var softHyphen = "\xAD";
var Text = class extends Mark {
  constructor(data, options = {}) {
    const {
      x: x3,
      y: y3,
      text: text2 = isIterable(data) && isTextual(data) ? identity6 : indexOf,
      frameAnchor,
      textAnchor = /right$/i.test(frameAnchor) ? "end" : /left$/i.test(frameAnchor) ? "start" : "middle",
      lineAnchor = /^top/i.test(frameAnchor) ? "top" : /^bottom/i.test(frameAnchor) ? "bottom" : "middle",
      lineHeight = 1,
      lineWidth = Infinity,
      textOverflow,
      monospace,
      fontFamily = monospace ? "ui-monospace, monospace" : void 0,
      fontSize,
      fontStyle,
      fontVariant,
      fontWeight,
      rotate
    } = options;
    const [vrotate, crotate] = maybeNumberChannel(rotate, 0);
    const [vfontSize, cfontSize] = maybeFontSizeChannel(fontSize);
    super(
      data,
      {
        x: { value: x3, scale: "x", optional: true },
        y: { value: y3, scale: "y", optional: true },
        fontSize: { value: vfontSize, optional: true },
        rotate: { value: numberChannel(vrotate), optional: true },
        text: { value: text2, filter: nonempty, optional: true }
      },
      options,
      defaults2
    );
    this.rotate = crotate;
    this.textAnchor = impliedString(textAnchor, "middle");
    this.lineAnchor = keyword(lineAnchor, "lineAnchor", ["top", "middle", "bottom"]);
    this.lineHeight = +lineHeight;
    this.lineWidth = +lineWidth;
    this.textOverflow = maybeTextOverflow(textOverflow);
    this.monospace = !!monospace;
    this.fontFamily = string(fontFamily);
    this.fontSize = cfontSize;
    this.fontStyle = string(fontStyle);
    this.fontVariant = string(fontVariant);
    this.fontWeight = string(fontWeight);
    this.frameAnchor = maybeFrameAnchor(frameAnchor);
    if (!(this.lineWidth >= 0))
      throw new Error(`invalid lineWidth: ${lineWidth}`);
    this.splitLines = splitter(this);
    this.clipLine = clipper(this);
  }
  render(index2, scales, channels, dimensions, context) {
    const { x: x3, y: y3 } = scales;
    const { x: X3, y: Y3, rotate: R, text: T2, title: TL, fontSize: FS } = channels;
    const { rotate } = this;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyIndirectTextStyles, this, T2, dimensions).call(applyTransform, this, { x: X3 && x3, y: Y3 && y3 }).call(
      (g3) => g3.selectAll().data(index2).enter().append("text").call(applyDirectStyles, this).call(applyMultilineText, this, T2, TL).attr(
        "transform",
        template`translate(${X3 ? (i3) => X3[i3] : cx},${Y3 ? (i3) => Y3[i3] : cy})${R ? (i3) => ` rotate(${R[i3]})` : rotate ? ` rotate(${rotate})` : ``}`
      ).call(applyAttr, "font-size", FS && ((i3) => FS[i3])).call(applyChannelStyles, this, channels)
    ).node();
  }
};
function maybeTextOverflow(textOverflow) {
  return textOverflow == null ? null : keyword(textOverflow, "textOverflow", [
    "clip",
    // shorthand for clip-end
    "ellipsis",
    //  ellipsis-end
    "clip-start",
    "clip-end",
    "ellipsis-start",
    "ellipsis-middle",
    "ellipsis-end"
  ]).replace(/^(clip|ellipsis)$/, "$1-end");
}
function applyMultilineText(selection2, mark, T2, TL) {
  if (!T2)
    return;
  const { lineAnchor, lineHeight, textOverflow, splitLines, clipLine } = mark;
  selection2.each(function(i3) {
    const lines = splitLines(formatDefault(T2[i3]) ?? "").map(clipLine);
    const n2 = lines.length;
    const y3 = lineAnchor === "top" ? 0.71 : lineAnchor === "bottom" ? 1 - n2 : (164 - n2 * 100) / 200;
    if (n2 > 1) {
      let m3 = 0;
      for (let i4 = 0; i4 < n2; ++i4) {
        ++m3;
        if (!lines[i4])
          continue;
        const tspan = this.ownerDocument.createElementNS(namespaces_default.svg, "tspan");
        tspan.setAttribute("x", 0);
        if (i4 === m3 - 1)
          tspan.setAttribute("y", `${(y3 + i4) * lineHeight}em`);
        else
          tspan.setAttribute("dy", `${m3 * lineHeight}em`);
        tspan.textContent = lines[i4];
        this.appendChild(tspan);
        m3 = 0;
      }
    } else {
      if (y3)
        this.setAttribute("y", `${y3 * lineHeight}em`);
      this.textContent = lines[0];
    }
    if (textOverflow && !TL && lines[0] !== T2[i3]) {
      const title = this.ownerDocument.createElementNS(namespaces_default.svg, "title");
      title.textContent = T2[i3];
      this.appendChild(title);
    }
  });
}
function text(data, { x: x3, y: y3, ...options } = {}) {
  if (options.frameAnchor === void 0)
    [x3, y3] = maybeTuple(x3, y3);
  return new Text(data, { ...options, x: x3, y: y3 });
}
function textX(data, { x: x3 = identity6, ...options } = {}) {
  return new Text(data, maybeIntervalMidY({ ...options, x: x3 }));
}
function textY(data, { y: y3 = identity6, ...options } = {}) {
  return new Text(data, maybeIntervalMidX({ ...options, y: y3 }));
}
function applyIndirectTextStyles(selection2, mark, T2) {
  applyAttr(selection2, "text-anchor", mark.textAnchor);
  applyAttr(selection2, "font-family", mark.fontFamily);
  applyAttr(selection2, "font-size", mark.fontSize);
  applyAttr(selection2, "font-style", mark.fontStyle);
  applyAttr(selection2, "font-variant", mark.fontVariant === void 0 ? inferFontVariant2(T2) : mark.fontVariant);
  applyAttr(selection2, "font-weight", mark.fontWeight);
}
function inferFontVariant2(T2) {
  return T2 && (isNumeric(T2) || isTemporal(T2)) ? "tabular-nums" : void 0;
}
var fontSizes = /* @__PURE__ */ new Set([
  // global keywords
  "inherit",
  "initial",
  "revert",
  "unset",
  // absolute keywords
  "xx-small",
  "x-small",
  "small",
  "medium",
  "large",
  "x-large",
  "xx-large",
  "xxx-large",
  // relative keywords
  "larger",
  "smaller"
]);
function maybeFontSizeChannel(fontSize) {
  if (fontSize == null || typeof fontSize === "number")
    return [void 0, fontSize];
  if (typeof fontSize !== "string")
    return [fontSize, void 0];
  fontSize = fontSize.trim().toLowerCase();
  return fontSizes.has(fontSize) || /^[+-]?\d*\.?\d+(e[+-]?\d+)?(\w*|%)$/.test(fontSize) ? [void 0, fontSize] : [fontSize, void 0];
}
function lineWrap(input, maxWidth, widthof) {
  const lines = [];
  let lineStart, lineEnd = 0;
  for (const [wordStart, wordEnd, required] of lineBreaks(input)) {
    if (lineStart === void 0)
      lineStart = wordStart;
    if (lineEnd > lineStart && widthof(input, lineStart, wordEnd) > maxWidth) {
      lines.push(input.slice(lineStart, lineEnd) + (input[lineEnd - 1] === softHyphen ? "-" : ""));
      lineStart = wordStart;
    }
    if (required) {
      lines.push(input.slice(lineStart, wordEnd));
      lineStart = void 0;
      continue;
    }
    lineEnd = wordEnd;
  }
  return lines;
}
function* lineBreaks(input) {
  let i3 = 0, j3 = 0;
  const n2 = input.length;
  while (j3 < n2) {
    let k4 = 1;
    switch (input[j3]) {
      case softHyphen:
      case "-":
        ++j3;
        yield [i3, j3, false];
        i3 = j3;
        break;
      case " ":
        yield [i3, j3, false];
        while (input[++j3] === " ")
          ;
        i3 = j3;
        break;
      case "\r":
        if (input[j3 + 1] === "\n")
          ++k4;
      case "\n":
        yield [i3, j3, true];
        j3 += k4;
        i3 = j3;
        break;
      default:
        ++j3;
        break;
    }
  }
  yield [i3, j3, true];
}
var defaultWidthMap = {
  a: 56,
  b: 63,
  c: 57,
  d: 63,
  e: 58,
  f: 37,
  g: 62,
  h: 60,
  i: 26,
  j: 26,
  k: 55,
  l: 26,
  m: 88,
  n: 60,
  o: 60,
  p: 62,
  q: 62,
  r: 39,
  s: 54,
  t: 38,
  u: 60,
  v: 55,
  w: 79,
  x: 54,
  y: 55,
  z: 55,
  A: 69,
  B: 67,
  C: 73,
  D: 74,
  E: 61,
  F: 58,
  G: 76,
  H: 75,
  I: 28,
  J: 55,
  K: 67,
  L: 58,
  M: 89,
  N: 75,
  O: 78,
  P: 65,
  Q: 78,
  R: 67,
  S: 65,
  T: 65,
  U: 75,
  V: 69,
  W: 98,
  X: 69,
  Y: 67,
  Z: 67,
  0: 64,
  1: 48,
  2: 62,
  3: 64,
  4: 66,
  5: 63,
  6: 65,
  7: 58,
  8: 65,
  9: 65,
  " ": 29,
  "!": 32,
  '"': 49,
  "'": 31,
  "(": 39,
  ")": 39,
  ",": 31,
  "-": 48,
  ".": 31,
  "/": 32,
  ":": 31,
  ";": 31,
  "?": 52,
  "\u2018": 31,
  "\u2019": 31,
  "\u201C": 47,
  "\u201D": 47,
  "\u2026": 82
};
function defaultWidth(text2, start2 = 0, end = text2.length) {
  let sum2 = 0;
  for (let i3 = start2; i3 < end; i3 = readCharacter(text2, i3)) {
    sum2 += defaultWidthMap[text2[i3]] ?? (isPictographic(text2, i3) ? 120 : defaultWidthMap.e);
  }
  return sum2;
}
function monospaceWidth(text2, start2 = 0, end = text2.length) {
  let sum2 = 0;
  for (let i3 = start2; i3 < end; i3 = readCharacter(text2, i3)) {
    sum2 += isPictographic(text2, i3) ? 200 : 100;
  }
  return sum2;
}
function splitter({ monospace, lineWidth, textOverflow }) {
  if (textOverflow != null || lineWidth == Infinity)
    return (text2) => text2.split(/\r\n?|\n/g);
  const widthof = monospace ? monospaceWidth : defaultWidth;
  const maxWidth = lineWidth * 100;
  return (text2) => lineWrap(text2, maxWidth, widthof);
}
function clipper({ monospace, lineWidth, textOverflow }) {
  if (textOverflow == null || lineWidth == Infinity)
    return (text2) => text2;
  const widthof = monospace ? monospaceWidth : defaultWidth;
  const maxWidth = lineWidth * 100;
  switch (textOverflow) {
    case "clip-start":
      return (text2) => clipStart(text2, maxWidth, widthof, "");
    case "clip-end":
      return (text2) => clipEnd(text2, maxWidth, widthof, "");
    case "ellipsis-start":
      return (text2) => clipStart(text2, maxWidth, widthof, ellipsis);
    case "ellipsis-middle":
      return (text2) => clipMiddle(text2, maxWidth, widthof, ellipsis);
    case "ellipsis-end":
      return (text2) => clipEnd(text2, maxWidth, widthof, ellipsis);
  }
}
var ellipsis = "\u2026";
function cut(text2, width, widthof, inset) {
  const I2 = [];
  let w3 = 0;
  for (let i3 = 0, j3 = 0, n2 = text2.length; i3 < n2; i3 = j3) {
    j3 = readCharacter(text2, i3);
    const l3 = widthof(text2, i3, j3);
    if (w3 + l3 > width) {
      w3 += inset;
      while (w3 > width && i3 > 0)
        j3 = i3, i3 = I2.pop(), w3 -= widthof(text2, i3, j3);
      return [i3, width - w3];
    }
    w3 += l3;
    I2.push(i3);
  }
  return [-1, 0];
}
function clipEnd(text2, width, widthof, ellipsis2) {
  text2 = text2.trim();
  const e3 = widthof(ellipsis2);
  const [i3] = cut(text2, width, widthof, e3);
  return i3 < 0 ? text2 : text2.slice(0, i3).trimEnd() + ellipsis2;
}
function clipMiddle(text2, width, widthof, ellipsis2) {
  text2 = text2.trim();
  const w3 = widthof(text2);
  if (w3 <= width)
    return text2;
  const e3 = widthof(ellipsis2) / 2;
  const [i3, ei] = cut(text2, width / 2, widthof, e3);
  const [j3] = cut(text2, w3 - width / 2 - ei + e3, widthof, -e3);
  return j3 < 0 ? ellipsis2 : text2.slice(0, i3).trimEnd() + ellipsis2 + text2.slice(readCharacter(text2, j3)).trimStart();
}
function clipStart(text2, width, widthof, ellipsis2) {
  text2 = text2.trim();
  const w3 = widthof(text2);
  if (w3 <= width)
    return text2;
  const e3 = widthof(ellipsis2);
  const [j3] = cut(text2, w3 - width + e3, widthof, -e3);
  return j3 < 0 ? ellipsis2 : ellipsis2 + text2.slice(readCharacter(text2, j3)).trimStart();
}
var reCombiner = /[\p{Combining_Mark}\p{Emoji_Modifier}]+/uy;
var rePictographic = /\p{Extended_Pictographic}/uy;
function readCharacter(text2, i3) {
  i3 += isSurrogatePair(text2, i3) ? 2 : 1;
  if (isCombiner(text2, i3))
    i3 = reCombiner.lastIndex;
  if (isZeroWidthJoiner(text2, i3))
    return readCharacter(text2, i3 + 1);
  return i3;
}
function isAscii(text2, i3) {
  return text2.charCodeAt(i3) < 128;
}
function isSurrogatePair(text2, i3) {
  const hi = text2.charCodeAt(i3);
  if (hi >= 55296 && hi < 56320) {
    const lo = text2.charCodeAt(i3 + 1);
    return lo >= 56320 && lo < 57344;
  }
  return false;
}
function isZeroWidthJoiner(text2, i3) {
  return text2.charCodeAt(i3) === 8205;
}
function isCombiner(text2, i3) {
  return isAscii(text2, i3) ? false : (reCombiner.lastIndex = i3, reCombiner.test(text2));
}
function isPictographic(text2, i3) {
  return isAscii(text2, i3) ? false : (rePictographic.lastIndex = i3, rePictographic.test(text2));
}

// node_modules/@observablehq/plot/src/marks/vector.js
var defaults3 = {
  ariaLabel: "vector",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 1.5,
  strokeLinejoin: "round",
  strokeLinecap: "round"
};
var defaultRadius = 3.5;
var wingRatio = defaultRadius * 5;
var shapeArrow = {
  draw(context, l3, r3) {
    const wing = l3 * r3 / wingRatio;
    context.moveTo(0, 0);
    context.lineTo(0, -l3);
    context.moveTo(-wing, wing - l3);
    context.lineTo(0, -l3);
    context.lineTo(wing, wing - l3);
  }
};
var shapeSpike = {
  draw(context, l3, r3) {
    context.moveTo(-r3, 0);
    context.lineTo(0, -l3);
    context.lineTo(r3, 0);
  }
};
var shapes = /* @__PURE__ */ new Map([
  ["arrow", shapeArrow],
  ["spike", shapeSpike]
]);
function isShapeObject(value) {
  return value && typeof value.draw === "function";
}
function maybeShape(shape) {
  if (isShapeObject(shape))
    return shape;
  const value = shapes.get(`${shape}`.toLowerCase());
  if (value)
    return value;
  throw new Error(`invalid shape: ${shape}`);
}
var Vector = class extends Mark {
  constructor(data, options = {}) {
    const { x: x3, y: y3, r: r3 = defaultRadius, length: length3, rotate, shape = shapeArrow, anchor = "middle", frameAnchor } = options;
    const [vl, cl] = maybeNumberChannel(length3, 12);
    const [vr, cr] = maybeNumberChannel(rotate, 0);
    super(
      data,
      {
        x: { value: x3, scale: "x", optional: true },
        y: { value: y3, scale: "y", optional: true },
        length: { value: vl, scale: "length", optional: true },
        rotate: { value: vr, optional: true }
      },
      options,
      defaults3
    );
    this.r = +r3;
    this.length = cl;
    this.rotate = cr;
    this.shape = maybeShape(shape);
    this.anchor = keyword(anchor, "anchor", ["start", "middle", "end"]);
    this.frameAnchor = maybeFrameAnchor(frameAnchor);
  }
  render(index2, scales, channels, dimensions, context) {
    const { x: x3, y: y3 } = scales;
    const { x: X3, y: Y3, length: L2, rotate: A5 } = channels;
    const { length: length3, rotate, anchor, shape, r: r3 } = this;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x3, y: Y3 && y3 }).call(
      (g3) => g3.selectAll().data(index2).enter().append("path").call(applyDirectStyles, this).attr(
        "transform",
        template`translate(${X3 ? (i3) => X3[i3] : cx},${Y3 ? (i3) => Y3[i3] : cy})${A5 ? (i3) => ` rotate(${A5[i3]})` : rotate ? ` rotate(${rotate})` : ``}${anchor === "start" ? `` : anchor === "end" ? L2 ? (i3) => ` translate(0,${L2[i3]})` : ` translate(0,${length3})` : L2 ? (i3) => ` translate(0,${L2[i3] / 2})` : ` translate(0,${length3 / 2})`}`
      ).attr(
        "d",
        L2 ? (i3) => {
          const p3 = pathRound();
          shape.draw(p3, L2[i3], r3);
          return p3;
        } : (() => {
          const p3 = pathRound();
          shape.draw(p3, length3, r3);
          return p3;
        })()
      ).call(applyChannelStyles, this, channels)
    ).node();
  }
};
function vectorX(data, options = {}) {
  const { x: x3 = identity6, ...rest } = options;
  return new Vector(data, { ...rest, x: x3 });
}
function vectorY(data, options = {}) {
  const { y: y3 = identity6, ...rest } = options;
  return new Vector(data, { ...rest, y: y3 });
}

// node_modules/@observablehq/plot/src/marks/axis.js
function maybeData(data, options) {
  if (arguments.length < 2 && !isIterable(data))
    options = data, data = null;
  if (options === void 0)
    options = {};
  return [data, options];
}
function maybeAnchor2({ anchor } = {}, anchors) {
  return anchor === void 0 ? anchors[0] : keyword(anchor, "anchor", anchors);
}
function anchorY2(options) {
  return maybeAnchor2(options, ["left", "right"]);
}
function anchorFy(options) {
  return maybeAnchor2(options, ["right", "left"]);
}
function anchorX2(options) {
  return maybeAnchor2(options, ["bottom", "top"]);
}
function anchorFx(options) {
  return maybeAnchor2(options, ["top", "bottom"]);
}
function axisY() {
  const [data, options] = maybeData(...arguments);
  return axisKy("y", anchorY2(options), data, options);
}
function axisFy() {
  const [data, options] = maybeData(...arguments);
  return axisKy("fy", anchorFy(options), data, options);
}
function axisX() {
  const [data, options] = maybeData(...arguments);
  return axisKx("x", anchorX2(options), data, options);
}
function axisFx() {
  const [data, options] = maybeData(...arguments);
  return axisKx("fx", anchorFx(options), data, options);
}
function axisKy(k4, anchor, data, {
  color: color3 = "currentColor",
  opacity: opacity2 = 1,
  stroke = color3,
  strokeOpacity = opacity2,
  strokeWidth = 1,
  fill = color3,
  fillOpacity = opacity2,
  textAnchor,
  textStroke,
  textStrokeOpacity,
  textStrokeWidth,
  tickSize = k4 === "y" ? 6 : 0,
  tickPadding,
  tickRotate,
  x: x3,
  margin,
  marginTop = margin === void 0 ? 20 : margin,
  marginRight = margin === void 0 ? anchor === "right" ? 40 : 0 : margin,
  marginBottom = margin === void 0 ? 20 : margin,
  marginLeft = margin === void 0 ? anchor === "left" ? 40 : 0 : margin,
  label,
  labelAnchor,
  labelArrow,
  labelOffset,
  ...options
}) {
  tickSize = number5(tickSize);
  tickPadding = number5(tickPadding);
  tickRotate = number5(tickRotate);
  if (labelAnchor !== void 0)
    labelAnchor = keyword(labelAnchor, "labelAnchor", ["center", "top", "bottom"]);
  labelArrow = maybeLabelArrow(labelArrow);
  return marks(
    tickSize && !isNoneish(stroke) ? axisTickKy(k4, anchor, data, {
      stroke,
      strokeOpacity,
      strokeWidth,
      tickSize,
      tickPadding,
      tickRotate,
      x: x3,
      ...options
    }) : null,
    !isNoneish(fill) ? axisTextKy(k4, anchor, data, {
      fill,
      fillOpacity,
      stroke: textStroke,
      strokeOpacity: textStrokeOpacity,
      strokeWidth: textStrokeWidth,
      textAnchor,
      tickSize,
      tickPadding,
      tickRotate,
      x: x3,
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      ...options
    }) : null,
    !isNoneish(fill) && label !== null ? text(
      [],
      labelOptions({ fill, fillOpacity, ...options }, function(data2, facets, channels, scales, dimensions) {
        const scale = scales[k4];
        const { marginTop: marginTop2, marginRight: marginRight2, marginBottom: marginBottom2, marginLeft: marginLeft2 } = k4 === "y" && dimensions.inset || dimensions;
        const cla = labelAnchor ?? (scale.bandwidth ? "center" : "top");
        const clo = labelOffset ?? (anchor === "right" ? marginRight2 : marginLeft2) - 3;
        if (cla === "center") {
          this.textAnchor = void 0;
          this.lineAnchor = anchor === "right" ? "bottom" : "top";
          this.frameAnchor = anchor;
          this.rotate = -90;
        } else {
          this.textAnchor = anchor === "right" ? "end" : "start";
          this.lineAnchor = cla;
          this.frameAnchor = `${cla}-${anchor}`;
          this.rotate = 0;
        }
        this.dy = cla === "top" ? 3 - marginTop2 : cla === "bottom" ? marginBottom2 - 3 : 0;
        this.dx = anchor === "right" ? clo : -clo;
        this.ariaLabel = `${k4}-axis label`;
        return {
          facets: [[0]],
          channels: { text: { value: [formatAxisLabel(k4, scale, { anchor, label, labelAnchor: cla, labelArrow })] } }
        };
      })
    ) : null
  );
}
function axisKx(k4, anchor, data, {
  color: color3 = "currentColor",
  opacity: opacity2 = 1,
  stroke = color3,
  strokeOpacity = opacity2,
  strokeWidth = 1,
  fill = color3,
  fillOpacity = opacity2,
  textAnchor,
  textStroke,
  textStrokeOpacity,
  textStrokeWidth,
  tickSize = k4 === "x" ? 6 : 0,
  tickPadding,
  tickRotate,
  y: y3,
  margin,
  marginTop = margin === void 0 ? anchor === "top" ? 30 : 0 : margin,
  marginRight = margin === void 0 ? 20 : margin,
  marginBottom = margin === void 0 ? anchor === "bottom" ? 30 : 0 : margin,
  marginLeft = margin === void 0 ? 20 : margin,
  label,
  labelAnchor,
  labelArrow,
  labelOffset,
  ...options
}) {
  tickSize = number5(tickSize);
  tickPadding = number5(tickPadding);
  tickRotate = number5(tickRotate);
  if (labelAnchor !== void 0)
    labelAnchor = keyword(labelAnchor, "labelAnchor", ["center", "left", "right"]);
  labelArrow = maybeLabelArrow(labelArrow);
  return marks(
    tickSize && !isNoneish(stroke) ? axisTickKx(k4, anchor, data, {
      stroke,
      strokeOpacity,
      strokeWidth,
      tickSize,
      tickPadding,
      tickRotate,
      y: y3,
      ...options
    }) : null,
    !isNoneish(fill) ? axisTextKx(k4, anchor, data, {
      fill,
      fillOpacity,
      stroke: textStroke,
      strokeOpacity: textStrokeOpacity,
      strokeWidth: textStrokeWidth,
      textAnchor,
      tickSize,
      tickPadding,
      tickRotate,
      y: y3,
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      ...options
    }) : null,
    !isNoneish(fill) && label !== null ? text(
      [],
      labelOptions({ fill, fillOpacity, ...options }, function(data2, facets, channels, scales, dimensions) {
        const scale = scales[k4];
        const { marginTop: marginTop2, marginRight: marginRight2, marginBottom: marginBottom2, marginLeft: marginLeft2 } = k4 === "x" && dimensions.inset || dimensions;
        const cla = labelAnchor ?? (scale.bandwidth ? "center" : "right");
        const clo = labelOffset ?? (anchor === "top" ? marginTop2 : marginBottom2) - 3;
        if (cla === "center") {
          this.frameAnchor = anchor;
          this.textAnchor = void 0;
        } else {
          this.frameAnchor = `${anchor}-${cla}`;
          this.textAnchor = cla === "right" ? "end" : "start";
        }
        this.lineAnchor = anchor;
        this.dy = anchor === "top" ? -clo : clo;
        this.dx = cla === "right" ? marginRight2 - 3 : cla === "left" ? 3 - marginLeft2 : 0;
        this.ariaLabel = `${k4}-axis label`;
        return {
          facets: [[0]],
          channels: { text: { value: [formatAxisLabel(k4, scale, { anchor, label, labelAnchor: cla, labelArrow })] } }
        };
      })
    ) : null
  );
}
function axisTickKy(k4, anchor, data, {
  strokeWidth = 1,
  strokeLinecap = null,
  strokeLinejoin = null,
  facetAnchor = anchor + (k4 === "y" ? "-empty" : ""),
  frameAnchor = anchor,
  tickSize,
  inset = 0,
  insetLeft = inset,
  insetRight = inset,
  dx = 0,
  y: y3 = k4 === "y" ? void 0 : null,
  ...options
}) {
  return axisMark(vectorY, k4, anchor, `${k4}-axis tick`, data, {
    strokeWidth,
    strokeLinecap,
    strokeLinejoin,
    facetAnchor,
    frameAnchor,
    y: y3,
    ...options,
    dx: anchor === "left" ? +dx - offset + +insetLeft : +dx + offset - insetRight,
    anchor: "start",
    length: tickSize,
    shape: anchor === "left" ? shapeTickLeft : shapeTickRight
  });
}
function axisTickKx(k4, anchor, data, {
  strokeWidth = 1,
  strokeLinecap = null,
  strokeLinejoin = null,
  facetAnchor = anchor + (k4 === "x" ? "-empty" : ""),
  frameAnchor = anchor,
  tickSize,
  inset = 0,
  insetTop = inset,
  insetBottom = inset,
  dy = 0,
  x: x3 = k4 === "x" ? void 0 : null,
  ...options
}) {
  return axisMark(vectorX, k4, anchor, `${k4}-axis tick`, data, {
    strokeWidth,
    strokeLinejoin,
    strokeLinecap,
    facetAnchor,
    frameAnchor,
    x: x3,
    ...options,
    dy: anchor === "bottom" ? +dy - offset - insetBottom : +dy + offset + +insetTop,
    anchor: "start",
    length: tickSize,
    shape: anchor === "bottom" ? shapeTickBottom : shapeTickTop
  });
}
function axisTextKy(k4, anchor, data, {
  facetAnchor = anchor + (k4 === "y" ? "-empty" : ""),
  frameAnchor = anchor,
  tickSize,
  tickRotate = 0,
  tickPadding = Math.max(3, 9 - tickSize) + (Math.abs(tickRotate) > 60 ? 4 * Math.cos(tickRotate * radians3) : 0),
  text: text2,
  textAnchor = Math.abs(tickRotate) > 60 ? "middle" : anchor === "left" ? "end" : "start",
  lineAnchor = tickRotate > 60 ? "top" : tickRotate < -60 ? "bottom" : "middle",
  fontVariant,
  inset = 0,
  insetLeft = inset,
  insetRight = inset,
  dx = 0,
  y: y3 = k4 === "y" ? void 0 : null,
  ...options
}) {
  return axisMark(
    textY,
    k4,
    anchor,
    `${k4}-axis tick label`,
    data,
    {
      facetAnchor,
      frameAnchor,
      text: text2,
      textAnchor,
      lineAnchor,
      fontVariant,
      rotate: tickRotate,
      y: y3,
      ...options,
      dx: anchor === "left" ? +dx - tickSize - tickPadding + +insetLeft : +dx + +tickSize + +tickPadding - insetRight
    },
    function(scale, data2, ticks2, tickFormat2, channels) {
      if (fontVariant === void 0)
        this.fontVariant = inferFontVariant3(scale);
      if (text2 === void 0)
        channels.text = inferTextChannel(scale, data2, ticks2, tickFormat2, anchor);
    }
  );
}
function axisTextKx(k4, anchor, data, {
  facetAnchor = anchor + (k4 === "x" ? "-empty" : ""),
  frameAnchor = anchor,
  tickSize,
  tickRotate = 0,
  tickPadding = Math.max(3, 9 - tickSize) + (Math.abs(tickRotate) >= 10 ? 4 * Math.cos(tickRotate * radians3) : 0),
  text: text2,
  textAnchor = Math.abs(tickRotate) >= 10 ? tickRotate < 0 ^ anchor === "bottom" ? "start" : "end" : "middle",
  lineAnchor = Math.abs(tickRotate) >= 10 ? "middle" : anchor === "bottom" ? "top" : "bottom",
  fontVariant,
  inset = 0,
  insetTop = inset,
  insetBottom = inset,
  dy = 0,
  x: x3 = k4 === "x" ? void 0 : null,
  ...options
}) {
  return axisMark(
    textX,
    k4,
    anchor,
    `${k4}-axis tick label`,
    data,
    {
      facetAnchor,
      frameAnchor,
      text: text2 === void 0 ? null : text2,
      textAnchor,
      lineAnchor,
      fontVariant,
      rotate: tickRotate,
      x: x3,
      ...options,
      dy: anchor === "bottom" ? +dy + +tickSize + +tickPadding - insetBottom : +dy - tickSize - tickPadding + +insetTop
    },
    function(scale, data2, ticks2, tickFormat2, channels) {
      if (fontVariant === void 0)
        this.fontVariant = inferFontVariant3(scale);
      if (text2 === void 0)
        channels.text = inferTextChannel(scale, data2, ticks2, tickFormat2, anchor);
    }
  );
}
function gridY() {
  const [data, options] = maybeData(...arguments);
  return gridKy("y", anchorY2(options), data, options);
}
function gridFy() {
  const [data, options] = maybeData(...arguments);
  return gridKy("fy", anchorFy(options), data, options);
}
function gridX() {
  const [data, options] = maybeData(...arguments);
  return gridKx("x", anchorX2(options), data, options);
}
function gridFx() {
  const [data, options] = maybeData(...arguments);
  return gridKx("fx", anchorFx(options), data, options);
}
function gridKy(k4, anchor, data, {
  y: y3 = k4 === "y" ? void 0 : null,
  x: x3 = null,
  x1: x12 = anchor === "left" ? x3 : null,
  x2: x22 = anchor === "right" ? x3 : null,
  ...options
}) {
  return axisMark(ruleY, k4, anchor, `${k4}-grid`, data, { y: y3, x1: x12, x2: x22, ...gridDefaults(options) });
}
function gridKx(k4, anchor, data, {
  x: x3 = k4 === "x" ? void 0 : null,
  y: y3 = null,
  y1: y12 = anchor === "top" ? y3 : null,
  y2: y22 = anchor === "bottom" ? y3 : null,
  ...options
}) {
  return axisMark(ruleX, k4, anchor, `${k4}-grid`, data, { x: x3, y1: y12, y2: y22, ...gridDefaults(options) });
}
function gridDefaults({
  color: color3 = "currentColor",
  opacity: opacity2 = 0.1,
  stroke = color3,
  strokeOpacity = opacity2,
  strokeWidth = 1,
  ...options
}) {
  return { stroke, strokeOpacity, strokeWidth, ...options };
}
function labelOptions({
  fill,
  fillOpacity,
  fontFamily,
  fontSize,
  fontStyle,
  fontVariant,
  fontWeight,
  monospace,
  pointerEvents,
  shapeRendering,
  clip = false
}, initializer2) {
  [, fill] = maybeColorChannel(fill);
  [, fillOpacity] = maybeNumberChannel(fillOpacity);
  return {
    facet: "super",
    x: null,
    y: null,
    fill,
    fillOpacity,
    fontFamily,
    fontSize,
    fontStyle,
    fontVariant,
    fontWeight,
    monospace,
    pointerEvents,
    shapeRendering,
    clip,
    initializer: initializer2
  };
}
function axisMark(mark, k4, anchor, ariaLabel, data, options, initialize) {
  let channels;
  function axisInitializer(data2, facets, _channels, scales, dimensions, context) {
    const initializeFacets = data2 == null && (k4 === "fx" || k4 === "fy");
    const { [k4]: scale } = scales;
    if (!scale)
      throw new Error(`missing scale: ${k4}`);
    const domain = scale.domain();
    let { interval: interval2, ticks: ticks2, tickFormat: tickFormat2, tickSpacing = k4 === "x" ? 80 : 35 } = options;
    if (typeof ticks2 === "string" && hasTemporalDomain(scale))
      interval2 = ticks2, ticks2 = void 0;
    if (ticks2 === void 0)
      ticks2 = maybeRangeInterval(interval2, scale.type) ?? inferTickCount(scale, tickSpacing);
    if (data2 == null) {
      if (isIterable(ticks2)) {
        data2 = arrayify2(ticks2);
      } else if (isInterval(ticks2)) {
        data2 = inclusiveRange(ticks2, ...extent(domain));
      } else if (scale.interval) {
        let interval3 = scale.interval;
        if (scale.ticks) {
          const [min4, max3] = extent(domain);
          const n2 = (max3 - min4) / interval3[intervalDuration];
          interval3 = generalizeTimeInterval(interval3, n2 / ticks2) ?? interval3;
          data2 = inclusiveRange(interval3, min4, max3);
        } else {
          data2 = domain;
          const n2 = data2.length;
          interval3 = generalizeTimeInterval(interval3, n2 / ticks2) ?? interval3;
          if (interval3 !== scale.interval)
            data2 = inclusiveRange(interval3, ...extent(data2));
        }
        if (interval3 === scale.interval) {
          const n2 = Math.round(data2.length / ticks2);
          if (n2 > 1)
            data2 = data2.filter((d3, i3) => i3 % n2 === 0);
        }
      } else if (scale.ticks) {
        data2 = scale.ticks(ticks2);
      } else {
        data2 = domain;
      }
      if (!scale.ticks && data2.length && data2 !== domain) {
        const domainSet = new InternSet(domain);
        data2 = data2.filter((d3) => domainSet.has(d3));
        if (!data2.length)
          warn(`Warning: the ${k4}-axis ticks appear to not align with the scale domain, resulting in no ticks. Try different ticks?`);
      }
      if (k4 === "y" || k4 === "x") {
        facets = [range2(data2)];
      } else {
        channels[k4] = { scale: k4, value: identity6 };
      }
    }
    initialize?.call(this, scale, data2, ticks2, tickFormat2, channels);
    const initializedChannels = Object.fromEntries(
      Object.entries(channels).map(([name, channel]) => {
        return [name, { ...channel, value: valueof(data2, channel.value) }];
      })
    );
    if (initializeFacets)
      facets = context.filterFacets(data2, initializedChannels);
    return { data: data2, facets, channels: initializedChannels };
  }
  const basicInitializer = initializer(options).initializer;
  const m3 = mark(data, initializer({ ...options, initializer: axisInitializer }, basicInitializer));
  if (data == null) {
    channels = m3.channels;
    m3.channels = {};
  } else {
    channels = {};
  }
  m3.ariaLabel = ariaLabel;
  if (m3.clip === void 0)
    m3.clip = false;
  return m3;
}
function inferTickCount(scale, tickSpacing) {
  const [min4, max3] = extent(scale.range());
  return (max3 - min4) / tickSpacing;
}
function inferTextChannel(scale, data, ticks2, tickFormat2, anchor) {
  return { value: inferTickFormat(scale, data, ticks2, tickFormat2, anchor) };
}
function inferTickFormat(scale, data, ticks2, tickFormat2, anchor) {
  return typeof tickFormat2 === "function" ? tickFormat2 : tickFormat2 === void 0 && data && isTemporal(data) ? inferTimeFormat(data, anchor) ?? formatDefault : scale.tickFormat ? scale.tickFormat(typeof ticks2 === "number" ? ticks2 : null, tickFormat2) : tickFormat2 === void 0 ? formatDefault : typeof tickFormat2 === "string" ? (isTemporal(scale.domain()) ? utcFormat : format)(tickFormat2) : constant(tickFormat2);
}
function inclusiveRange(interval2, min4, max3) {
  return interval2.range(min4, interval2.offset(interval2.floor(max3)));
}
var shapeTickBottom = {
  draw(context, l3) {
    context.moveTo(0, 0);
    context.lineTo(0, l3);
  }
};
var shapeTickTop = {
  draw(context, l3) {
    context.moveTo(0, 0);
    context.lineTo(0, -l3);
  }
};
var shapeTickLeft = {
  draw(context, l3) {
    context.moveTo(0, 0);
    context.lineTo(-l3, 0);
  }
};
var shapeTickRight = {
  draw(context, l3) {
    context.moveTo(0, 0);
    context.lineTo(l3, 0);
  }
};
function inferFontVariant3(scale) {
  return scale.bandwidth && !scale.interval ? void 0 : "tabular-nums";
}
function inferScaleOrder(scale) {
  return Math.sign(orderof(scale.domain())) * Math.sign(orderof(scale.range()));
}
function formatAxisLabel(k4, scale, { anchor, label = scale.label, labelAnchor, labelArrow } = {}) {
  if (label == null || label.inferred && hasTemporalDomain(scale) && /^(date|time|year)$/i.test(label))
    return;
  label = String(label);
  if (labelArrow === "auto")
    labelArrow = (!scale.bandwidth || scale.interval) && !/[]/.test(label);
  if (!labelArrow)
    return label;
  if (labelArrow === true) {
    const order = inferScaleOrder(scale);
    if (order)
      labelArrow = /x$/.test(k4) || labelAnchor === "center" ? /x$/.test(k4) === order < 0 ? "left" : "right" : order < 0 ? "up" : "down";
  }
  switch (labelArrow) {
    case "left":
      return `\u2190 ${label}`;
    case "right":
      return `${label} \u2192`;
    case "up":
      return anchor === "right" ? `${label} \u2191` : `\u2191 ${label}`;
    case "down":
      return anchor === "right" ? `${label} \u2193` : `\u2193 ${label}`;
  }
  return label;
}
function maybeLabelArrow(labelArrow = "auto") {
  return isNoneish(labelArrow) ? false : typeof labelArrow === "boolean" ? labelArrow : keyword(labelArrow, "labelArrow", ["auto", "up", "right", "down", "left"]);
}
function hasTemporalDomain(scale) {
  return isTemporal(scale.domain());
}

// node_modules/@observablehq/plot/src/legends/swatches.js
function maybeScale(scale, key) {
  if (key == null)
    return key;
  const s4 = scale(key);
  if (!s4)
    throw new Error(`scale not found: ${key}`);
  return s4;
}
function legendSwatches(color3, { opacity: opacity2, ...options } = {}) {
  if (!isOrdinalScale(color3) && !isThresholdScale(color3))
    throw new Error(`swatches legend requires ordinal or threshold color scale (not ${color3.type})`);
  return legendItems(
    color3,
    options,
    (selection2, scale, width, height) => selection2.append("svg").attr("width", width).attr("height", height).attr("fill", scale.scale).attr("fill-opacity", maybeNumberChannel(opacity2)[1]).append("rect").attr("width", "100%").attr("height", "100%")
  );
}
function legendSymbols(symbol2, {
  fill = symbol2.hint?.fill !== void 0 ? symbol2.hint.fill : "none",
  fillOpacity = 1,
  stroke = symbol2.hint?.stroke !== void 0 ? symbol2.hint.stroke : isNoneish(fill) ? "currentColor" : "none",
  strokeOpacity = 1,
  strokeWidth = 1.5,
  r: r3 = 4.5,
  ...options
} = {}, scale) {
  const [vf, cf] = maybeColorChannel(fill);
  const [vs, cs] = maybeColorChannel(stroke);
  const sf = maybeScale(scale, vf);
  const ss = maybeScale(scale, vs);
  const size = r3 * r3 * Math.PI;
  fillOpacity = maybeNumberChannel(fillOpacity)[1];
  strokeOpacity = maybeNumberChannel(strokeOpacity)[1];
  strokeWidth = maybeNumberChannel(strokeWidth)[1];
  return legendItems(
    symbol2,
    options,
    (selection2, scale2, width, height) => selection2.append("svg").attr("viewBox", "-8 -8 16 16").attr("width", width).attr("height", height).attr("fill", vf === "color" ? (d3) => sf.scale(d3) : cf).attr("fill-opacity", fillOpacity).attr("stroke", vs === "color" ? (d3) => ss.scale(d3) : cs).attr("stroke-opacity", strokeOpacity).attr("stroke-width", strokeWidth).append("path").attr("d", (d3) => {
      const p3 = pathRound();
      symbol2.scale(d3).draw(p3, size);
      return p3;
    })
  );
}
function legendItems(scale, options = {}, swatch) {
  let {
    columns,
    tickFormat: tickFormat2,
    fontVariant = inferFontVariant(scale),
    // TODO label,
    swatchSize = 15,
    swatchWidth = swatchSize,
    swatchHeight = swatchSize,
    marginLeft = 0,
    className,
    style,
    width
  } = options;
  const context = createContext(options);
  className = maybeClassName(className);
  tickFormat2 = inferTickFormat(scale.scale, scale.domain, void 0, tickFormat2);
  const swatches = create2("div", context).attr(
    "class",
    `${className}-swatches ${className}-swatches-${columns != null ? "columns" : "wrap"}`
  );
  let extraStyle;
  if (columns != null) {
    extraStyle = `.${className}-swatches-columns .${className}-swatch {
  display: flex;
  align-items: center;
  break-inside: avoid;
  padding-bottom: 1px;
}
.${className}-swatches-columns .${className}-swatch::before {
  flex-shrink: 0;
}
.${className}-swatches-columns .${className}-swatch-label {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}`;
    swatches.style("columns", columns).selectAll().data(scale.domain).enter().append("div").attr("class", `${className}-swatch`).call(swatch, scale, swatchWidth, swatchHeight).call(
      (item) => item.append("div").attr("class", `${className}-swatch-label`).attr("title", tickFormat2).text(tickFormat2)
    );
  } else {
    extraStyle = `.${className}-swatches-wrap {
  display: flex;
  align-items: center;
  min-height: 33px;
  flex-wrap: wrap;
}
.${className}-swatches-wrap .${className}-swatch {
  display: inline-flex;
  align-items: center;
  margin-right: 1em;
}`;
    swatches.selectAll().data(scale.domain).enter().append("span").attr("class", `${className}-swatch`).call(swatch, scale, swatchWidth, swatchHeight).append(function() {
      return this.ownerDocument.createTextNode(tickFormat2.apply(this, arguments));
    });
  }
  return swatches.call(
    (div) => div.insert("style", "*").text(
      `.${className}-swatches {
  font-family: system-ui, sans-serif;
  font-size: 10px;
  margin-bottom: 0.5em;
}
.${className}-swatch > svg {
  margin-right: 0.5em;
  overflow: visible;
}
${extraStyle}`
    )
  ).style("margin-left", marginLeft ? `${+marginLeft}px` : null).style("width", width === void 0 ? null : `${+width}px`).style("font-variant", impliedString(fontVariant, "normal")).call(applyInlineStyles, style).node();
}

// node_modules/@observablehq/plot/src/legends.js
var legendRegistry = /* @__PURE__ */ new Map([
  ["symbol", legendSymbols],
  ["color", legendColor],
  ["opacity", legendOpacity]
]);
function exposeLegends(scales, context, defaults8 = {}) {
  return (key, options) => {
    if (!legendRegistry.has(key))
      throw new Error(`unknown legend type: ${key}`);
    if (!(key in scales))
      return;
    return legendRegistry.get(key)(scales[key], legendOptions(context, defaults8[key], options), (key2) => scales[key2]);
  };
}
function legendOptions({ className, ...context }, { label, ticks: ticks2, tickFormat: tickFormat2 } = {}, options) {
  return inherit2(options, { className, ...context }, { label, ticks: ticks2, tickFormat: tickFormat2 });
}
function legendColor(color3, { legend = true, ...options }) {
  if (legend === true)
    legend = color3.type === "ordinal" ? "swatches" : "ramp";
  if (color3.domain === void 0)
    return;
  switch (`${legend}`.toLowerCase()) {
    case "swatches":
      return legendSwatches(color3, options);
    case "ramp":
      return legendRamp(color3, options);
    default:
      throw new Error(`unknown legend type: ${legend}`);
  }
}
function legendOpacity({ type: type2, interpolate, ...scale }, { legend = true, color: color3 = rgb(0, 0, 0), ...options }) {
  if (!interpolate)
    throw new Error(`${type2} opacity scales are not supported`);
  if (legend === true)
    legend = "ramp";
  if (`${legend}`.toLowerCase() !== "ramp")
    throw new Error(`${legend} opacity legends are not supported`);
  return legendColor({ type: type2, ...scale, interpolate: interpolateOpacity(color3) }, { legend, ...options });
}
function interpolateOpacity(color3) {
  const { r: r3, g: g3, b: b3 } = rgb(color3) || rgb(0, 0, 0);
  return (t4) => `rgba(${r3},${g3},${b3},${t4})`;
}
function createLegends(scales, context, options) {
  const legends = [];
  for (const [key, value] of legendRegistry) {
    const o3 = options[key];
    if (o3?.legend && key in scales) {
      const legend = value(scales[key], legendOptions(context, scales[key], o3), (key2) => scales[key2]);
      if (legend != null)
        legends.push(legend);
    }
  }
  return legends;
}

// node_modules/@observablehq/plot/src/marks/frame.js
var defaults4 = {
  ariaLabel: "frame",
  fill: "none",
  stroke: "currentColor",
  clip: false
};
var lineDefaults = {
  ariaLabel: "frame",
  fill: null,
  stroke: "currentColor",
  strokeLinecap: "square",
  clip: false
};
var Frame = class extends Mark {
  constructor(options = {}) {
    const {
      anchor = null,
      inset = 0,
      insetTop = inset,
      insetRight = inset,
      insetBottom = inset,
      insetLeft = inset,
      rx,
      ry
    } = options;
    super(singleton, void 0, options, anchor == null ? defaults4 : lineDefaults);
    this.anchor = maybeKeyword(anchor, "anchor", ["top", "right", "bottom", "left"]);
    this.insetTop = number5(insetTop);
    this.insetRight = number5(insetRight);
    this.insetBottom = number5(insetBottom);
    this.insetLeft = number5(insetLeft);
    this.rx = number5(rx);
    this.ry = number5(ry);
  }
  render(index2, scales, channels, dimensions, context) {
    const { marginTop, marginRight, marginBottom, marginLeft, width, height } = dimensions;
    const { anchor, insetTop, insetRight, insetBottom, insetLeft, rx, ry } = this;
    const x12 = marginLeft + insetLeft;
    const x22 = width - marginRight - insetRight;
    const y12 = marginTop + insetTop;
    const y22 = height - marginBottom - insetBottom;
    return create2(anchor ? "svg:line" : "svg:rect", context).datum(0).call(applyIndirectStyles, this, dimensions, context).call(applyDirectStyles, this).call(applyChannelStyles, this, channels).call(applyTransform, this, {}).call(
      anchor === "left" ? (line) => line.attr("x1", x12).attr("x2", x12).attr("y1", y12).attr("y2", y22) : anchor === "right" ? (line) => line.attr("x1", x22).attr("x2", x22).attr("y1", y12).attr("y2", y22) : anchor === "top" ? (line) => line.attr("x1", x12).attr("x2", x22).attr("y1", y12).attr("y2", y12) : anchor === "bottom" ? (line) => line.attr("x1", x12).attr("x2", x22).attr("y1", y22).attr("y2", y22) : (rect) => rect.attr("x", x12).attr("y", y12).attr("width", x22 - x12).attr("height", y22 - y12).attr("rx", rx).attr("ry", ry)
    ).node();
  }
};
function frame2(options) {
  return new Frame(options);
}

// node_modules/@observablehq/plot/src/marks/tip.js
var defaults5 = {
  ariaLabel: "tip",
  fill: "white",
  stroke: "currentColor"
};
var ignoreChannels = /* @__PURE__ */ new Set(["geometry", "href", "src", "ariaLabel", "scales"]);
var Tip = class extends Mark {
  constructor(data, options = {}) {
    if (options.tip)
      options = { ...options, tip: false };
    if (options.title === void 0 && isIterable(data) && isTextual(data))
      options = { ...options, title: identity6 };
    const {
      x: x3,
      y: y3,
      x1: x12,
      x2: x22,
      y1: y12,
      y2: y22,
      anchor,
      monospace,
      fontFamily = monospace ? "ui-monospace, monospace" : void 0,
      fontSize,
      fontStyle,
      fontVariant,
      fontWeight,
      lineHeight = 1,
      lineWidth = 20,
      frameAnchor,
      format: format3,
      textAnchor = "start",
      textOverflow,
      textPadding = 8,
      title,
      pointerSize = 12,
      pathFilter = "drop-shadow(0 3px 4px rgba(0,0,0,0.2))"
    } = options;
    super(
      data,
      {
        x: { value: x12 != null && x22 != null ? null : x3, scale: "x", optional: true },
        // ignore midpoint
        y: { value: y12 != null && y22 != null ? null : y3, scale: "y", optional: true },
        // ignore midpoint
        x1: { value: x12, scale: "x", optional: x22 == null },
        y1: { value: y12, scale: "y", optional: y22 == null },
        x2: { value: x22, scale: "x", optional: x12 == null },
        y2: { value: y22, scale: "y", optional: y12 == null },
        title: { value: title, optional: true }
        // filter: defined
      },
      options,
      defaults5
    );
    this.anchor = maybeAnchor(anchor, "anchor");
    this.previousAnchor = this.anchor ?? "top-left";
    this.frameAnchor = maybeFrameAnchor(frameAnchor);
    this.textAnchor = impliedString(textAnchor, "middle");
    this.textPadding = +textPadding;
    this.pointerSize = +pointerSize;
    this.pathFilter = string(pathFilter);
    this.lineHeight = +lineHeight;
    this.lineWidth = +lineWidth;
    this.textOverflow = maybeTextOverflow(textOverflow);
    this.monospace = !!monospace;
    this.fontFamily = string(fontFamily);
    this.fontSize = number5(fontSize);
    this.fontStyle = string(fontStyle);
    this.fontVariant = string(fontVariant);
    this.fontWeight = string(fontWeight);
    for (const key in defaults5)
      if (key in this.channels)
        this[key] = defaults5[key];
    this.splitLines = splitter(this);
    this.clipLine = clipper(this);
    this.format = { ...format3 };
  }
  render(index2, scales, values2, dimensions, context) {
    const mark = this;
    const { x: x3, y: y3, fx, fy } = scales;
    const { ownerSVGElement: svg, document: document2 } = context;
    const { anchor, monospace, lineHeight, lineWidth } = this;
    const { textPadding: r3, pointerSize: m3, pathFilter } = this;
    const { marginTop, marginLeft } = dimensions;
    const { x1: X12, y1: Y12, x2: X22, y2: Y22, x: X3 = X12 ?? X22, y: Y3 = Y12 ?? Y22 } = values2;
    const ox = fx ? fx(index2.fx) - marginLeft : 0;
    const oy = fy ? fy(index2.fy) - marginTop : 0;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    const px = anchorX(values2, cx);
    const py = anchorY(values2, cy);
    const widthof = monospace ? monospaceWidth : defaultWidth;
    const ee = widthof(ellipsis);
    let sources, format3;
    if ("title" in values2) {
      sources = values2.channels;
      format3 = formatTitle;
    } else {
      sources = getSourceChannels.call(this, values2, scales);
      format3 = formatChannels;
    }
    const g3 = create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyIndirectTextStyles, this).call(applyTransform, this, { x: X3 && x3, y: Y3 && y3 }).call(
      (g4) => g4.selectAll().data(index2).enter().append("g").attr("transform", (i3) => `translate(${Math.round(px(i3))},${Math.round(py(i3))})`).call(applyDirectStyles, this).call((g5) => g5.append("path").attr("filter", pathFilter)).call(
        (g5) => g5.append("text").each(function(i3) {
          const that = select_default2(this);
          this.setAttribute("fill", "currentColor");
          this.setAttribute("fill-opacity", 1);
          this.setAttribute("stroke", "none");
          const lines = format3.call(mark, i3, index2, sources, scales, values2);
          if (typeof lines === "string") {
            for (const line of mark.splitLines(lines)) {
              renderLine(that, { value: mark.clipLine(line) });
            }
          } else {
            const labels = /* @__PURE__ */ new Set();
            for (const line of lines) {
              const { label = "" } = line;
              if (label && labels.has(label))
                continue;
              else
                labels.add(label);
              renderLine(that, line);
            }
          }
        })
      )
    );
    function renderLine(selection2, { label, value, color: color3, opacity: opacity2 }) {
      label ??= "", value ??= "";
      const swatch = color3 != null || opacity2 != null;
      let title;
      let w3 = lineWidth * 100;
      const [j3] = cut(label, w3, widthof, ee);
      if (j3 >= 0) {
        label = label.slice(0, j3).trimEnd() + ellipsis;
        title = value.trim();
        value = "";
      } else {
        if (label || !value && !swatch)
          value = " " + value;
        const [k4] = cut(value, w3 - widthof(label), widthof, ee);
        if (k4 >= 0) {
          value = value.slice(0, k4).trimEnd() + ellipsis;
          title = value.trim();
        }
      }
      const line = selection2.append("tspan").attr("x", 0).attr("dy", `${lineHeight}em`).text("\u200B");
      if (label)
        line.append("tspan").attr("font-weight", "bold").text(label);
      if (value)
        line.append(() => document2.createTextNode(value));
      if (swatch)
        line.append("tspan").text(" \u25A0").attr("fill", color3).attr("fill-opacity", opacity2).style("user-select", "none");
      if (title)
        line.append("title").text(title);
    }
    function postrender() {
      const { width, height } = dimensions.facet ?? dimensions;
      g3.selectChildren().each(function(i3) {
        let { x: tx, width: w3, height: h3 } = this.getBBox();
        w3 = Math.round(w3), h3 = Math.round(h3);
        let a4 = anchor;
        if (a4 === void 0) {
          a4 = mark.previousAnchor;
          const x4 = px(i3) + ox;
          const y4 = py(i3) + oy;
          const fitLeft = x4 + w3 + r3 * 2 < width;
          const fitRight = x4 - w3 - r3 * 2 > 0;
          const fitTop = y4 + h3 + m3 + r3 * 2 + 7 < height;
          const fitBottom = y4 - h3 - m3 - r3 * 2 > 0;
          const ax = (/-left$/.test(a4) ? fitLeft || !fitRight : fitLeft && !fitRight) ? "left" : "right";
          const ay = (/^top-/.test(a4) ? fitTop || !fitBottom : fitTop && !fitBottom) ? "top" : "bottom";
          a4 = mark.previousAnchor = `${ay}-${ax}`;
        }
        const path2 = this.firstChild;
        const text2 = this.lastChild;
        path2.setAttribute("d", getPath(a4, m3, r3, w3, h3));
        if (tx)
          for (const t4 of text2.childNodes)
            t4.setAttribute("x", -tx);
        text2.setAttribute("y", `${+getLineOffset(a4, text2.childNodes.length, lineHeight).toFixed(6)}em`);
        text2.setAttribute("transform", `translate(${getTextTranslate(a4, m3, r3, w3, h3)})`);
      });
      g3.attr("visibility", null);
    }
    if (index2.length) {
      g3.attr("visibility", "hidden");
      if (svg.isConnected)
        Promise.resolve().then(postrender);
      else if (typeof requestAnimationFrame !== "undefined")
        requestAnimationFrame(postrender);
    }
    return g3.node();
  }
};
function tip(data, { x: x3, y: y3, ...options } = {}) {
  if (options.frameAnchor === void 0)
    [x3, y3] = maybeTuple(x3, y3);
  return new Tip(data, { ...options, x: x3, y: y3 });
}
function getLineOffset(anchor, length3, lineHeight) {
  return /^top(?:-|$)/.test(anchor) ? 0.94 - lineHeight : /^bottom(?:-|$)/ ? -0.29 - length3 * lineHeight : length3 / 2 * lineHeight;
}
function getTextTranslate(anchor, m3, r3, width, height) {
  switch (anchor) {
    case "middle":
      return [-width / 2, height / 2];
    case "top-left":
      return [r3, m3 + r3];
    case "top":
      return [-width / 2, m3 / 2 + r3];
    case "top-right":
      return [-width - r3, m3 + r3];
    case "right":
      return [-m3 / 2 - width - r3, height / 2];
    case "bottom-left":
      return [r3, -m3 - r3];
    case "bottom":
      return [-width / 2, -m3 / 2 - r3];
    case "bottom-right":
      return [-width - r3, -m3 - r3];
    case "left":
      return [r3 + m3 / 2, height / 2];
  }
}
function getPath(anchor, m3, r3, width, height) {
  const w3 = width + r3 * 2;
  const h3 = height + r3 * 2;
  switch (anchor) {
    case "middle":
      return `M${-w3 / 2},${-h3 / 2}h${w3}v${h3}h${-w3}z`;
    case "top-left":
      return `M0,0l${m3},${m3}h${w3 - m3}v${h3}h${-w3}z`;
    case "top":
      return `M0,0l${m3 / 2},${m3 / 2}h${(w3 - m3) / 2}v${h3}h${-w3}v${-h3}h${(w3 - m3) / 2}z`;
    case "top-right":
      return `M0,0l${-m3},${m3}h${m3 - w3}v${h3}h${w3}z`;
    case "right":
      return `M0,0l${-m3 / 2},${-m3 / 2}v${m3 / 2 - h3 / 2}h${-w3}v${h3}h${w3}v${m3 / 2 - h3 / 2}z`;
    case "bottom-left":
      return `M0,0l${m3},${-m3}h${w3 - m3}v${-h3}h${-w3}z`;
    case "bottom":
      return `M0,0l${m3 / 2},${-m3 / 2}h${(w3 - m3) / 2}v${-h3}h${-w3}v${h3}h${(w3 - m3) / 2}z`;
    case "bottom-right":
      return `M0,0l${-m3},${-m3}h${m3 - w3}v${-h3}h${w3}z`;
    case "left":
      return `M0,0l${m3 / 2},${-m3 / 2}v${m3 / 2 - h3 / 2}h${w3}v${h3}h${-w3}v${m3 / 2 - h3 / 2}z`;
  }
}
function getSourceChannels({ channels }, scales) {
  const sources = {};
  let format3 = this.format;
  format3 = maybeExpandPairedFormat(format3, channels, "x");
  format3 = maybeExpandPairedFormat(format3, channels, "y");
  this.format = format3;
  for (const key in format3) {
    const value = format3[key];
    if (value === null || value === false) {
      continue;
    } else if (key === "fx" || key === "fy") {
      sources[key] = true;
    } else {
      const source = getSource(channels, key);
      if (source)
        sources[key] = source;
    }
  }
  for (const key in channels) {
    if (key in sources || key in format3 || ignoreChannels.has(key))
      continue;
    const source = getSource(channels, key);
    if (source)
      sources[key] = source;
  }
  if (this.facet) {
    if (scales.fx && !("fx" in format3))
      sources.fx = true;
    if (scales.fy && !("fy" in format3))
      sources.fy = true;
  }
  for (const key in sources) {
    const format4 = this.format[key];
    if (typeof format4 === "string") {
      const value = sources[key]?.value ?? scales[key]?.domain() ?? [];
      this.format[key] = (isTemporal(value) ? utcFormat : format)(format4);
    } else if (format4 === void 0 || format4 === true) {
      const scale = scales[key];
      this.format[key] = scale?.bandwidth ? inferTickFormat(scale, scale.domain()) : formatDefault;
    }
  }
  return sources;
}
function maybeExpandPairedFormat(format3, channels, key) {
  if (!(key in format3))
    return format3;
  const key1 = `${key}1`;
  const key2 = `${key}2`;
  if ((key1 in format3 || !(key1 in channels)) && (key2 in format3 || !(key2 in channels)))
    return format3;
  const entries = Object.entries(format3);
  const value = format3[key];
  entries.splice(entries.findIndex(([name]) => name === key) + 1, 0, [key1, value], [key2, value]);
  return Object.fromEntries(entries);
}
function formatTitle(i3, index2, { title }) {
  return formatDefault(title.value[i3], i3);
}
function* formatChannels(i3, index2, channels, scales, values2) {
  for (const key in channels) {
    if (key === "fx" || key === "fy") {
      yield {
        label: formatLabel(scales, channels, key),
        value: this.format[key](index2[key], i3)
      };
      continue;
    }
    if (key === "x1" && "x2" in channels)
      continue;
    if (key === "y1" && "y2" in channels)
      continue;
    const channel = channels[key];
    if (key === "x2" && "x1" in channels) {
      yield {
        label: formatPairLabel(scales, channels, "x"),
        value: formatPair(this.format.x2, channels.x1, channel, i3)
      };
    } else if (key === "y2" && "y1" in channels) {
      yield {
        label: formatPairLabel(scales, channels, "y"),
        value: formatPair(this.format.y2, channels.y1, channel, i3)
      };
    } else {
      const value = channel.value[i3];
      const scale = channel.scale;
      if (!defined(value) && scale == null)
        continue;
      yield {
        label: formatLabel(scales, channels, key),
        value: this.format[key](value, i3),
        color: scale === "color" ? values2[key][i3] : null,
        opacity: scale === "opacity" ? values2[key][i3] : null
      };
    }
  }
}
function formatPair(formatValue, c1, c22, i3) {
  return c22.hint?.length ? `${formatValue(c22.value[i3] - c1.value[i3], i3)}` : `${formatValue(c1.value[i3], i3)}\u2013${formatValue(c22.value[i3], i3)}`;
}
function formatPairLabel(scales, channels, key) {
  const l1 = formatLabel(scales, channels, `${key}1`, key);
  const l22 = formatLabel(scales, channels, `${key}2`, key);
  return l1 === l22 ? l1 : `${l1}\u2013${l22}`;
}
function formatLabel(scales, channels, key, defaultLabel = key) {
  const channel = channels[key];
  const scale = scales[channel?.scale ?? key];
  return String(scale?.label ?? channel?.label ?? defaultLabel);
}

// node_modules/@observablehq/plot/src/plot.js
function plot(options = {}) {
  const { facet, style, title, subtitle, caption, ariaLabel, ariaDescription } = options;
  const className = maybeClassName(options.className);
  const marks2 = options.marks === void 0 ? [] : flatMarks(options.marks);
  marks2.push(...inferTips(marks2));
  const topFacetState = maybeTopFacet(facet, options);
  const facetStateByMark = /* @__PURE__ */ new Map();
  for (const mark of marks2) {
    const facetState = maybeMarkFacet(mark, topFacetState, options);
    if (facetState)
      facetStateByMark.set(mark, facetState);
  }
  const channelsByScale = /* @__PURE__ */ new Map();
  if (topFacetState)
    addScaleChannels(channelsByScale, [topFacetState], options);
  addScaleChannels(channelsByScale, facetStateByMark, options);
  const axes = flatMarks(inferAxes(marks2, channelsByScale, options));
  for (const mark of axes) {
    const facetState = maybeMarkFacet(mark, topFacetState, options);
    if (facetState)
      facetStateByMark.set(mark, facetState);
  }
  marks2.unshift(...axes);
  let facets = createFacets(channelsByScale, options);
  if (facets !== void 0) {
    const topFacetsIndex = topFacetState ? facetFilter(facets, topFacetState) : void 0;
    for (const mark of marks2) {
      if (mark.facet === null || mark.facet === "super")
        continue;
      const facetState = facetStateByMark.get(mark);
      if (facetState === void 0)
        continue;
      facetState.facetsIndex = mark.fx != null || mark.fy != null ? facetFilter(facets, facetState) : topFacetsIndex;
    }
    const nonEmpty = /* @__PURE__ */ new Set();
    for (const { facetsIndex } of facetStateByMark.values()) {
      facetsIndex?.forEach((index2, i3) => {
        if (index2?.length > 0) {
          nonEmpty.add(i3);
        }
      });
    }
    facets.forEach(
      0 < nonEmpty.size && nonEmpty.size < facets.length ? (f3, i3) => f3.empty = !nonEmpty.has(i3) : (f3) => f3.empty = false
    );
    for (const mark of marks2) {
      if (mark.facet === "exclude") {
        const facetState = facetStateByMark.get(mark);
        if (facetState !== void 0)
          facetState.facetsIndex = facetExclude(facetState.facetsIndex);
      }
    }
  }
  for (const key of registry.keys()) {
    if (isScaleOptions(options[key]) && key !== "fx" && key !== "fy") {
      channelsByScale.set(key, []);
    }
  }
  const stateByMark = /* @__PURE__ */ new Map();
  for (const mark of marks2) {
    if (stateByMark.has(mark))
      throw new Error("duplicate mark; each mark must be unique");
    const { facetsIndex, channels: facetChannels } = facetStateByMark.get(mark) ?? {};
    const { data, facets: facets2, channels } = mark.initialize(facetsIndex, facetChannels, options);
    applyScaleTransforms(channels, options);
    stateByMark.set(mark, { data, facets: facets2, channels });
  }
  const scaleDescriptors = createScales(addScaleChannels(channelsByScale, stateByMark, options), options);
  const dimensions = createDimensions(scaleDescriptors, marks2, options);
  autoScaleRange(scaleDescriptors, dimensions);
  const scales = createScaleFunctions(scaleDescriptors);
  const { fx, fy } = scales;
  const subdimensions = fx || fy ? innerDimensions(scaleDescriptors, dimensions) : dimensions;
  const superdimensions = fx || fy ? actualDimensions(scales, dimensions) : dimensions;
  const context = createContext(options);
  const document2 = context.document;
  const svg = creator_default("svg").call(document2.documentElement);
  let figure = svg;
  context.ownerSVGElement = svg;
  context.className = className;
  context.projection = createProjection(options, subdimensions);
  context.filterFacets = (data, channels) => {
    return facetFilter(facets, { channels, groups: facetGroups(data, channels) });
  };
  context.getMarkState = (mark) => {
    const state = stateByMark.get(mark);
    const facetState = facetStateByMark.get(mark);
    return { ...state, channels: { ...state.channels, ...facetState?.channels } };
  };
  context.dispatchValue = (value) => {
    if (figure.value === value)
      return;
    figure.value = value;
    figure.dispatchEvent(new Event("input", { bubbles: true }));
  };
  const newByScale = /* @__PURE__ */ new Set();
  for (const [mark, state] of stateByMark) {
    if (mark.initializer != null) {
      const dimensions2 = mark.facet === "super" ? superdimensions : subdimensions;
      const update = mark.initializer(state.data, state.facets, state.channels, scales, dimensions2, context);
      if (update.data !== void 0) {
        state.data = update.data;
      }
      if (update.facets !== void 0) {
        state.facets = update.facets;
      }
      if (update.channels !== void 0) {
        const { fx: fx2, fy: fy2, ...channels } = update.channels;
        inferChannelScales(channels);
        Object.assign(state.channels, channels);
        for (const channel of Object.values(channels)) {
          const { scale } = channel;
          if (scale != null && !isPosition(registry.get(scale))) {
            applyScaleTransform(channel, options);
            newByScale.add(scale);
          }
        }
        if (fx2 != null || fy2 != null)
          facetStateByMark.set(mark, true);
      }
    }
  }
  if (newByScale.size) {
    const newChannelsByScale = /* @__PURE__ */ new Map();
    addScaleChannels(newChannelsByScale, stateByMark, options, (key) => newByScale.has(key));
    addScaleChannels(channelsByScale, stateByMark, options, (key) => newByScale.has(key));
    const newScaleDescriptors = inheritScaleLabels(createScales(newChannelsByScale, options), scaleDescriptors);
    const { scales: newExposedScales, ...newScales } = createScaleFunctions(newScaleDescriptors);
    Object.assign(scaleDescriptors, newScaleDescriptors);
    Object.assign(scales, newScales);
    Object.assign(scales.scales, newExposedScales);
  }
  let facetDomains, facetTranslate;
  if (facets !== void 0) {
    facetDomains = { x: fx?.domain(), y: fy?.domain() };
    facets = recreateFacets(facets, facetDomains);
    facetTranslate = facetTranslator(fx, fy, dimensions);
  }
  for (const [mark, state] of stateByMark) {
    state.values = mark.scale(state.channels, scales, context);
  }
  const { width, height } = dimensions;
  select_default2(svg).attr("class", className).attr("fill", "currentColor").attr("font-family", "system-ui, sans-serif").attr("font-size", 10).attr("text-anchor", "middle").attr("width", width).attr("height", height).attr("viewBox", `0 0 ${width} ${height}`).attr("aria-label", ariaLabel).attr("aria-description", ariaDescription).call(
    (svg2) => (
      // Warning: if you edit this, change defaultClassName.
      svg2.append("style").text(
        `.${className} {
  display: block;
  background: white;
  height: auto;
  height: intrinsic;
  max-width: 100%;
}
.${className} text,
.${className} tspan {
  white-space: pre;
}`
      )
    )
  ).call(applyInlineStyles, style);
  for (const mark of marks2) {
    const { channels, values: values2, facets: indexes2 } = stateByMark.get(mark);
    if (facets === void 0 || mark.facet === "super") {
      let index2 = null;
      if (indexes2) {
        index2 = indexes2[0];
        index2 = mark.filter(index2, channels, values2);
        if (index2.length === 0)
          continue;
      }
      const node = mark.render(index2, scales, values2, superdimensions, context);
      if (node == null)
        continue;
      svg.appendChild(node);
    } else {
      let g3;
      for (const f3 of facets) {
        if (!(mark.facetAnchor?.(facets, facetDomains, f3) ?? !f3.empty))
          continue;
        let index2 = null;
        if (indexes2) {
          const faceted = facetStateByMark.has(mark);
          index2 = indexes2[faceted ? f3.i : 0];
          index2 = mark.filter(index2, channels, values2);
          if (index2.length === 0)
            continue;
          if (!faceted && index2 === indexes2[0])
            index2 = subarray(index2);
          index2.fx = f3.x, index2.fy = f3.y, index2.fi = f3.i;
        }
        const node = mark.render(index2, scales, values2, subdimensions, context);
        if (node == null)
          continue;
        (g3 ??= select_default2(svg).append("g")).append(() => node).datum(f3);
        for (const name of ["aria-label", "aria-description", "aria-hidden", "transform"]) {
          if (node.hasAttribute(name)) {
            g3.attr(name, node.getAttribute(name));
            node.removeAttribute(name);
          }
        }
      }
      g3?.selectChildren().attr("transform", facetTranslate);
    }
  }
  const legends = createLegends(scaleDescriptors, context, options);
  const { figure: figured = title != null || subtitle != null || caption != null || legends.length > 0 } = options;
  if (figured) {
    figure = document2.createElement("figure");
    figure.className = `${className}-figure`;
    figure.style.maxWidth = "initial";
    if (title != null)
      figure.append(createTitleElement(document2, title, "h2"));
    if (subtitle != null)
      figure.append(createTitleElement(document2, subtitle, "h3"));
    figure.append(...legends, svg);
    if (caption != null)
      figure.append(createFigcaption(document2, caption));
  }
  figure.scale = exposeScales(scales.scales);
  figure.legend = exposeLegends(scaleDescriptors, context, options);
  const w3 = consumeWarnings();
  if (w3 > 0) {
    select_default2(svg).append("text").attr("x", width).attr("y", 20).attr("dy", "-1em").attr("text-anchor", "end").attr("font-family", "initial").text("\u26A0\uFE0F").append("title").text(`${w3.toLocaleString("en-US")} warning${w3 === 1 ? "" : "s"}. Please check the console.`);
  }
  return figure;
}
function createTitleElement(document2, contents, tag) {
  if (contents.ownerDocument)
    return contents;
  const e3 = document2.createElement(tag);
  e3.append(contents);
  return e3;
}
function createFigcaption(document2, caption) {
  const e3 = document2.createElement("figcaption");
  e3.append(caption);
  return e3;
}
function plotThis({ marks: marks2 = [], ...options } = {}) {
  return plot({ ...options, marks: [...marks2, this] });
}
Mark.prototype.plot = plotThis;
function flatMarks(marks2) {
  return marks2.flat(Infinity).filter((mark) => mark != null).map(markify);
}
function markify(mark) {
  return typeof mark.render === "function" ? mark : new Render(mark);
}
var Render = class extends Mark {
  constructor(render) {
    if (typeof render !== "function")
      throw new TypeError("invalid mark; missing render function");
    super();
    this.render = render;
  }
  render() {
  }
};
function applyScaleTransforms(channels, options) {
  for (const name in channels)
    applyScaleTransform(channels[name], options);
  return channels;
}
function applyScaleTransform(channel, options) {
  const { scale, transform: t4 = true } = channel;
  if (scale == null || !t4)
    return;
  const {
    type: type2,
    percent,
    interval: interval2,
    transform: transform2 = percent ? (x3) => x3 * 100 : maybeIntervalTransform(interval2, type2)
  } = options[scale] ?? {};
  if (transform2 == null)
    return;
  channel.value = map2(channel.value, transform2);
  channel.transform = false;
}
function inferChannelScales(channels) {
  for (const name in channels) {
    inferChannelScale(name, channels[name]);
  }
}
function addScaleChannels(channelsByScale, stateByMark, options, filter2 = yes) {
  for (const { channels } of stateByMark.values()) {
    for (const name in channels) {
      const channel = channels[name];
      const { scale } = channel;
      if (scale != null && filter2(scale)) {
        if (scale === "projection") {
          if (!hasProjection(options)) {
            const gx = options.x?.domain === void 0;
            const gy = options.y?.domain === void 0;
            if (gx || gy) {
              const [x3, y3] = getGeometryChannels(channel);
              if (gx)
                addScaleChannel(channelsByScale, "x", x3);
              if (gy)
                addScaleChannel(channelsByScale, "y", y3);
            }
          }
        } else {
          addScaleChannel(channelsByScale, scale, channel);
        }
      }
    }
  }
  return channelsByScale;
}
function addScaleChannel(channelsByScale, scale, channel) {
  const scaleChannels = channelsByScale.get(scale);
  if (scaleChannels !== void 0)
    scaleChannels.push(channel);
  else
    channelsByScale.set(scale, [channel]);
}
function maybeTopFacet(facet, options) {
  if (facet == null)
    return;
  const { x: x3, y: y3 } = facet;
  if (x3 == null && y3 == null)
    return;
  const data = arrayify2(facet.data);
  if (data == null)
    throw new Error("missing facet data");
  const channels = {};
  if (x3 != null)
    channels.fx = createChannel(data, { value: x3, scale: "fx" });
  if (y3 != null)
    channels.fy = createChannel(data, { value: y3, scale: "fy" });
  applyScaleTransforms(channels, options);
  const groups2 = facetGroups(data, channels);
  return { channels, groups: groups2, data: facet.data };
}
function maybeMarkFacet(mark, topFacetState, options) {
  if (mark.facet === null || mark.facet === "super")
    return;
  const { fx, fy } = mark;
  if (fx != null || fy != null) {
    const data2 = arrayify2(mark.data ?? fx ?? fy);
    if (data2 === void 0)
      throw new Error(`missing facet data in ${mark.ariaLabel}`);
    if (data2 === null)
      return;
    const channels2 = {};
    if (fx != null)
      channels2.fx = createChannel(data2, { value: fx, scale: "fx" });
    if (fy != null)
      channels2.fy = createChannel(data2, { value: fy, scale: "fy" });
    applyScaleTransforms(channels2, options);
    return { channels: channels2, groups: facetGroups(data2, channels2) };
  }
  if (topFacetState === void 0)
    return;
  const { channels, groups: groups2, data } = topFacetState;
  if (mark.facet !== "auto" || mark.data === data)
    return { channels, groups: groups2 };
  if (data.length > 0 && (groups2.size > 1 || groups2.size === 1 && channels.fx && channels.fy && [...groups2][0][1].size > 1) && arrayify2(mark.data)?.length === data.length) {
    warn(
      `Warning: the ${mark.ariaLabel} mark appears to use faceted data, but isn\u2019t faceted. The mark data has the same length as the facet data and the mark facet option is "auto", but the mark data and facet data are distinct. If this mark should be faceted, set the mark facet option to true; otherwise, suppress this warning by setting the mark facet option to false.`
    );
  }
}
function derive(mark, options = {}) {
  return initializer({ ...options, x: null, y: null }, (data, facets, channels, scales, dimensions, context) => {
    return context.getMarkState(mark);
  });
}
function inferTips(marks2) {
  const tips = [];
  for (const mark of marks2) {
    let tipOptions = mark.tip;
    if (tipOptions) {
      if (tipOptions === true)
        tipOptions = {};
      else if (typeof tipOptions === "string")
        tipOptions = { pointer: tipOptions };
      let { pointer: p3 } = tipOptions;
      p3 = /^x$/i.test(p3) ? pointerX : /^y$/i.test(p3) ? pointerY : pointer;
      tipOptions = p3(derive(mark, tipOptions));
      tipOptions.title = null;
      const t4 = tip(mark.data, tipOptions);
      t4.facet = mark.facet;
      t4.facetAnchor = mark.facetAnchor;
      tips.push(t4);
    }
  }
  return tips;
}
function inferAxes(marks2, channelsByScale, options) {
  let {
    projection: projection3,
    x: x3 = {},
    y: y3 = {},
    fx = {},
    fy = {},
    axis: axis2,
    grid,
    facet = {},
    facet: { axis: facetAxis = axis2, grid: facetGrid } = facet,
    x: { axis: xAxis = axis2, grid: xGrid = xAxis === null ? null : grid } = x3,
    y: { axis: yAxis = axis2, grid: yGrid = yAxis === null ? null : grid } = y3,
    fx: { axis: fxAxis = facetAxis, grid: fxGrid = fxAxis === null ? null : facetGrid } = fx,
    fy: { axis: fyAxis = facetAxis, grid: fyGrid = fyAxis === null ? null : facetGrid } = fy
  } = options;
  if (projection3 || !isScaleOptions(x3) && !hasPositionChannel("x", marks2))
    xAxis = xGrid = null;
  if (projection3 || !isScaleOptions(y3) && !hasPositionChannel("y", marks2))
    yAxis = yGrid = null;
  if (!channelsByScale.has("fx"))
    fxAxis = fxGrid = null;
  if (!channelsByScale.has("fy"))
    fyAxis = fyGrid = null;
  if (xAxis === void 0)
    xAxis = !hasAxis(marks2, "x");
  if (yAxis === void 0)
    yAxis = !hasAxis(marks2, "y");
  if (fxAxis === void 0)
    fxAxis = !hasAxis(marks2, "fx");
  if (fyAxis === void 0)
    fyAxis = !hasAxis(marks2, "fy");
  if (xAxis === true)
    xAxis = "bottom";
  if (yAxis === true)
    yAxis = "left";
  if (fxAxis === true)
    fxAxis = xAxis === "top" || xAxis === null ? "bottom" : "top";
  if (fyAxis === true)
    fyAxis = yAxis === "right" || yAxis === null ? "left" : "right";
  const axes = [];
  maybeGrid(axes, fyGrid, gridFy, fy);
  maybeAxis(axes, fyAxis, axisFy, "right", "left", facet, fy);
  maybeGrid(axes, fxGrid, gridFx, fx);
  maybeAxis(axes, fxAxis, axisFx, "top", "bottom", facet, fx);
  maybeGrid(axes, yGrid, gridY, y3);
  maybeAxis(axes, yAxis, axisY, "left", "right", options, y3);
  maybeGrid(axes, xGrid, gridX, x3);
  maybeAxis(axes, xAxis, axisX, "bottom", "top", options, x3);
  return axes;
}
function maybeAxis(axes, axis2, axisType, primary, secondary, defaults8, options) {
  if (!axis2)
    return;
  const both = isBoth(axis2);
  options = axisOptions(both ? primary : axis2, defaults8, options);
  const { line } = options;
  if ((axisType === axisY || axisType === axisX) && line && !isNone(line))
    axes.push(frame2(lineOptions(options)));
  axes.push(axisType(options));
  if (both)
    axes.push(axisType({ ...options, anchor: secondary, label: null }));
}
function maybeGrid(axes, grid, gridType, options) {
  if (!grid || isNone(grid))
    return;
  axes.push(gridType(gridOptions(grid, options)));
}
function isBoth(value) {
  return /^\s*both\s*$/i.test(value);
}
function axisOptions(anchor, defaults8, {
  line = defaults8.line,
  ticks: ticks2,
  tickSize,
  tickSpacing,
  tickPadding,
  tickFormat: tickFormat2,
  tickRotate,
  fontVariant,
  ariaLabel,
  ariaDescription,
  label = defaults8.label,
  labelAnchor,
  labelArrow = defaults8.labelArrow,
  labelOffset
}) {
  return {
    anchor,
    line,
    ticks: ticks2,
    tickSize,
    tickSpacing,
    tickPadding,
    tickFormat: tickFormat2,
    tickRotate,
    fontVariant,
    ariaLabel,
    ariaDescription,
    label,
    labelAnchor,
    labelArrow,
    labelOffset
  };
}
function lineOptions(options) {
  const { anchor, line } = options;
  return { anchor, facetAnchor: anchor + "-empty", stroke: line === true ? void 0 : line };
}
function gridOptions(grid, {
  stroke = isColor(grid) ? grid : void 0,
  ticks: ticks2 = isGridTicks(grid) ? grid : void 0,
  tickSpacing,
  ariaLabel,
  ariaDescription
}) {
  return {
    stroke,
    ticks: ticks2,
    tickSpacing,
    ariaLabel,
    ariaDescription
  };
}
function isGridTicks(grid) {
  switch (typeof grid) {
    case "number":
      return true;
    case "string":
      return !isColor(grid);
  }
  return isIterable(grid) || typeof grid?.range === "function";
}
function hasAxis(marks2, k4) {
  const prefix = `${k4}-axis `;
  return marks2.some((m3) => m3.ariaLabel?.startsWith(prefix));
}
function hasPositionChannel(k4, marks2) {
  for (const mark of marks2) {
    for (const key in mark.channels) {
      const { scale } = mark.channels[key];
      if (scale === k4 || scale === "projection") {
        return true;
      }
    }
  }
  return false;
}
function inheritScaleLabels(newScales, scales) {
  for (const key in newScales) {
    const newScale = newScales[key];
    const scale = scales[key];
    if (newScale.label === void 0 && scale) {
      newScale.label = scale.label;
    }
  }
  return newScales;
}
function actualDimensions({ fx, fy }, dimensions) {
  const { marginTop, marginRight, marginBottom, marginLeft, width, height } = outerDimensions(dimensions);
  const fxr = fx && outerRange(fx);
  const fyr = fy && outerRange(fy);
  return {
    marginTop: fy ? fyr[0] : marginTop,
    marginRight: fx ? width - fxr[1] : marginRight,
    marginBottom: fy ? height - fyr[1] : marginBottom,
    marginLeft: fx ? fxr[0] : marginLeft,
    // Some marks, namely the x- and y-axis labels, want to know what the
    // desired (rather than actual) margins are for positioning.
    inset: {
      marginTop: dimensions.marginTop,
      marginRight: dimensions.marginRight,
      marginBottom: dimensions.marginBottom,
      marginLeft: dimensions.marginLeft
    },
    width,
    height
  };
}
function outerRange(scale) {
  const domain = scale.domain();
  let x12 = scale(domain[0]);
  let x22 = scale(domain[domain.length - 1]);
  if (x22 < x12)
    [x12, x22] = [x22, x12];
  return [x12, x22 + scale.bandwidth()];
}

// node_modules/@observablehq/plot/src/transforms/bin.js
function binX(outputs = { y: "count" }, options = {}) {
  [outputs, options] = mergeOptions(outputs, options);
  const { x: x3, y: y3 } = options;
  return binn(maybeBinValue(x3, options, identity6), null, null, y3, outputs, maybeInsetX(options));
}
function maybeDenseInterval(bin, k4, options = {}) {
  if (options?.interval == null)
    return options;
  const { reduce = reduceFirst } = options;
  const outputs = { filter: null };
  if (options[k4] != null)
    outputs[k4] = reduce;
  if (options[`${k4}1`] != null)
    outputs[`${k4}1`] = reduce;
  if (options[`${k4}2`] != null)
    outputs[`${k4}2`] = reduce;
  return bin(outputs, options);
}
function maybeDenseIntervalX(options = {}) {
  return maybeDenseInterval(binX, "y", withTip(options, "x"));
}
function binn(bx, by, gx, gy, {
  data: reduceData = reduceIdentity,
  // TODO avoid materializing when unused?
  filter: filter2 = reduceCount,
  // return only non-empty bins by default
  sort: sort3,
  reverse: reverse2,
  ...outputs
  // output channel definitions
} = {}, inputs = {}) {
  bx = maybeBin(bx);
  by = maybeBin(by);
  outputs = maybeBinOutputs(outputs, inputs);
  reduceData = maybeBinReduce(reduceData, identity6);
  sort3 = sort3 == null ? void 0 : maybeBinOutput("sort", sort3, inputs);
  filter2 = filter2 == null ? void 0 : maybeBinEvaluator("filter", filter2, inputs);
  if (gx != null && hasOutput(outputs, "x", "x1", "x2"))
    gx = null;
  if (gy != null && hasOutput(outputs, "y", "y1", "y2"))
    gy = null;
  const [BX1, setBX1] = maybeColumn(bx);
  const [BX2, setBX2] = maybeColumn(bx);
  const [BY1, setBY1] = maybeColumn(by);
  const [BY2, setBY2] = maybeColumn(by);
  const [k4, gk] = gx != null ? [gx, "x"] : gy != null ? [gy, "y"] : [];
  const [GK, setGK] = maybeColumn(k4);
  const {
    x: x3,
    y: y3,
    z: z3,
    fill,
    stroke,
    x1: x12,
    x2: x22,
    // consumed if x is an output
    y1: y12,
    y2: y22,
    // consumed if y is an output
    domain,
    cumulative,
    thresholds,
    interval: interval2,
    ...options
  } = inputs;
  const [GZ, setGZ] = maybeColumn(z3);
  const [vfill] = maybeColorChannel(fill);
  const [vstroke] = maybeColorChannel(stroke);
  const [GF, setGF] = maybeColumn(vfill);
  const [GS, setGS] = maybeColumn(vstroke);
  return {
    ..."z" in inputs && { z: GZ || z3 },
    ..."fill" in inputs && { fill: GF || fill },
    ..."stroke" in inputs && { stroke: GS || stroke },
    ...basic(options, (data, facets, plotOptions) => {
      const K2 = maybeApplyInterval(valueof(data, k4), plotOptions?.[gk]);
      const Z = valueof(data, z3);
      const F2 = valueof(data, vfill);
      const S2 = valueof(data, vstroke);
      const G = maybeSubgroup(outputs, { z: Z, fill: F2, stroke: S2 });
      const groupFacets = [];
      const groupData = [];
      const GK2 = K2 && setGK([]);
      const GZ2 = Z && setGZ([]);
      const GF2 = F2 && setGF([]);
      const GS2 = S2 && setGS([]);
      const BX12 = bx && setBX1([]);
      const BX22 = bx && setBX2([]);
      const BY12 = by && setBY1([]);
      const BY22 = by && setBY2([]);
      const bin = bing(bx?.(data), by?.(data));
      let i3 = 0;
      for (const o3 of outputs)
        o3.initialize(data);
      if (sort3)
        sort3.initialize(data);
      if (filter2)
        filter2.initialize(data);
      for (const facet of facets) {
        const groupFacet = [];
        for (const o3 of outputs)
          o3.scope("facet", facet);
        if (sort3)
          sort3.scope("facet", facet);
        if (filter2)
          filter2.scope("facet", facet);
        for (const [f3, I2] of maybeGroup(facet, G)) {
          for (const [k5, g3] of maybeGroup(I2, K2)) {
            for (const [b3, extent2] of bin(g3)) {
              if (filter2 && !filter2.reduce(b3, extent2))
                continue;
              groupFacet.push(i3++);
              groupData.push(reduceData.reduceIndex(b3, data, extent2));
              if (K2)
                GK2.push(k5);
              if (Z)
                GZ2.push(G === Z ? f3 : Z[(b3.length > 0 ? b3 : g3)[0]]);
              if (F2)
                GF2.push(G === F2 ? f3 : F2[(b3.length > 0 ? b3 : g3)[0]]);
              if (S2)
                GS2.push(G === S2 ? f3 : S2[(b3.length > 0 ? b3 : g3)[0]]);
              if (BX12)
                BX12.push(extent2.x1), BX22.push(extent2.x2);
              if (BY12)
                BY12.push(extent2.y1), BY22.push(extent2.y2);
              for (const o3 of outputs)
                o3.reduce(b3, extent2);
              if (sort3)
                sort3.reduce(b3);
            }
          }
        }
        groupFacets.push(groupFacet);
      }
      maybeSort(groupFacets, sort3, reverse2);
      return { data: groupData, facets: groupFacets };
    }),
    ...!hasOutput(outputs, "x") && (BX1 ? { x1: BX1, x2: BX2, x: mid(BX1, BX2) } : { x: x3, x1: x12, x2: x22 }),
    ...!hasOutput(outputs, "y") && (BY1 ? { y1: BY1, y2: BY2, y: mid(BY1, BY2) } : { y: y3, y1: y12, y2: y22 }),
    ...GK && { [gk]: GK },
    ...Object.fromEntries(outputs.map(({ name, output }) => [name, output]))
  };
}
function mergeOptions({ cumulative, domain, thresholds, interval: interval2, ...outputs }, options) {
  return [outputs, { cumulative, domain, thresholds, interval: interval2, ...options }];
}
function maybeBinValue(value, { cumulative, domain, thresholds, interval: interval2 }, defaultValue) {
  value = { ...maybeValue(value) };
  if (value.domain === void 0)
    value.domain = domain;
  if (value.cumulative === void 0)
    value.cumulative = cumulative;
  if (value.thresholds === void 0)
    value.thresholds = thresholds;
  if (value.interval === void 0)
    value.interval = interval2;
  if (value.value === void 0)
    value.value = defaultValue;
  value.thresholds = maybeThresholds(value.thresholds, value.interval);
  return value;
}
function maybeBin(options) {
  if (options == null)
    return;
  const { value, cumulative, domain = extent, thresholds } = options;
  const bin = (data) => {
    let V = valueof(data, value);
    let T2;
    if (isTemporal(V) || isTimeThresholds(thresholds)) {
      V = map2(V, coerceDate, Float64Array);
      let [min4, max3] = typeof domain === "function" ? domain(V) : domain;
      let t4 = typeof thresholds === "function" && !isInterval(thresholds) ? thresholds(V, min4, max3) : thresholds;
      if (typeof t4 === "number")
        t4 = utcTickInterval(min4, max3, t4);
      if (isInterval(t4)) {
        if (domain === extent) {
          min4 = t4.floor(min4);
          max3 = t4.offset(t4.floor(max3));
        }
        t4 = t4.range(min4, t4.offset(max3));
      }
      T2 = t4;
    } else {
      V = coerceNumbers(V);
      let [min4, max3] = typeof domain === "function" ? domain(V) : domain;
      let t4 = typeof thresholds === "function" && !isInterval(thresholds) ? thresholds(V, min4, max3) : thresholds;
      if (typeof t4 === "number") {
        if (domain === extent) {
          let step = tickIncrement(min4, max3, t4);
          if (isFinite(step)) {
            if (step > 0) {
              let r0 = Math.round(min4 / step);
              let r1 = Math.round(max3 / step);
              if (!(r0 * step <= min4))
                --r0;
              if (!(r1 * step > max3))
                ++r1;
              let n2 = r1 - r0 + 1;
              t4 = new Float64Array(n2);
              for (let i3 = 0; i3 < n2; ++i3)
                t4[i3] = (r0 + i3) * step;
            } else if (step < 0) {
              step = -step;
              let r0 = Math.round(min4 * step);
              let r1 = Math.round(max3 * step);
              if (!(r0 / step <= min4))
                --r0;
              if (!(r1 / step > max3))
                ++r1;
              let n2 = r1 - r0 + 1;
              t4 = new Float64Array(n2);
              for (let i3 = 0; i3 < n2; ++i3)
                t4[i3] = (r0 + i3) / step;
            } else {
              t4 = [min4];
            }
          } else {
            t4 = [min4];
          }
        } else {
          t4 = ticks(min4, max3, t4);
        }
      } else if (isInterval(t4)) {
        if (domain === extent) {
          min4 = t4.floor(min4);
          max3 = t4.offset(t4.floor(max3));
        }
        t4 = t4.range(min4, t4.offset(max3));
      }
      T2 = t4;
    }
    const E2 = [];
    if (T2.length === 1)
      E2.push([T2[0], T2[0]]);
    else
      for (let i3 = 1; i3 < T2.length; ++i3)
        E2.push([T2[i3 - 1], T2[i3]]);
    E2.bin = (cumulative < 0 ? bin1cn : cumulative > 0 ? bin1cp : bin1)(E2, T2, V);
    return E2;
  };
  bin.label = labelof(value);
  return bin;
}
function maybeThresholds(thresholds, interval2, defaultThresholds = thresholdAuto) {
  if (thresholds === void 0) {
    return interval2 === void 0 ? defaultThresholds : maybeRangeInterval(interval2);
  }
  if (typeof thresholds === "string") {
    switch (thresholds.toLowerCase()) {
      case "freedman-diaconis":
        return thresholdFreedmanDiaconis;
      case "scott":
        return thresholdScott;
      case "sturges":
        return thresholdSturges;
      case "auto":
        return thresholdAuto;
    }
    return maybeUtcInterval(thresholds);
  }
  return thresholds;
}
function maybeBinOutputs(outputs, inputs) {
  return maybeOutputs(outputs, inputs, maybeBinOutput);
}
function maybeBinOutput(name, reduce, inputs) {
  return maybeOutput(name, reduce, inputs, maybeBinEvaluator);
}
function maybeBinEvaluator(name, reduce, inputs) {
  return maybeEvaluator(name, reduce, inputs, maybeBinReduce);
}
function maybeBinReduce(reduce, value) {
  return maybeReduce(reduce, value, maybeBinReduceFallback);
}
function maybeBinReduceFallback(reduce) {
  switch (`${reduce}`.toLowerCase()) {
    case "x":
      return reduceX;
    case "x1":
      return reduceX1;
    case "x2":
      return reduceX2;
    case "y":
      return reduceY;
    case "y1":
      return reduceY1;
    case "y2":
      return reduceY2;
  }
  throw new Error(`invalid bin reduce: ${reduce}`);
}
function thresholdAuto(values2, min4, max3) {
  return Math.min(200, thresholdScott(values2, min4, max3));
}
function isTimeThresholds(t4) {
  return isTimeInterval(t4) || isIterable(t4) && isTemporal(t4);
}
function bing(EX, EY) {
  return EX && EY ? function* (I2) {
    const X3 = EX.bin(I2);
    for (const [ix, [x12, x22]] of EX.entries()) {
      const Y3 = EY.bin(X3[ix]);
      for (const [iy, [y12, y22]] of EY.entries()) {
        yield [Y3[iy], { x1: x12, y1: y12, x2: x22, y2: y22 }];
      }
    }
  } : EX ? function* (I2) {
    const X3 = EX.bin(I2);
    for (const [i3, [x12, x22]] of EX.entries()) {
      yield [X3[i3], { x1: x12, x2: x22 }];
    }
  } : function* (I2) {
    const Y3 = EY.bin(I2);
    for (const [i3, [y12, y22]] of EY.entries()) {
      yield [Y3[i3], { y1: y12, y2: y22 }];
    }
  };
}
function bin1(E2, T2, V) {
  T2 = coerceNumbers(T2);
  return (I2) => {
    const B4 = E2.map(() => []);
    for (const i3 of I2)
      B4[bisect_default(T2, V[i3]) - 1]?.push(i3);
    return B4;
  };
}
function bin1cp(E2, T2, V) {
  const bin = bin1(E2, T2, V);
  return (I2) => {
    const B4 = bin(I2);
    for (let i3 = 1, n2 = B4.length; i3 < n2; ++i3) {
      const C2 = B4[i3 - 1];
      const b3 = B4[i3];
      for (const j3 of C2)
        b3.push(j3);
    }
    return B4;
  };
}
function bin1cn(E2, T2, V) {
  const bin = bin1(E2, T2, V);
  return (I2) => {
    const B4 = bin(I2);
    for (let i3 = B4.length - 2; i3 >= 0; --i3) {
      const C2 = B4[i3 + 1];
      const b3 = B4[i3];
      for (const j3 of C2)
        b3.push(j3);
    }
    return B4;
  };
}
function mid1(x12, x22) {
  const m3 = (+x12 + +x22) / 2;
  return x12 instanceof Date ? new Date(m3) : m3;
}
var reduceX = {
  reduceIndex(I2, X3, { x1: x12, x2: x22 }) {
    return mid1(x12, x22);
  }
};
var reduceY = {
  reduceIndex(I2, X3, { y1: y12, y2: y22 }) {
    return mid1(y12, y22);
  }
};
var reduceX1 = {
  reduceIndex(I2, X3, { x1: x12 }) {
    return x12;
  }
};
var reduceX2 = {
  reduceIndex(I2, X3, { x2: x22 }) {
    return x22;
  }
};
var reduceY1 = {
  reduceIndex(I2, X3, { y1: y12 }) {
    return y12;
  }
};
var reduceY2 = {
  reduceIndex(I2, X3, { y2: y22 }) {
    return y22;
  }
};

// node_modules/@observablehq/plot/src/marks/dot.js
var defaults6 = {
  ariaLabel: "dot",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 1.5
};
function withDefaultSort(options) {
  return options.sort === void 0 && options.reverse === void 0 ? sort2({ channel: "-r" }, options) : options;
}
var Dot = class extends Mark {
  constructor(data, options = {}) {
    const { x: x3, y: y3, r: r3, rotate, symbol: symbol2 = circle_default2, frameAnchor } = options;
    const [vrotate, crotate] = maybeNumberChannel(rotate, 0);
    const [vsymbol, csymbol] = maybeSymbolChannel(symbol2);
    const [vr, cr] = maybeNumberChannel(r3, vsymbol == null ? 3 : 4.5);
    super(
      data,
      {
        x: { value: x3, scale: "x", optional: true },
        y: { value: y3, scale: "y", optional: true },
        r: { value: vr, scale: "r", filter: positive, optional: true },
        rotate: { value: vrotate, optional: true },
        symbol: { value: vsymbol, scale: "auto", optional: true }
      },
      withDefaultSort(options),
      defaults6
    );
    this.r = cr;
    this.rotate = crotate;
    this.symbol = csymbol;
    this.frameAnchor = maybeFrameAnchor(frameAnchor);
    const { channels } = this;
    const { symbol: symbolChannel } = channels;
    if (symbolChannel) {
      const { fill: fillChannel, stroke: strokeChannel } = channels;
      symbolChannel.hint = {
        fill: fillChannel ? fillChannel.value === symbolChannel.value ? "color" : "currentColor" : this.fill ?? "currentColor",
        stroke: strokeChannel ? strokeChannel.value === symbolChannel.value ? "color" : "currentColor" : this.stroke ?? "none"
      };
    }
  }
  render(index2, scales, channels, dimensions, context) {
    const { x: x3, y: y3 } = scales;
    const { x: X3, y: Y3, r: R, rotate: A5, symbol: S2 } = channels;
    const { r: r3, rotate, symbol: symbol2 } = this;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    const circle2 = symbol2 === circle_default2;
    const size = R ? void 0 : r3 * r3 * Math.PI;
    if (negative(r3))
      index2 = [];
    return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x3, y: Y3 && y3 }).call(
      (g3) => g3.selectAll().data(index2).enter().append(circle2 ? "circle" : "path").call(applyDirectStyles, this).call(
        circle2 ? (selection2) => {
          selection2.attr("cx", X3 ? (i3) => X3[i3] : cx).attr("cy", Y3 ? (i3) => Y3[i3] : cy).attr("r", R ? (i3) => R[i3] : r3);
        } : (selection2) => {
          selection2.attr(
            "transform",
            template`translate(${X3 ? (i3) => X3[i3] : cx},${Y3 ? (i3) => Y3[i3] : cy})${A5 ? (i3) => ` rotate(${A5[i3]})` : rotate ? ` rotate(${rotate})` : ``}`
          ).attr(
            "d",
            R && S2 ? (i3) => {
              const p3 = pathRound();
              S2[i3].draw(p3, R[i3] * R[i3] * Math.PI);
              return p3;
            } : R ? (i3) => {
              const p3 = pathRound();
              symbol2.draw(p3, R[i3] * R[i3] * Math.PI);
              return p3;
            } : S2 ? (i3) => {
              const p3 = pathRound();
              S2[i3].draw(p3, size);
              return p3;
            } : (() => {
              const p3 = pathRound();
              symbol2.draw(p3, size);
              return p3;
            })()
          );
        }
      ).call(applyChannelStyles, this, channels)
    ).node();
  }
};
function dot(data, { x: x3, y: y3, ...options } = {}) {
  if (options.frameAnchor === void 0)
    [x3, y3] = maybeTuple(x3, y3);
  return new Dot(data, { ...options, x: x3, y: y3 });
}

// node_modules/@observablehq/plot/src/stats.js
function ibetainv(p3, a4, b3) {
  var EPS = 1e-8;
  var a1 = a4 - 1;
  var b1 = b3 - 1;
  var j3 = 0;
  var lna, lnb, pp, t4, u3, err, x3, al, h3, w3, afac;
  if (p3 <= 0)
    return 0;
  if (p3 >= 1)
    return 1;
  if (a4 >= 1 && b3 >= 1) {
    pp = p3 < 0.5 ? p3 : 1 - p3;
    t4 = Math.sqrt(-2 * Math.log(pp));
    x3 = (2.30753 + t4 * 0.27061) / (1 + t4 * (0.99229 + t4 * 0.04481)) - t4;
    if (p3 < 0.5)
      x3 = -x3;
    al = (x3 * x3 - 3) / 6;
    h3 = 2 / (1 / (2 * a4 - 1) + 1 / (2 * b3 - 1));
    w3 = x3 * Math.sqrt(al + h3) / h3 - (1 / (2 * b3 - 1) - 1 / (2 * a4 - 1)) * (al + 5 / 6 - 2 / (3 * h3));
    x3 = a4 / (a4 + b3 * Math.exp(2 * w3));
  } else {
    lna = Math.log(a4 / (a4 + b3));
    lnb = Math.log(b3 / (a4 + b3));
    t4 = Math.exp(a4 * lna) / a4;
    u3 = Math.exp(b3 * lnb) / b3;
    w3 = t4 + u3;
    if (p3 < t4 / w3)
      x3 = Math.pow(a4 * w3 * p3, 1 / a4);
    else
      x3 = 1 - Math.pow(b3 * w3 * (1 - p3), 1 / b3);
  }
  afac = -gammaln(a4) - gammaln(b3) + gammaln(a4 + b3);
  for (; j3 < 10; j3++) {
    if (x3 === 0 || x3 === 1)
      return x3;
    err = ibeta(x3, a4, b3) - p3;
    t4 = Math.exp(a1 * Math.log(x3) + b1 * Math.log(1 - x3) + afac);
    u3 = err / t4;
    x3 -= t4 = u3 / (1 - 0.5 * Math.min(1, u3 * (a1 / x3 - b1 / (1 - x3))));
    if (x3 <= 0)
      x3 = 0.5 * (x3 + t4);
    if (x3 >= 1)
      x3 = 0.5 * (x3 + t4 + 1);
    if (Math.abs(t4) < EPS * x3 && j3 > 0)
      break;
  }
  return x3;
}
function ibeta(x3, a4, b3) {
  var bt = x3 === 0 || x3 === 1 ? 0 : Math.exp(gammaln(a4 + b3) - gammaln(a4) - gammaln(b3) + a4 * Math.log(x3) + b3 * Math.log(1 - x3));
  if (x3 < 0 || x3 > 1)
    return false;
  if (x3 < (a4 + 1) / (a4 + b3 + 2))
    return bt * betacf(x3, a4, b3) / a4;
  return 1 - bt * betacf(1 - x3, b3, a4) / b3;
}
function betacf(x3, a4, b3) {
  var fpmin = 1e-30;
  var m3 = 1;
  var qab = a4 + b3;
  var qap = a4 + 1;
  var qam = a4 - 1;
  var c6 = 1;
  var d3 = 1 - qab * x3 / qap;
  var m22, aa, del, h3;
  if (Math.abs(d3) < fpmin)
    d3 = fpmin;
  d3 = 1 / d3;
  h3 = d3;
  for (; m3 <= 100; m3++) {
    m22 = 2 * m3;
    aa = m3 * (b3 - m3) * x3 / ((qam + m22) * (a4 + m22));
    d3 = 1 + aa * d3;
    if (Math.abs(d3) < fpmin)
      d3 = fpmin;
    c6 = 1 + aa / c6;
    if (Math.abs(c6) < fpmin)
      c6 = fpmin;
    d3 = 1 / d3;
    h3 *= d3 * c6;
    aa = -(a4 + m3) * (qab + m3) * x3 / ((a4 + m22) * (qap + m22));
    d3 = 1 + aa * d3;
    if (Math.abs(d3) < fpmin)
      d3 = fpmin;
    c6 = 1 + aa / c6;
    if (Math.abs(c6) < fpmin)
      c6 = fpmin;
    d3 = 1 / d3;
    del = d3 * c6;
    h3 *= del;
    if (Math.abs(del - 1) < 3e-7)
      break;
  }
  return h3;
}
function gammaln(x3) {
  var j3 = 0;
  var cof = [
    76.18009172947146,
    -86.5053203294167,
    24.01409824083091,
    -1.231739572450155,
    0.001208650973866179,
    -5395239384953e-18
  ];
  var ser = 1.000000000190015;
  var xx, y3, tmp;
  tmp = (y3 = xx = x3) + 5.5;
  tmp -= (xx + 0.5) * Math.log(tmp);
  for (; j3 < 6; j3++)
    ser += cof[j3] / ++y3;
  return Math.log(2.506628274631 * ser / xx) - tmp;
}
function qt(p3, dof) {
  var x3 = ibetainv(2 * Math.min(p3, 1 - p3), 0.5 * dof, 0.5);
  x3 = Math.sqrt(dof * (1 - x3) / x3);
  return p3 > 0.5 ? x3 : -x3;
}

// node_modules/@observablehq/plot/src/marks/linearRegression.js
var defaults7 = {
  ariaLabel: "linear-regression",
  fill: "currentColor",
  fillOpacity: 0.1,
  stroke: "currentColor",
  strokeWidth: 1.5,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeMiterlimit: 1
};
var LinearRegression = class extends Mark {
  constructor(data, options = {}) {
    const { x: x3, y: y3, z: z3, ci = 0.95, precision = 4 } = options;
    super(
      data,
      {
        x: { value: x3, scale: "x" },
        y: { value: y3, scale: "y" },
        z: { value: maybeZ(options), optional: true }
      },
      options,
      defaults7
    );
    this.z = z3;
    this.ci = +ci;
    this.precision = +precision;
    if (!(0 <= this.ci && this.ci < 1))
      throw new Error(`invalid ci; not in [0, 1): ${ci}`);
    if (!(this.precision > 0))
      throw new Error(`invalid precision: ${precision}`);
  }
  render(index2, scales, channels, dimensions, context) {
    const { x: X3, y: Y3, z: Z } = channels;
    const { ci } = this;
    return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call(
      (g3) => g3.selectAll().data(Z ? groupZ(index2, Z, this.z) : [index2]).enter().call(
        (enter) => enter.append("path").attr("fill", "none").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, { ...channels, fill: null, fillOpacity: null }).attr("d", (I2) => this._renderLine(I2, X3, Y3)).call(
          ci && !isNone(this.fill) ? (path2) => path2.select(pathBefore).attr("stroke", "none").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, {
            ...channels,
            stroke: null,
            strokeOpacity: null,
            strokeWidth: null
          }).attr("d", (I2) => this._renderBand(I2, X3, Y3)) : () => {
          }
        )
      )
    ).node();
  }
};
function pathBefore() {
  return this.parentNode.insertBefore(this.ownerDocument.createElementNS(namespaces_default.svg, "path"), this);
}
var LinearRegressionY = class extends LinearRegression {
  constructor(data, options) {
    super(data, options);
  }
  _renderBand(I2, X3, Y3) {
    const { ci, precision } = this;
    const [x12, x22] = extent(I2, (i3) => X3[i3]);
    const f3 = linearRegressionF(I2, X3, Y3);
    const g3 = confidenceIntervalF(I2, X3, Y3, (1 - ci) / 2, f3);
    return area_default2().x((x3) => x3).y0((x3) => g3(x3, -1)).y1((x3) => g3(x3, 1))(range(x12, x22 - precision / 2, precision).concat(x22));
  }
  _renderLine(I2, X3, Y3) {
    const [x12, x22] = extent(I2, (i3) => X3[i3]);
    const f3 = linearRegressionF(I2, X3, Y3);
    return `M${x12},${f3(x12)}L${x22},${f3(x22)}`;
  }
};
function linearRegressionY(data, { x: x3 = indexOf, y: y3 = identity6, stroke, fill = isNoneish(stroke) ? "currentColor" : stroke, ...options } = {}) {
  return new LinearRegressionY(data, maybeDenseIntervalX({ ...options, x: x3, y: y3, fill, stroke }));
}
function linearRegressionF(I2, X3, Y3) {
  let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
  for (const i3 of I2) {
    const xi = X3[i3];
    const yi = Y3[i3];
    sumX += xi;
    sumY += yi;
    sumXY += xi * yi;
    sumX2 += xi * xi;
  }
  const n2 = I2.length;
  const slope = (n2 * sumXY - sumX * sumY) / (n2 * sumX2 - sumX * sumX);
  const intercept = (sumY - slope * sumX) / n2;
  return (x3) => slope * x3 + intercept;
}
function confidenceIntervalF(I2, X3, Y3, p3, f3) {
  const mean2 = sum(I2, (i3) => X3[i3]) / I2.length;
  let a4 = 0, b3 = 0;
  for (const i3 of I2) {
    a4 += (X3[i3] - mean2) ** 2;
    b3 += (Y3[i3] - f3(X3[i3])) ** 2;
  }
  const sy = Math.sqrt(b3 / (I2.length - 2));
  const t4 = qt(p3, I2.length - 2);
  return (x3, k4) => {
    const Y4 = f3(x3);
    const se = sy * Math.sqrt(1 / I2.length + (x3 - mean2) ** 2 / a4);
    return Y4 + k4 * t4 * se;
  };
}

// datasette_plot/frontend/targets/main.tsx
var dataUrl = window.location.origin + window.location.pathname + ".json" + window.location.search;
function DotForm(props) {
  const [x3, setX] = h2(props.columns[0]);
  const [y3, setY] = h2(props.columns[1]);
  const [fill, setFill] = h2(props.columns[2]);
  p2(() => {
    props.onUpdate({ x: x3, y: y3, fill, tip: true });
  }, [x3, y3, fill]);
  return /* @__PURE__ */ y("div", null, /* @__PURE__ */ y("div", null, /* @__PURE__ */ y("span", null, "X"), /* @__PURE__ */ y(
    "select",
    {
      value: x3,
      onChange: (e3) => setX(e3.target.value)
    },
    props.columns.map((c6) => /* @__PURE__ */ y("option", { key: c6 }, c6))
  )), /* @__PURE__ */ y("div", null, /* @__PURE__ */ y("span", null, "Y"), /* @__PURE__ */ y(
    "select",
    {
      value: y3,
      onChange: (e3) => setY(e3.target.value)
    },
    props.columns.map((c6) => /* @__PURE__ */ y("option", { key: c6 }, c6))
  )), /* @__PURE__ */ y("div", null, /* @__PURE__ */ y("span", null, "Fill"), /* @__PURE__ */ y(
    "select",
    {
      value: fill,
      onChange: (e3) => setFill(e3.target.value)
    },
    props.columns.map((c6) => /* @__PURE__ */ y("option", { key: c6 }, c6))
  )));
}
function PlotEditor(props) {
  const [show, setShow] = h2(false);
  const [marks2, setMarks] = h2([]);
  if (!show) {
    return /* @__PURE__ */ y("div", null, /* @__PURE__ */ y("button", { onClick: () => setShow(true) }, "Show Plot"));
  }
  return /* @__PURE__ */ y("div", null, /* @__PURE__ */ y("b", null, "Marks"), marks2.map((mark, idx) => /* @__PURE__ */ y(
    DotForm,
    {
      columns: props.columns,
      onUpdate: (options) => {
        setMarks(marks2.map((d3, i3) => i3 === idx ? options : d3));
      }
    }
  )), /* @__PURE__ */ y(
    "button",
    {
      onClick: () => {
        setMarks([...marks2, {}]);
      }
    },
    "Add mark"
  ), /* @__PURE__ */ y("div", null, /* @__PURE__ */ y("strong", null, "Preview"), /* @__PURE__ */ y(Preview, { data: props.data, marks: marks2 })), /* @__PURE__ */ y("div", null, /* @__PURE__ */ y("button", { onClick: () => setShow(false) }, "Hide")));
}
function Preview(props) {
  const target = _(null);
  p2(() => {
    if (!target.current)
      return;
    const p3 = plot({ marks: props.marks.map((m3) => dot(props.data, m3)) });
    target.current.appendChild(p3);
    return () => target.current.removeChild(p3);
  }, [target, props.data, props.marks]);
  return /* @__PURE__ */ y("div", { ref: target });
}
async function main() {
  const data = (await fetch(dataUrl).then((r3) => r3.json())).rows;
  console.log(data);
  const penguins = data;
  const p3 = plot({
    grid: true,
    color: { legend: true },
    marks: [
      dot(penguins, {
        x: "culmen_length_mm",
        y: "culmen_depth_mm",
        fill: "species"
      }),
      linearRegressionY(penguins, {
        x: "culmen_length_mm",
        y: "culmen_depth_mm",
        stroke: "species"
      }),
      linearRegressionY(penguins, {
        x: "culmen_length_mm",
        y: "culmen_depth_mm"
      })
    ]
  });
  const target = document.querySelector("form");
  const root2 = document.createElement("div");
  target.insertAdjacentElement("afterend", root2);
  const preact = root2.appendChild(document.createElement("div"));
  const columns = Object.keys(data[0]);
  B(
    /* @__PURE__ */ y("div", null, /* @__PURE__ */ y(PlotEditor, { data, columns })),
    preact
  );
}
main();
